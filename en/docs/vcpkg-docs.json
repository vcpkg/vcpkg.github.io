[{"Path":"/en/docs/README.html","Name":"README","Source":"### Quick Start\n\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/README.md).**\n\nVcpkg helps you manage C and C++ libraries on Windows, Linux and MacOS. This tool and ecosystem are constantly evolving; your involvement is vital to its success!\n\n### Examples\n\n- [Installing and Using Packages Example: sqlite](examples/installing-and-using-packages.md)\n- [Packaging Zipfiles Example: zlib](examples/packaging-zipfiles.md)\n- [Packaging GitHub Repositories Example: libogg](examples/packaging-github-repos.md)\n- [Patching Example: Patching libpng to work for x64-uwp](examples/patching.md)\n- [Getting Started with Versioning](examples/versioning.getting-started.md)\n\n### User Help\n\n- [Buildsystem Integration](users/buildsystems/integration.md)\n- [Triplet files](users/triplets.md)\n- [Configuration and Environment](users/config-environment.md)\n- [Authentication](users/authentication.md)\n- [Manifest Mode](users/manifests.md)\n- [Binary Caching](users/binarycaching.md)\n- [Asset Caching](users/assetcaching.md)\n- [Versioning](users/versioning.md)\n- [Usage with Android](users/android.md)\n- [Usage with Mingw-w64](users/mingw.md)\n- [Host Dependencies](users/host-dependencies.md)\n- [Using Registries](users/registries.md)\n\n### Maintainer Help\n\n- [Manifest Files - vcpkg.json](maintainers/manifest-files.md)\n- [Control Files](maintainers/control-files.md)\n- [Portfile Functions](maintainers/portfile-functions.md)\n- [Authoring Script Ports](maintainers/authoring-script-ports.md)\n- [Common CMake Definitions](maintainers/vcpkg_common_definitions.md)\n- [Maintainer Guidelines](maintainers/maintainer-guide.md)\n- [Creating Registries](maintainers/registries.md)\n- [CMake Guidelines](maintainers/cmake-guidelines.md)\n\n### [Vcpkg-Tool](https://github.com/microsoft/vcpkg-tool) Maintainer Help\n\n- [Testing](https://github.com/microsoft/vcpkg-tool/tree/main/docs/testing.md)\n- [Benchmarking](https://github.com/microsoft/vcpkg-tool/tree/main/docs/benchmarking.md)\n- [Layout of the vcpkg source tree](https://github.com/microsoft/vcpkg-tool/tree/main/docs/layout.md)\n\n### Community Resources (not directly affiliated with vcpkg)\n\n- [vcpkg.info](https://vcpkg.info/) - Package index + search\n- [vcpkgx](https://vcpkgx.com/) - Package index + search\n- [vcpkg index](https://vcpkg.dev/) - Package index + search\n\n### Blog posts\n\n- [Vcpkg Host Dependencies for Cross-Compilation](https://devblogs.microsoft.com/cppblog/vcpkg-host-dependencies/)\n- [Registries: Bring your own libraries to vcpkg](https://devblogs.microsoft.com/cppblog/registries-bring-your-own-libraries-to-vcpkg/)\n- [Vcpkg: Accelerate your team development environment with binary caching and manifests](https://devblogs.microsoft.com/cppblog/vcpkg-accelerate-your-team-development-environment-with-binary-caching-and-manifests/)\n- [Vcpkg: 2019.06 Update (overlay ports, overlay triplets, `vcpkg_check_features`)](https://devblogs.microsoft.com/cppblog/vcpkg-2019-06-update/)\n- [Announcing a single C++ library manager for Linux, macOS and Windows: Vcpkg](https://blogs.msdn.microsoft.com/vcblog/2018/04/24/announcing-a-single-c-library-manager-for-linux-macos-and-windows-vcpkg/)\n- [Vcpkg: Using multiple enlistments to handle multiple versions of a library](https://blogs.msdn.microsoft.com/vcblog/2017/10/23/vcpkg-using-multiple-enlistments/)\n- [Vcpkg: introducing the export command](https://blogs.msdn.microsoft.com/vcblog/2017/05/03/vcpkg-introducing-export-command/)\n- [Binary Compatibility and Pain-free Upgrade Why Moving to Visual Studio 2017 is almost \"too easy\"](https://blogs.msdn.microsoft.com/vcblog/2017/03/07/binary-compatibility-and-pain-free-upgrade-why-moving-to-visual-studio-2017-is-almost-too-easy/)\n- [Vcpkg recent enhancements](https://blogs.msdn.microsoft.com/vcblog/2017/02/14/vcpkg-recent-enhancements/)\n- [Vcpkg 3 Months Anniversary, Survey](https://blogs.msdn.microsoft.com/vcblog/2017/01/11/vcpkg-3-months-anniversary-survey/)\n- [Vcpkg updates: Static linking is now available](https://blogs.msdn.microsoft.com/vcblog/2016/11/01/vcpkg-updates-static-linking-is-now-available/)\n- [Vcpkg: a tool to acquire and build C++ open source libraries on Windows](https://blogs.msdn.microsoft.com/vcblog/2016/09/19/vcpkg-a-tool-to-acquire-and-build-c-open-source-libraries-on-windows/)\n\n### Other\n\n- [FAQ](about/faq.md)\n- [Privacy](about/privacy.md)\n","Nav":"#"},{"Path":"/en/docs/about/faq.html","Name":"Faq","Source":"# Frequently Asked Questions\n\n## Can I contribute a new library?\nYes! Start out by reading our [contribution guidelines](https://github.com/Microsoft/vcpkg/blob/master/CONTRIBUTING.md).\nIf you want to contribute but don't have a particular library in mind then take a look at the list\nof [new port requests](https://github.com/Microsoft/vcpkg/issues?q=is%3Aissue+is%3Aopen+label%3Acategory%3Anew-port).\n\n## Can Vcpkg create pre-built binary packages? What is the binary format used by Vcpkg?\nYes! See the [`export` command](../users/buildsystems/export-command.md).\n\n## How do I update libraries?\nThe `vcpkg update` command lists all packages which are out-of-sync with your current portfiles. To update a package, follow the instructions in the command.\n\n## How do I get more libraries?\nThe list of libraries is enumerated from the [`ports\\`](https://github.com/Microsoft/vcpkg/blob/master/ports) directory. By design, you can add and remove libraries from this directory as you see fit for yourself or your company -- see our examples on packaging [zipfiles](../examples/packaging-zipfiles.md) and [GitHub repos](../examples/packaging-github-repos.md).\n\nWe recommend cloning directly from [GitHub](https://github.com/microsoft/vcpkg) and using `git pull` to update the list of portfiles. Once you've updated your portfiles, `vcpkg update` will indicate any installed libraries that are now out of date.\n\n## Can I build a private library with this tool?\nYes. Follow [our packaging zlib Example](../examples/packaging-zipfiles.md) for creating a portfile using a fake URL. Then, either pre-seed the `downloads\\` folder with a zip containing your private sources or replace the normal calls to `vcpkg_download_distfile` and `vcpkg_extract_source_archive` with functions that unpack your source code.\n\n## Can I use a prebuilt private library with this tool?\nYes. The `portfile.cmake` for a library is fundamentally a script that places the headers and binaries into the correct arrangement in the `${CURRENT_PACKAGES_DIR}`, so to pull in prebuilt binaries you can write a portfile which directly downloads and arranges the files.\n\nTo see an example of this, look at [`ports\\opengl\\portfile.cmake`](https://github.com/microsoft/vcpkg/blob/master/ports/opengl/portfile.cmake) which simply copies files out of the Windows SDK.\n\n## Which platforms I can target with Vcpkg?\nWe currently target Windows Desktop (x86 and x64) as well as the Universal Windows Platform (x86, x64, and ARM). See `vcpkg help triplet` for the current list.\n\n## Does Vcpkg run on Linux/OSX?\nYes! We continuously test on OSX and Ubuntu 16.04, however we know users have been successful with Arch, Fedora, and FreeBSD. If you have trouble with your favorite Linux distribution, let us know in an issue and we'd be happy to help!\n\n## How do I update vcpkg?\nExecute `git pull` to get the latest sources, then run `bootstrap-vcpkg.bat` (Windows) or `./bootstrap-vcpkg.sh` (Unix) to update vcpkg.\n\n## How do I use different versions of a library on one machine?\nWithin a single instance of Vcpkg (e.g. one set of `installed\\`, `packages\\`, `ports\\` and so forth), you can only have one version of a library installed (otherwise, the headers would conflict with each other!). For those with experience with system-wide package managers, packages in Vcpkg correspond to the `X-dev` or `X-devel` packages.\n\nTo use different versions of a library for different projects, we recommend making separate instances of Vcpkg and using the [per-project integration mechanisms](../users/buildsystems/integration.md). The versions of each library are specified by the files in `ports\\`, so they are easily manipulated using standard `git` commands. This makes it very easy to roll back the entire set of libraries to a consistent set of older versions which all work with each other. If you need to then pin a specific library forward, that is as easy as checking out the appropriate version of `ports\\<package>\\`.\n\nIf your application is very sensitive to the versions of libraries, we recommend checking in the specific set of portfiles you need into your source control along with your project sources and using the `--vcpkg-root` option to redirect the working directory of `vcpkg.exe`.\n\n## How does Vcpkg protect my privacy?\nSee the [Privacy document](privacy.md) for all information regarding privacy.\n\n## Can I use my own CMake toolchain file with Vcpkg's toolchain file?\nYes. If you already have a CMake toolchain file, you will need to include our toolchain file at the end of yours. This should be as simple as an `include(<vcpkg_root>\\scripts\\buildsystems\\vcpkg.cmake)` directive. Alternatively, you could copy the contents of our `scripts\\buildsystems\\vcpkg.cmake` into the end of your existing toolchain file.\n\n## Can I use my own/specific flags for rebuilding libs?\nYes. In the current version, there is not yet a standardized global way to change them, however you can edit individual portfiles and tweak the exact build process however you'd like.\n\nBy saving the changes to the portfile (and checking them in), you'll get the same results even if you're rebuilding from scratch in the future and forgot what exact settings you used.\n\n## Can I get Vcpkg integration for custom configurations?\n\nYes. While Vcpkg will only produce the standard \"Release\" and \"Debug\" configurations when building a library, you can get integration support for your projects' custom configurations, in addition to your project's standard configurations.\n\nFirst of all, Vcpkg will automatically assume any custom configuration starting with \"Release\" (resp. \"Debug\") as a configuration that is compatible with the standard \"Release\" (resp. \"Debug\") configuration and will act accordingly.\n\nFor other configurations, you only need to override the MSBuild `$(VcpkgConfiguration)` macro in your project file (.vcxproj) to declare the compatibility between your configuration, and the target standard configuration. Unfortunately, due to the sequential nature of MSBuild, you'll need to add those settings much higher in your vcxproj so that it is declared before the Vcpk integration is loaded. It is recommend that the `$(VcpkgConfiguration)` macro is added to the \"Globals\" PropertyGroup.\n\nFor example, you can add support for your \"MyRelease\" configuration by adding in your project file:\n```\n<PropertyGroup Label=\"Globals\">\n  ...\n  <VcpkgConfiguration Condition=\"'$(Configuration)' == 'MyRelease'\">Release</VcpkgConfiguration>\n</PropertyGroup>\n```\nOf course, this will only produce viable binaries if your custom configuration is compatible with the target configuration (e.g. they should both link with the same runtime library).\n\n## I can't use user-wide integration. Can I use a per-project integration?\n\nYes. A NuGet package suitable for per-project use can be generated via either the `vcpkg integrate project` command (lightweight linking) or the `vcpkg export --nuget` command (shrinkwrapped).\n\nA lower level mechanism to achieve the same as the `vcpkg integrate project` NuGet package is via the `<vcpkg_root>\\scripts\\buildsystems\\msbuild\\vcpkg.targets` file. All you need is to import it in your .vcxproj file, replacing `<vcpkg_root>` with the path where you installed vcpkg:\n\n```\n<Import Project=\"<vcpkg_root>\\scripts\\buildsystems\\msbuild\\vcpkg.targets\" />\n```\n\n## How can I remove temporary files?\n\nYou can save some disk space by completely removing the `packages\\`, `buildtrees\\`, and `downloads\\` folders.\n\n## How is CMake used internally by Vcpkg?\nVcpkg uses CMake internally as a build scripting language. This is because CMake is already an extremely common build system for cross-platform open source libraries and is becoming very popular for C++ projects in general. It is easy to acquire on Windows, does not require system-wide installation, and legible for unfamiliar users.\n\n## Will Vcpkg support downloading compiled binaries from a public or private server?\nWe would like to eventually support downloading precompiled binaries, similar to other system package managers.\n\nIn a corporate scenario, we currently recommend building the libraries once and distributing the entire vcpkg root directory to everyone else on the project through some raw file transport such as a network share or HTTP host. See the [`export` command](../users/buildsystems/export-command.md).\n\n## What Visual C++ toolsets are supported?\nWe support Visual Studio 2015 Update 3 and above.\n\n## Why does Visual Studio not use my libraries with user-wide integration enabled?\nEnabling user-wide integration (`vcpkg integrate install`) changes the default for some project properties. In particular, \"C/C++/General/Additional Include Directories\" and \"Linker/General/Additional Library Directories\" are normally blank *without* user-wide integration. *With* integration, a blank value means that the augmented default supplied by vcpkg is overridden, and headers/libraries will not be found. To reinstate the default, set the properties to inherit from parent.\n\n## Why not NuGet?\nNuGet is a package manager for .NET libraries with a strong dependency on MSBuild. It does not meet the specific needs of Native C++ customers in at least three ways.\n\n- **Compilation Flavors**. With so many possible combinations of compilation options, the task of providing a truly complete set of options is intrinsically impossible. Furthermore, the download size for reasonably complete binary packages becomes enormous. This makes it a requirement to split the results into multiple packages, but then searching becomes very difficult.\n\n- **Binary vs Source**. Very closely tied to the first point, NuGet is designed from the ground up to provide relatively small, prebuilt binaries. Due to the nature of native code, developers need to have access to the source code to ensure ABI compatibility, performance, integrity, and debuggability.\n\n- **Per-dll vs Per-application**. NuGet is highly project centric. This works well in managed languages with naturally stable ABIs, because base libraries can continue to evolve without breaking those higher up. However, in native languages where the ABI is much more fragile, the only robust strategy is to explicitly build each library against the exact dependencies that will be included in the final application. This is difficult to ensure in NuGet and leads to a highly disconnected and independently versioned ecosystem.\n\n## Why not Conan?\nConan.io is a publicly-federated, project-centric, cross-platform, C++ package manager written in python. Our primary differences are:\n\n- **Public federation vs private federation**. Conan relies on individuals publishing independent copies of each package. We believe this approach encourages a large number of packages that are all broken in different ways. We believe it is a waste of user's time to pick through the list of 20+ public packages for Boost 1.56 to determine the handful that will work for their particular situation. In contrast, we believe there should be a single, collaboratively maintained version which works for the vast majority of cases and allow users to hack freely on their private versions. We believe this will result in a set of high quality packages that are heavily tested with each other and form a fantastic base for any private modifications you need.\n\n- **Per-dll vs Per-application**. When dependencies are independently versioned on a library level, it encourages every build environment to be a completely unique, unable to take advantage of or contribute to a solid, well tested ecosystem. In contrast, by versioning all libraries together as a platform (similar to a system package manager), we hope to congregate testing and effort on very common sets of library versions to maximize the quality and stability of the ecosystem. This also completely designs out the ability for a library to ask for versions that conflict with the application's choices (I want openssl Z and boost X but X only claims to work with openssl Y).\n\n- **Cross-platform vs single-platform**. While being hosted on many platforms is an excellent north star, we believe the level of system integration and stability provided by apt-get, yum, and homebrew is well worth needing to exchange `apt-get install libboost-all-dev` with `brew install boost` in automated scripts. We chose to make our system as easy as possible to integrate into a world with these very successful system managers -- one more line for `vcpkg install boost` -- instead of attempting to replace them where they are already so successful and well-loved.\n\n- **C++/CMake vs python**. While Python is an excellent language loved by many, we believe that transparency and familiarity are the most important factors when choosing a tool as important to your workflow as a package manager. Consequently, we chose to make the implementation languages be as universally accepted as possible: C++ should be used in a C++ package manager for C++ programmers. You should not be required to learn another programming language just to understand your package manager.\n\n## Why not Chocolatey?\nChocolatey is an excellent system for managing applications. However, it is not currently designed to acquire redistributable developer assets and help you with debugging. Vcpkg, in comparison, is designed to get you the libraries you need to build your application and help you deliver through any platform you'd like (including Chocolatey!).\n","Nav":"#"},{"Path":"/en/docs/about/privacy.html","Name":"Privacy","Source":"# Vcpkg Telemetry and Privacy\n\nvcpkg collects telemetry data to understand usage issues, such as failing packages, and to guide tool improvements. The collected data is anonymous.\nFor more information about how Microsoft protects your privacy, see https://privacy.microsoft.com/en-US/privacystatement#mainenterprisedeveloperproductsmodule\n\n## Scope\n\nWe explicitly ONLY collect information from invocations of the tool itself; we do NOT add any tracking information into the produced libraries. Telemetry is collected when using any of the `vcpkg` commands.\n\n## How to opt out\n\nThe vcpkg telemetry feature is enabled by default. In order to opt-out of data collection, you can re-run the bootstrap script with the following flag, for Windows and Linux/OSX, respectively:\n\n```PS> .\\bootstrap-vcpkg.bat -disableMetrics```\n\n```~/$ ./bootstrap-vcpkg.sh -disableMetrics```\n\n## Disclosure\n\nvcpkg displays text similar to the following when you build vcpkg. This is how Microsoft notifies you about data collection.\n\n```\nTelemetry\n---------\nvcpkg collects usage data in order to help us improve your experience.\nThe data collected by Microsoft is anonymous.\nYou can opt-out of telemetry by re-running the bootstrap-vcpkg script with -disableMetrics,\npassing --disable-metrics to vcpkg on the command line,\nor by setting the VCPKG_DISABLE_METRICS environment variable.\n\nRead more about vcpkg telemetry at docs/about/privacy.md\n```\n\n## Data Collected\n\nThe telemetry feature doesn't collect personal data, such as usernames or email addresses. It doesn't scan your code and doesn't extract project-level data, such as name, repository, or author. The data is sent securely to Microsoft servers and held under restricted access.\n\nProtecting your privacy is important to us. If you suspect the telemetry is collecting sensitive data or the data is being insecurely or inappropriately handled, file an issue in the Microsoft/vcpkg repository or send an email to vcpkg@microsoft.com for investigation.\n\nWe collect various telemetry events such as the command line used, the time of invocation, and how long execution took. Some commands also add additional calculated information (such as the full set of libraries to install). We generate a completely random UUID on first use and attach it to each event.\n\nYou can see the telemetry events any command by appending `--printmetrics` after the vcpkg command line.\n\nIn the source code (included at https://github.com/microsoft/vcpkg-tool/ ), you can search for calls to the functions `track_property()`, `track_feature()`, `track_metric()`, and `track_buildtime()`\nto see every specific data point we collect.\n\n## Avoid inadvertent disclosure information\n\nvcpkg contributors and anyone else running a version of vcpkg that they built themselves should consider the path to their source code. If a crash occurs when using vcpkg, the file path from the build machine is collected as part of the stack trace and isn't hashed.\nBecause of this, builds of vcpkg shouldn't be located in directories whose path names expose personal or sensitive information.\n","Nav":"#"},{"Path":"/en/docs/examples/installing-and-using-packages.html","Name":"Installing-and-using-packages","Source":"## Installing and Using Packages Example: SQLite\n\n_Note: this old example uses Classic Mode, but most developers will be happier with Manifest Mode. See [Manifest Mode: CMake Example](manifest-mode-cmake.md) for an example of converting to Manifest Mode._\n\n  - [Step 1: Install](#install)\n  - [Step 2: Use](#use)\n    - [VS/MSBuild Project (User-wide integration)](#msbuild)\n    - [CMake (Toolchain file)](#cmake)\n    - [Other integration options](../users/buildsystems/integration.md)\n\n---\n<a name=\"install\"></a>\n## Step 1: Install\n\nFirst, we need to know what name [SQLite](https://sqlite.org) goes by in the ports tree. To do that, we'll run the `search` command and inspect the output:\n```no-highlight\nPS D:\\src\\vcpkg> .\\vcpkg search sqlite\nlibodb-sqlite        2.4.0            Sqlite support for the ODB ORM library\nsqlite3              3.32.1           SQLite is a software library that implements a se...\n\nIf your library is not listed, please open an issue at:\n    https://github.com/Microsoft/vcpkg/issues\n```\nLooking at the list, we can see that the port is named \"sqlite3\". You can also run the `search` command without arguments to see the full list of packages.\n\nInstalling is then as simple as using the `install` command.\n```no-highlight\nPS D:\\src\\vcpkg> .\\vcpkg install sqlite3\nComputing installation plan...\nThe following packages will be built and installed:\n    sqlite3[core]:x86-windows\nStarting package 1/1: sqlite3:x86-windows\nBuilding package sqlite3[core]:x86-windows...\n-- Downloading https://sqlite.org/2020/sqlite-amalgamation-3320100.zip...\n-- Extracting source C:/src/vcpkg/downloads/sqlite-amalgamation-3320100.zip\n-- Applying patch fix-arm-uwp.patch\n-- Using source at C:/src/vcpkg/buildtrees/sqlite3/src/3320100-15aeda126a.clean\n-- Configuring x86-windows\n-- Building x86-windows-dbg\n-- Building x86-windows-rel\n-- Performing post-build validation\n-- Performing post-build validation done\nBuilding package sqlite3[core]:x86-windows... done\nInstalling package sqlite3[core]:x86-windows...\nInstalling package sqlite3[core]:x86-windows... done\nElapsed time for package sqlite3:x86-windows: 12 s\n\nTotal elapsed time: 12.04 s\n\nThe package sqlite3:x86-windows provides CMake targets:\n\n    find_package(unofficial-sqlite3 CONFIG REQUIRED)\n    target_link_libraries(main PRIVATE unofficial::sqlite3::sqlite3))\n\n```\n\nWe can check that sqlite3 was successfully installed for x86 Windows desktop by running the `list` command.\n```no-highlight\nPS D:\\src\\vcpkg> .\\vcpkg list\nsqlite3:x86-windows         3.32.1           SQLite is a software library that implements a se...\n```\n\nTo install for other architectures and platforms such as Universal Windows Platform or x64 Desktop, you can suffix the package name with `:<target>`.\n```no-highlight\nPS D:\\src\\vcpkg> .\\vcpkg install sqlite3:x86-uwp zlib:x64-windows\n```\n\nSee `.\\vcpkg help triplet` for all supported targets.\n\n---\n<a name=\"use\"></a>\n## Step 2: Use\n<a name=\"msbuild\"></a>\n#### VS/MSBuild Project (User-wide integration)\n\nThe recommended and most productive way to use vcpkg is via user-wide integration, making the system available for all projects you build. The user-wide integration will prompt for administrator access the first time it is used on a given machine, but afterwards is no longer required and the integration is configured on a per-user basis.\n```no-highlight\nPS D:\\src\\vcpkg> .\\vcpkg integrate install\nApplied user-wide integration for this vcpkg root.\n\nAll C++ projects can now #include any installed libraries.\nLinking will be handled automatically.\nInstalling new libraries will make them instantly available.\n```\n*Note: You will need to restart Visual Studio or perform a Build to update intellisense with the changes.* \n\nYou can now simply use File -> New Project in Visual Studio and the library will be automatically available. For SQLite, you can try out their [C/C++ sample](https://sqlite.org/quickstart.html).\n\nTo remove the integration for your user, you can use `.\\vcpkg integrate remove`.\n\n<a name=\"cmake\"></a>\n#### CMake (Toolchain File)\n\nThe best way to use installed libraries with cmake is via the toolchain file `scripts\\buildsystems\\vcpkg.cmake`. To use this file, you simply need to add it onto your CMake command line as:  \n`-DCMAKE_TOOLCHAIN_FILE=D:\\src\\vcpkg\\scripts\\buildsystems\\vcpkg.cmake`.\n\nIf you are using CMake through Open Folder with Visual Studio you can define `CMAKE_TOOLCHAIN_FILE` by adding a \"variables\" section to each of your `CMakeSettings.json` configurations:\n\n```json\n{\n  \"configurations\": [{\n    \"name\": \"x86-Debug\",\n    \"generator\": \"Visual Studio 15 2017\",\n    \"configurationType\" : \"Debug\",\n    \"buildRoot\":  \"${env.LOCALAPPDATA}\\\\CMakeBuild\\\\${workspaceHash}\\\\build\\\\${name}\",\n    \"cmakeCommandArgs\": \"\",\n    \"buildCommandArgs\": \"-m -v:minimal\",\n    \"variables\": [{\n      \"name\": \"CMAKE_TOOLCHAIN_FILE\",\n      \"value\": \"D:\\\\src\\\\vcpkg\\\\scripts\\\\buildsystems\\\\vcpkg.cmake\"\n    }]\n  }]\n}\n```\n*Note: It might be necessary to delete the CMake cache folder of each modified configuration, to force a full regeneration. In the `CMake` menu, under `Cache (<configuration name>)` you'll find `Delete Cache Folders`.*\n\nNow let's make a simple CMake project with a main file.\n```cmake\n# CMakeLists.txt\ncmake_minimum_required(VERSION 3.0)\nproject(test)\n\nfind_package(unofficial-sqlite3 CONFIG REQUIRED)\n\nadd_executable(main main.cpp)\n\ntarget_link_libraries(main PRIVATE unofficial::sqlite3::sqlite3)\n```\n```cpp\n// main.cpp\n#include <sqlite3.h>\n#include <stdio.h>\n\nint main()\n{\n    printf(\"%s\\n\", sqlite3_libversion());\n    return 0;\n}\n```\n\nThen, we build our project in the normal CMake way:\n```no-highlight\nPS D:\\src\\cmake-test> mkdir build \nPS D:\\src\\cmake-test> cd build\nPS D:\\src\\cmake-test\\build> cmake .. \"-DCMAKE_TOOLCHAIN_FILE=D:\\src\\vcpkg\\scripts\\buildsystems\\vcpkg.cmake\"\n    // omitted CMake output here //\n-- Build files have been written to: D:/src/cmake-test/build\nPS D:\\src\\cmake-test\\build> cmake --build .\n    // omitted MSBuild output here //\nBuild succeeded.\n    0 Warning(s)\n    0 Error(s)\n\nTime Elapsed 00:00:02.38\nPS D:\\src\\cmake-test\\build> .\\Debug\\main.exe\n3.15.0\n```\n\n*Note: The correct sqlite3.dll is automatically copied to the output folder when building for x86-windows. You will need to distribute this along with your application.*\n\n##### Handling libraries without native cmake support\n\nUnlike other platforms, we do not automatically add the `include\\` directory to your compilation line by default. If you're using a library that does not provide CMake integration, you will need to explicitly search for the files and add them yourself using [`find_path()`][1] and [`find_library()`][2].\n\n```cmake\n# To find and use catch\nfind_path(CATCH_INCLUDE_DIR catch.hpp)\ninclude_directories(${CATCH_INCLUDE_DIR})\n\n# To find and use azure-storage-cpp\nfind_path(WASTORAGE_INCLUDE_DIR was/blob.h)\nfind_library(WASTORAGE_LIBRARY wastorage)\ninclude_directories(${WASTORAGE_INCLUDE_DIR})\nlink_libraries(${WASTORAGE_LIBRARY})\n\n# Note that we recommend using the target-specific directives for a cleaner cmake:\n#     target_include_directories(main ${LIBRARY})\n#     target_link_libraries(main PRIVATE ${LIBRARY})\n```\n\n[1]: https://cmake.org/cmake/help/latest/command/find_path.html\n[2]: https://cmake.org/cmake/help/latest/command/find_library.html\n","Nav":"#"},{"Path":"/en/docs/examples/manifest-mode-cmake.html","Name":"Manifest-mode-cmake","Source":"# Manifest Mode: CMake Example\n\nWe would like to add [vcpkg manifest support](../users/manifests.md) to an existing cmake project!\nLet's create a simple project that prints the fibonacci sequence up to a certain number,\nusing some common dependencies.\n\n## Initial Layout\n\nLet's create the following file layout:\n\n```no-highlight\nfibo/\n  src/\n    main.cxx\n  CMakeLists.txt\n```\n\nAnd we wish to use [fmt](https://github.com/fmtlib/fmt), [range-v3](https://github.com/ericniebler/range-v3),\nand [cxxopts](https://github.com/jarro2783/cxxopts).\n\nLet's write our `CMakeLists.txt` first:\n\n```cmake\ncmake_minimum_required(VERSION 3.15)\n\nproject(fibo CXX)\n\nfind_package(fmt REQUIRED)\nfind_package(range-v3 REQUIRED)\nfind_package(cxxopts REQUIRED)\n\nadd_executable(fibo src/main.cxx)\ntarget_compile_features(fibo PRIVATE cxx_std_17)\n\ntarget_link_libraries(fibo\n  PRIVATE\n    fmt::fmt\n    range-v3::range-v3\n    cxxopts::cxxopts)\n```\n\nAnd then we should add `main.cxx`:\n\n```cxx\n#include <cxxopts.hpp>\n#include <fmt/format.h>\n#include <range/v3/view.hpp>\n\nnamespace view = ranges::views;\n\nint fib(int x) {\n  int a = 0, b = 1;\n\n  for (int it : view::repeat(0) | view::take(x)) {\n    (void)it;\n    int tmp = a;\n    a += b;\n    b = tmp;\n  }\n\n  return a;\n}\n\nint main(int argc, char** argv) {\n  cxxopts::Options options(\"fibo\", \"Print the fibonacci sequence up to a value 'n'\");\n    options.add_options()\n      (\"n,value\", \"The value to print to\", cxxopts::value<int>()->default_value(\"10\"));\n\n  auto result = options.parse(argc, argv);\n  auto n = result[\"value\"].as<int>();\n\n  for (int x : view::iota(1) | view::take(n)) {\n    fmt::print(\"fib({}) = {}\\n\", x, fib(x));\n  }\n}\n```\n\nThis is a simple project of course, but it should give us a clean project to start with.\nLet's try it out!\n\nLet's assume you have `fmt`, `range-v3`, and `cxxopts` installed with vcpkg classic mode;\nthen, you can just do a simple:\n\n```cmd\nD:\\src\\fibo> cmake -B build -S . -DCMAKE_TOOLCHAIN_FILE=D:\\src\\vcpkg\\scripts\\buildsystems\\vcpkg.cmake\n-- Building for: Visual Studio 16 2019\n-- Selecting Windows SDK version 10.0.18362.0 to target Windows 10.0.19041.\n-- The CXX compiler identification is MSVC 19.27.29111.0\n-- Detecting CXX compiler ABI info\n-- Detecting CXX compiler ABI info - done\n-- Check for working CXX compiler: C:/Program Files (x86)/Microsoft Visual Studio/2019/Community/VC/Tools/MSVC/14.27.29110/bin/Hostx64/x64/cl.exe - skipped\n-- Detecting CXX compile features\n-- Detecting CXX compile features - done\n-- Configuring done\n-- Generating done\n-- Build files have been written to: D:/src/fibo/build\nD:\\src\\fibo> cmake --build build\nMicrosoft (R) Build Engine version 16.7.0+b89cb5fde for .NET Framework\nCopyright (C) Microsoft Corporation. All rights reserved.\n\n  Checking Build System\n  Building Custom Rule D:/src/fibo/CMakeLists.txt\n  main.cxx\n  The contents of <span> are available only with C++20 or later.\n  fibo.vcxproj -> D:\\src\\fibo\\build\\Debug\\fibo.exe\n  Building Custom Rule D:/src/fibo/CMakeLists.txt\n```\n\nAnd now we can try out the `fibo` binary!\n\n```cmd\nD:\\src\\fibo> .\\build\\Debug\\fibo.exe -n 7 \nfib(1) = 1\nfib(2) = 1\nfib(3) = 2\nfib(4) = 3\nfib(5) = 5\nfib(6) = 8\nfib(7) = 13\n```\n\nit works!\n\n## Converting to Manifest Mode\n\nWe now wish to use manifest mode, so all of our dependencies are managed for us! Let's write a `vcpkg.json`:\n\n```json\n{\n  \"name\": \"fibo\",\n  \"version-string\": \"0.1.0\",\n  \"dependencies\": [\n    \"cxxopts\",\n    \"fmt\",\n    \"range-v3\"\n  ]\n}\n```\n\nLet's delete the build directory and rerun the build:\n\n```cmd\nD:\\src\\fibo> rmdir /S /Q build\nD:\\src\\fibo> cmake -B build -S . -DCMAKE_TOOLCHAIN_FILE=D:\\src\\vcpkg\\scripts\\buildsystems\\vcpkg.cmake\n-- Running vcpkg install\nDetecting compiler hash for triplet x64-windows...\nThe following packages will be built and installed:\n    cxxopts[core]:x64-windows\n    fmt[core]:x64-windows\n    range-v3[core]:x64-windows\nStarting package 1/3: cxxopts:x64-windows\nBuilding package cxxopts[core]:x64-windows...\nUsing cached binary package: C:\\Users\\me\\AppData\\Local\\vcpkg/archives\\d2\\d2d1e5302cdfefef2fd090d8eda84cc0c1fbe6f1.zip\nBuilding package cxxopts[core]:x64-windows... done\nInstalling package cxxopts[core]:x64-windows...\nInstalling package cxxopts[core]:x64-windows... done\nElapsed time for package cxxopts:x64-windows: 50.64 ms\nStarting package 2/3: fmt:x64-windows\nBuilding package fmt[core]:x64-windows...\nUsing cached binary package: C:\\Users\\me\\AppData\\Local\\vcpkg/archives\\bf\\bf00d5214e912d71414b545b241f54ef87fdf6e5.zip\nBuilding package fmt[core]:x64-windows... done\nInstalling package fmt[core]:x64-windows...\nInstalling package fmt[core]:x64-windows... done\nElapsed time for package fmt:x64-windows: 225 ms\nStarting package 3/3: range-v3:x64-windows\nBuilding package range-v3[core]:x64-windows...\nUsing cached binary package: C:\\Users\\me\\AppData\\Local\\vcpkg/archives\\fe\\fe2cdedef6953bf954e8ddca471bf3cc8d9b06d7.zip\nBuilding package range-v3[core]:x64-windows... done\nInstalling package range-v3[core]:x64-windows...\nInstalling package range-v3[core]:x64-windows... done\nElapsed time for package range-v3:x64-windows: 1.466 s\n\nTotal elapsed time: 1.742 s\n\n-- Running vcpkg install - done\n-- Selecting Windows SDK version 10.0.18362.0 to target Windows 10.0.19041.\n-- The CXX compiler identification is MSVC 19.27.29111.0\n-- Detecting CXX compiler ABI info\n-- Detecting CXX compiler ABI info - done\n-- Check for working CXX compiler: C:/Program Files (x86)/Microsoft Visual Studio/2019/Community/VC/Tools/MSVC/14.27.29110/bin/Hostx64/x64/cl.exe - skipped\n-- Detecting CXX compile features\n-- Detecting CXX compile features - done\n-- Configuring done\n-- Generating done\n-- Build files have been written to: D:/src/fibo/build\nD:\\src\\fibo> cmake --build build\nMicrosoft (R) Build Engine version 16.7.0+b89cb5fde for .NET Framework\nCopyright (C) Microsoft Corporation. All rights reserved.\n\n  Checking Build System\n  Building Custom Rule D:/src/fibo/CMakeLists.txt\n  main.cxx\n  The contents of <span> are available only with C++20 or later.\n  fibo.vcxproj -> D:\\src\\fibo\\build\\Debug\\fibo.exe\n  Building Custom Rule D:/src/fibo/CMakeLists.txt\n```\n\nYou can see that with just a _single file_, we've changed over to manifests without _any_ trouble.\nThe build system doesn't change _at all_! We just add a `vcpkg.json` file, delete the build directory,\nand reconfigure. And we're done!\n","Nav":"#"},{"Path":"/en/docs/examples/modify-baseline-to-pin-old-boost.html","Name":"Modify-baseline-to-pin-old-boost","Source":"# Pin old Boost versions\r\nThis document will teach you how to set versions of meta-packages like `boost` or `qt5`.\r\n\r\n**What is a meta-package?**\r\nIn vcpkg we call meta-packages to ports that by themselves don't install anything but that instead forward installation to another port or ports. The reasons for these meta-packages to exist are plenty: to install different versions of a library depending on platform or to conveniently install/uninstall a catalog of related packages (Boost and Qt).\r\n\r\nIn the case of Boost, it is unlikely that a user requires all of the 140+ Boost libraries in their project. For the sake of convenience, vcpkg splits Boost into multiple sub-packages broken down to individual libraries. By doing so, users can limit the subset of Boost libraries that they depend on.\r\n\r\nIf a user wants to install all of the Boost libraries available in vcpkg, they can do so by installing the `boost` meta-package.\r\n\r\nDue to the nature of meta-packages, some unexpected issues arise when trying to use them with versioning. If a user writes the following manifest file:\r\n\r\n`vcpkg.json`\r\n```json\r\n{\r\n    \"name\": \"demo\",\r\n    \"version\": \"1.0.0\",\r\n    \"builtin-baseline\": \"787fe1418ea968913cc6daf11855ffd8b0b5e9d4\",\r\n    \"dependencies\": [ \"boost-tuple\" ],\r\n    \"overrides\": [\r\n        { \"name\": \"boost\", \"version\": \"1.72.0\" }\r\n    ]\r\n}\r\n```\r\n\r\nThe resulting installation plan is:\r\n```\r\nThe following packages will be built and installed:\r\n    boost-assert[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-assert\\3393715b4ebe30fe1c3b68acf7f84363e611f156\r\n    boost-compatibility[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-compatibility\\cda5675366367789659c59aca65fc57d03c51deb\r\n    boost-config[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-config\\ca82ca1b9c1739c91f3cf42c68cee56c896ae6bd\r\n    boost-container-hash[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-container-hash\\bf472c23d29c3d80b562c43471eb92cea998f372\r\n    boost-core[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-core\\20a19f6ece37686a02eed33e1f58add8b7a2582a\r\n    boost-detail[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-detail\\96744251f025f9b3c856a275dfc338031876777b\r\n    boost-integer[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-integer\\de70ce0d1500df1eda3496c4f98f42f5db256b4a\r\n    boost-io[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-io\\7bf3407372f8fc2a99321d24a0e952d44fe25bf3\r\n    boost-preprocessor[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-preprocessor\\8d78b8ba2e9f54cb00137115ddd2ffec1c63c149\r\n    boost-static-assert[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-static-assert\\2a41c4703c7122de25b1c60510c43edc9371f63d\r\n    boost-throw-exception[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-throw-exception\\b13bdf32a20786a0165cc20205ef63765cac0627\r\n    boost-tuple[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-tuple\\22e3d000a178a88992c430d8ae8a0244c7dea674\r\n    boost-type-traits[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-type-traits\\8829793f6c6c913257314caa317599f8d253a5ca\r\n    boost-uninstall[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-uninstall\\08933bad27b6d41caef0940c31e2069ecb6a079c\r\n    boost-utility[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-utility\\47572946bf6a63c731b9c4142eecb8bef3d3b270\r\n    boost-vcpkg-helpers[core]:x64-windows -> 7#2 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-vcpkg-helpers\\2a21e5ab45d1ce41c185faf85dff0670ea6def1d\r\n```\r\n\r\nIt is reasonable to expect that overriding `boost` to version 1.72.0 results in all Boost packages being pinned to version 1.72.0. **However, vcpkg does not treat the `boost` meta-package any differently that any other port.** In other words, vcpkg has no notion that `boost` is related to all the other `boost-*` libraries, other than it depends on all of them. For this reason, all the other boost packages are installed at version 1.75.0, which is the baseline version.\r\n\r\nBelow, we describe two methods to pin down Boost versions effectively.\r\n\r\n## Method 1: Pin specific packages\r\nUse `\"overrides\"` to force specific versions in a package-by-package basis.\r\n\r\n`vcpkg.json`\r\n```json\r\n{\r\n    \"name\": \"demo\",\r\n    \"version\": \"1.0.0\",\r\n    \"builtin-baseline\": \"787fe1418ea968913cc6daf11855ffd8b0b5e9d4\",\r\n    \"dependencies\": [ \"boost-tuple\" ],\r\n    \"overrides\": [\r\n        { \"name\": \"boost-core\", \"version\": \"1.72\" },\r\n        { \"name\": \"boost-integer\", \"version\": \"1.72\" },\r\n        { \"name\": \"boost-io\", \"version\": \"1.72\" },\r\n        { \"name\": \"boost-tuple\", \"version\": \"1.72\" }\r\n    ]\r\n}\r\n```\r\n\r\nThis method allows you to quickly set the specific versions you want, but you will need to write an override for each package. Boost libraries are also heavily interdependent, which means that you may end up writing a lot of override lines.\r\n\r\nThe second method makes it easy to pin the entire Boost collection and end up with a very simple manifest file.\r\n\r\n## Method 2: Modify baseline\r\nAn easy way to set the version for the entirety of boost is to use the `\"builtin-baseline\"` property.\r\n\r\nAs of right now, it is only possible to go back to Boost version `1.75.0` using a baseline, since that was the contemporary Boost version when the versioning feature was merged. **But, it is possible to modify the baseline to whatever you like and use that instead.**\r\n\r\n### Step 1: Create a new branch\r\nAs described in the versioning documentation. The value that goes in `\"builtin-baseline\"` is a git commit in the microsoft/vcpkg repository's history. If you want to customize the baseline and have control over the vcpkg instance, you can create a new commit with said custom baseline.\r\n\r\nLet's start by creating a new branch to hold our modified baseline.\r\n\r\nIn the directory containing your clone of the vcpkg Git repository run:\r\n\r\n```\r\ngit checkout -b custom-boost-baseline\r\n```\r\n\r\nThis will create a new branch named `custom-boost-baseline` and check it out immediately.\r\n\r\n### Step 2: Modify the baseline\r\nThe next step is to modify the baseline file, open the file in your editor of choice and modify the entries for the Boost libraries.\r\n\r\nChange the `\"baseline\"` version to your desired version.\r\n_NOTE: Remember to also set the port versions to 0 (or your desired version)._\r\n\r\n`${vcpkg-root}/versions/baseline.json`\r\n```diff\r\n...\r\n     \"boost\": {\r\n-      \"baseline\": \"1.75.0\",\r\n+      \"baseline\": \"1.72.0\",\r\n       \"port-version\": 0\r\n     },\r\n     \"boost-accumulators\": {\r\n-      \"baseline\": \"1.75.0\",\r\n-      \"port-version\": 1\r\n+      \"baseline\": \"1.72.0\",\r\n+      \"port-version\": 0\r\n     },\r\n     \"boost-algorithm\": {\r\n-      \"baseline\": \"1.75.0\",\r\n+      \"baseline\": \"1.72.0\",\r\n       \"port-version\": 0\r\n     },\r\n     \"boost-align\": {\r\n-      \"baseline\": \"1.75.0\",\r\n+      \"baseline\": \"1.72.0\",\r\n       \"port-version\": 0\r\n     },\r\n...\r\n    \"boost-uninstall: {\r\n        \"baseline\": \"1.75.0\",\r\n        \"port-version\": 0\r\n    },\r\n...\r\n```\r\n\r\nSome `boost-` packages are helpers used by vcpkg and are not part of Boost. For example, `\"boost-uninstall\"` is a vcpkg helper to conveniently uninstall all Boost libraries, but it didn't exist for Boost version `1.72.0`, in this case it is fine to leave it at `1.75.0` to avoid baseline errors (since all versions in `baseline.json` must have existed).\r\n\r\n### Step 3: Commit your changes\r\nAfter saving your modified file, run these commands to commit your changes:\r\n\r\n```\r\ngit add versions/baseline.json\r\ngit commit -m \"Baseline Boost 1.72.0\"\r\n```\r\n\r\nYou can set the commit message to whatever you want, just make it useful for you.\r\n\r\n### Step 4: Get your baseline commit SHA\r\nOnce all your changes are ready, you can get the commit SHA by running:\r\n```\r\ngit rev-parse HEAD\r\n```\r\n\r\nThe output of that command will be the commit SHA you need to put as the `\"builtin-baseline\"` in your project's manifest file. Copy the 40-hex digits and save them to use later in your manifest file.\r\n\r\n### Step 5: (Optional) Go back to the main repository branch\r\nOnce your changes have been committed locally, you can refer to the commit SHA regardless of the repository branch you're working on. So, let's go back to the main vcpkg repository branch.\r\n\r\n```\r\ngit checkout master\r\n```\r\n\r\n### Step 6: Create your manifest file with your custom baseline\r\n\r\n```json\r\n{\r\n    \"name\": \"demo\",\r\n    \"version\": \"1.0.0\",\r\n    \"builtin-baseline\": \"9b5cf7c3d9376ddf43429671282972ec4f99aa85\",\r\n    \"dependencies\": [ \"boost-tuple\" ]\r\n}\r\n```\r\n\r\nIn this example, commit SHA `9b5cf7c3d9376ddf43429671282972ec4f99aa85` is the commit ID with the modified baseline. Even when a different branch (`master` in this case) is checked out, Git is able to find the commit as long as the branch with the modified baseline exists (the `custom-boost-baseline` branch we created in step 1).\r\n\r\nWe run `vcpkg install` in the directory containing our manifest file and the output looks like this:\r\n\r\n```\r\nThe following packages will be built and installed:\r\n    boost-assert[core]:x64-windows -> 1.72.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-assert\\6754398591f48435b28014ca0d60e5375a4c04d1\r\n    boost-compatibility[core]:x64-windows -> 1.72.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-compatibility\\9893ff3c554575bc712df4108a949e07b269f401\r\n    boost-config[core]:x64-windows -> 1.72.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-config\\de2784767046b06ec31eb718f10df512e51f2aad\r\n    boost-container-hash[core]:x64-windows -> 1.72.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-container-hash\\cc19fb0154bbef188f309f49b2664ec7623b96b6\r\n    boost-core[core]:x64-windows -> 1.72.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-core\\0eb5e20df9e267e9eca325be946f52ceb8a60229\r\n    boost-detail[core]:x64-windows -> 1.72.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-detail\\759d7c6a3f9dbaed0b0c69fa0bb764f7606bb02d\r\n    boost-integer[core]:x64-windows -> 1.72.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-integer\\173956c61a26e83b0f8b58b0baf60f06aeee637c\r\n    boost-preprocessor[core]:x64-windows -> 1.72.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-preprocessor\\86eb3938b7875f124feb845331dbe84cbab5d1c6\r\n    boost-static-assert[core]:x64-windows -> 1.72.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-static-assert\\e82d8f7f3ee07e927dc374f5a08ed6d6f4ef81f4\r\n    boost-throw-exception[core]:x64-windows -> 1.72.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-throw-exception\\64df295f7df41de4fcb219834889b126b5020def\r\n    boost-tuple[core]:x64-windows -> 1.72.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-tuple\\b3e1b01ffce6e367e4fed0a5538a8546abacb6b2\r\n    boost-type-traits[core]:x64-windows -> 1.72.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-type-traits\\5e44ec657660eccf4d3b2710b092dd238e1e7a2d\r\n    boost-uninstall[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-uninstall\\08933bad27b6d41caef0940c31e2069ecb6a079c\r\n    boost-utility[core]:x64-windows -> 1.72.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-utility\\7d721b2458d5d595ac341eb54883274f38a4b8c2\r\n    boost-vcpkg-helpers[core]:x64-windows -> 7#2 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-vcpkg-helpers\\2a21e5ab45d1ce41c185faf85dff0670ea6def1d\r\n```\r\n\r\nNotice how simple our manifest file has become, instead of having a multitude of `\"overrides\"` you can pin down all Boost packages just by setting the `\"builtin-baseline\"` to be your modified baseline commit SHA.\r\n","Nav":"#"},{"Path":"/en/docs/examples/overlay-triplets-linux-dynamic.html","Name":"Overlay-triplets-linux-dynamic","Source":"# Overlay triplets example\r\n\r\n## Building dynamic libraries on Linux\r\n\r\nUsing **vcpkg** you can build libraries for many configurations out of the box. However, this doesn't currently include shared libraries on Linux and Mac OS.\r\n\r\nThis doesn't mean that you cannot use **vcpkg** to build your dynamic libraries on these platforms! This document will guide you through creating your own custom triplets with `--overlay-triplets` to easily build dynamic libraries on Linux.\r\n\r\n### Step 1: Create the custom triplet files\r\n\r\nTo save time, copy the existing `x64-linux.cmake` triplet file.\r\n\r\n```sh\r\n~/git$ mkdir custom-triplets\r\n~/git$ cp vcpkg/triplets/x64-linux.cmake custom-triplets/x64-linux-dynamic.cmake\r\n```\r\n\r\nAnd modify `custom-triplets/x64-linux-dynamic.cmake` to match the contents below:\r\n```cmake\r\n# ~/git/custom-triplets/x64-linux-dynamic.cmake\r\nset(VCPKG_TARGET_ARCHITECTURE x64)\r\nset(VCPKG_CRT_LINKAGE dynamic)\r\nset(VCPKG_LIBRARY_LINKAGE dynamic) # This changed from static to dynamic\r\n\r\nset(VCPKG_CMAKE_SYSTEM_NAME Linux)\r\n```\r\n\r\n### Step 2: Use `--overlay-triplets` to build dynamic libraries\r\n\r\nUse the `--overlay-triplets` option to include the triplets in the `custom-triplets` directory. \r\n\r\n```\r\n~/git$ vcpkg/vcpkg install sqlite3:x64-linux-dynamic --overlay-triplets=custom-triplets\r\nThe following packages will be built and installed:\r\n    sqlite3[core]:x64-linux-dynamic\r\nStarting package 1/1: sqlite3:x64-linux-dynamic\r\nBuilding package sqlite3[core]:x64-linux-dynamic...\r\n-- Loading triplet configuration from: /home/victor/git/custom-triplets/x64-linux-dynamic.cmake\r\n-- Downloading https://sqlite.org/2019/sqlite-amalgamation-3280000.zip...\r\n-- Extracting source /home/victor/git/vcpkg/downloads/sqlite-amalgamation-3280000.zip\r\n-- Applying patch fix-arm-uwp.patch\r\n-- Using source at /home/victor/git/vcpkg/buildtrees/sqlite3/src/3280000-6a3ff7ce92\r\n-- Configuring x64-linux-dynamic-dbg\r\n-- Configuring x64-linux-dynamic-rel\r\n-- Building x64-linux-dynamic-dbg\r\n-- Building x64-linux-dynamic-rel\r\n-- Performing post-build validation\r\n-- Performing post-build validation done\r\nBuilding package sqlite3[core]:x64-linux-dynamic... done\r\nInstalling package sqlite3[core]:x64-linux-dynamic...\r\nInstalling package sqlite3[core]:x64-linux-dynamic... done\r\nElapsed time for package sqlite3:x64-linux-dynamic: 44.82 s\r\n\r\nTotal elapsed time: 44.82 s\r\n\r\nThe package sqlite3:x64-linux-dynamic provides CMake targets:\r\n\r\n    find_package(unofficial-sqlite3 CONFIG REQUIRED)\r\n    target_link_libraries(main PRIVATE unofficial::sqlite3::sqlite3)\r\n```\r\n\r\nOverlay triplets enables your custom triplet files when using `vcpkg install`, `vcpkg update`, `vcpkg upgrade`, and `vcpkg remove`.\r\n\r\nWhen using the `--overlay-triplets` option, a message like the following lets you know that a custom triplet is being used: \r\n\r\n```\r\n-- Loading triplet configuration from: /home/custom-triplets/x64-linux-dynamic.cmake\r\n```\r\n\r\n## Overriding default triplets\r\n\r\nAs you may have noticed, the default triplets for Windows (`x86-windows` and `x64-windows`) install dynamic libraries, while a suffix (`-static`) is needed for static libraries. This is different with Linux and Mac OS where static libraries are built by `x64-linux` and `x64-osx`.\r\n\r\nUsing `--overlay-triplets` it is possible to override the default triplets to accomplish the same behavior on Linux:\r\n\r\n* `x64-linux`: Builds dynamic libraries,\r\n* `x64-linux-static`: Builds static libraries.\r\n\r\n### Step 1: Create the overlay triplets\r\n\r\nUsing the custom triplet created in the previous example, rename `custom-triplets/x64-linux-dynamic.cmake` to `custom-triplets/x64-linux.cmake`. Then, copy the default `x64-linux` triplet (which builds static libraries) in your `custom-triplets` folder and rename it to `x64-linux-static.cmake`.\r\n\r\n```sh\r\n~/git$ mv custom-triplets/x64-linux-dynamic.cmake custom-triplets/x64-linux.cmake\r\n~/git$ cp vcpkg/triplets/x64-linux.cmake custom-triplets/x64-linux-static.cmake\r\n```\r\n\r\n### Step 2: Use `--overlay-triplets` to override default triplets\r\n\r\nUse the `--overlay-triplets` option to include the triplets in the `custom-triplets` directory.\r\n\r\n```\r\n~/git$ vcpkg/vcpkg install sqlite3:x64-linux --overlay-triplets=custom-triplets\r\nThe following packages will be built and installed:\r\n    sqlite3[core]:x64-linux\r\nStarting package 1/1: sqlite3:x64-linux\r\nBuilding package sqlite3[core]:x64-linux...\r\n-- Loading triplet configuration from: /home/victor/git/custom-triplets/x64-linux.cmake\r\n-- Downloading https://sqlite.org/2019/sqlite-amalgamation-3280000.zip...\r\n-- Extracting source /home/victor/git/vcpkg/downloads/sqlite-amalgamation-3280000.zip\r\n-- Applying patch fix-arm-uwp.patch\r\n-- Using source at /home/victor/git/vcpkg/buildtrees/sqlite3/src/3280000-6a3ff7ce92\r\n-- Configuring x64-linux-dbg\r\n-- Configuring x64-linux-rel\r\n-- Building x64-linux-dbg\r\n-- Building x64-linux-rel\r\n-- Performing post-build validation\r\n-- Performing post-build validation done\r\nBuilding package sqlite3[core]:x64-linux... done\r\nInstalling package sqlite3[core]:x64-linux...\r\nInstalling package sqlite3[core]:x64-linux... done\r\nElapsed time for package sqlite3:x64-linux: 44.82 s\r\n\r\nTotal elapsed time: 44.82 s\r\n\r\nThe package sqlite3:x64-linux provides CMake targets:\r\n\r\n    find_package(unofficial-sqlite3 CONFIG REQUIRED)\r\n    target_link_libraries(main PRIVATE unofficial::sqlite3::sqlite3)\r\n```\r\n\r\nNote that the default triplet is masked by your custom triplet:\r\n\r\n```\r\n-- Loading triplet configuration from: /home/victor/git/custom-triplets/x64-linux.cmake\r\n```\r\n","Nav":"#"},{"Path":"/en/docs/examples/packaging-github-repos.html","Name":"Packaging-github-repos","Source":"## Packaging Github Repos Example: libogg\r\n### Create the manifest file\r\nThe manifest file (called `vcpkg.json`) is a json file describing the package's metadata.\r\n\r\nFor libogg, we'll create the file `ports/libogg/vcpkg.json` with the following content:\r\n\r\n```json\r\n{\r\n  \"name\": \"libogg\",\r\n  \"version-string\": \"1.3.3\",\r\n  \"description\": \"Ogg is a multimedia container format, and the native file and stream format for the Xiph.org multimedia codecs.\"\r\n}\r\n```\r\n\r\nYou can format the manifest file to our specifications with `vcpkg format-manifest ports/libogg/vcpkg.json`.\r\n\r\n### Create the portfile\r\n`portfile.cmake` describes how to build and install the package. First we download the project from Github with [`vcpkg_from_github`](../maintainers/vcpkg_from_github.md):\r\n\r\n```cmake\r\nvcpkg_from_github(\r\n    OUT_SOURCE_PATH SOURCE_PATH\r\n    REPO xiph/ogg\r\n    REF v1.3.3\r\n    SHA512 0bd6095d647530d4cb1f509eb5e99965a25cc3dd9b8125b93abd6b248255c890cf20710154bdec40568478eb5c4cde724abfb2eff1f3a04e63acef0fbbc9799b\r\n    HEAD_REF master\r\n)\r\n```\r\n\r\nThe important parts to update are `REPO` for the GitHub repository path, `REF` for a stable tag/commit to use, and `SHA512` with the checksum of the downloaded zipfile (you can get this easily by setting it to `0`, trying to install the package, and copying the checksum).\r\n\r\nFinally, we configure the project with CMake, install the package, and copy over the license file:\r\n\r\n```cmake\r\nvcpkg_cmake_configure(SOURCE_PATH ${SOURCE_PATH})\r\nvcpkg_cmake_install()\r\nfile(INSTALL \"${SOURCE_PATH}/COPYING\" DESTINATION \"${CURRENT_PACKAGES_DIR}/share/libogg\" RENAME copyright)\r\n```\r\n\r\nCheck the documentation for [`vcpkg_cmake_configure`](../maintainers/ports/vcpkg-cmake/vcpkg_cmake_configure.md) and [`vcpkg_cmake_install`](../maintainers/ports/vcpkg-cmake/vcpkg_cmake_install.md) if your package needs additional options. \r\n\r\nNow you can run `vcpkg install libogg` to build and install the package.\r\n\r\n### Suggested example portfiles\r\nIn the `ports/` directory are many libraries that can be used as examples, including many that are not based on CMake.\r\n\r\n- Header only libraries\r\n  - rapidjson\r\n  - range-v3\r\n- MSBuild-based\r\n  - mpg123\r\n- Non-CMake, custom buildsystem\r\n  - openssl\r\n  - ffmpeg\r\n","Nav":"#"},{"Path":"/en/docs/examples/packaging-zipfiles.html","Name":"Packaging-zipfiles","Source":"## Packaging `.zip` Files Example: zlib\n\n### Bootstrap with `create`\nFirst, locate a globally accessible archive of the library's sources. Zip, gzip, and bzip are all supported. Strongly prefer official sources or mirrors over unofficial mirrors.\n\n*Looking at zlib's website, the URL http://zlib.net/zlib-1.2.11.tar.gz looks appropriate.*\n\nSecond, determine a suitable package name. This should be ASCII, lowercase, and recognizable to someone who knows the library's \"human name\". If the library is already packaged in another package manager, prefer that name.\n\n*Since zlib is already packaged as zlib, we will use the name zlib2 for this example.*\n\nFinally, if the server's name for the archive is not very descriptive (such as downloading a zipped commit or branch from GitHub), choose a nice archive name of the form `<packagename>-<version>.zip`.\n\n*`zlib1211.zip` is a fine name, so no change needed.*\n\nAll this information can then be passed into the `create` command, which will download the sources and bootstrap the packaging process inside `ports/<packagename>`.\n\n```no-highlight\nPS D:\\src\\vcpkg> .\\vcpkg create zlib2 http://zlib.net/zlib-1.2.11.tar.gz zlib1211.tar.gz\n-- Generated portfile: D:/src/vcpkg/ports/zlib2/portfile.cmake\n```\n\n### Create the manifest file\nIn addition to the generated `ports/<package>/portfile.cmake`, we also need a `ports/<package>/vcpkg.json` file. This file is a simple set of fields describing the package's metadata.\n\n*For zlib2, we'll create the file `ports/zlib2/vcpkg.json` with the following contents:*\n```json\n{\n  \"name\": \"zlib2\",\n  \"version-string\": \"1.2.11\",\n  \"description\": \"A Massively Spiffy Yet Delicately Unobtrusive Compression Library\"\n}\n```\n\n### Tweak the generated portfile\nThe generated `portfile.cmake` will need some editing to correctly package most libraries in the wild, however we can start by trying out the build.\n\n```no-highlight\nPS D:\\src\\vcpkg> .\\vcpkg install zlib2\nComputing installation plan...\nThe following packages will be built and installed:\n    zlib2[core]:x64-uwp\nStarting package 1/1: zlib2:x64-uwp\nBuilding package zlib2[core]:x64-uwp...\n-- Using cached C:/src/vcpkg/downloads/zlib1211.tar.gz\n-- Cleaning sources at C:/src/vcpkg/buildtrees/zlib2/src/1.2.11-deec42f53b.clean. Pass --editable to vcpkg to reuse sources.\n-- Extracting source C:/src/vcpkg/downloads/zlib1211.tar.gz\n-- Applying patch cmake_dont_build_more_than_needed.patch\n-- Using source at C:/src/vcpkg/buildtrees/zlib2/src/1.2.11-deec42f53b.clean\n-- Configuring x64-uwp\n-- Building x64-uwp-dbg\n-- Building x64-uwp-rel\n-- Installing: C:/src/vcpkg/packages/zlib2_x64-uwp/share/zlib2/copyright\n-- Performing post-build validation\nInclude files should not be duplicated into the /debug/include directory. If this cannot be disabled in the project cmake, use\n    file(REMOVE_RECURSE ${CURRENT_PACKAGES_DIR}/debug/include)\n/debug/share should not exist. Please reorganize any important files, then use\n    file(REMOVE_RECURSE ${CURRENT_PACKAGES_DIR}/debug/share)\nThe software license must be available at ${CURRENT_PACKAGES_DIR}/share/zlib2/copyright\nFound 3 error(s). Please correct the portfile:\n    D:\\src\\vcpkg\\ports\\zlib2\\portfile.cmake\n```\n\nAt this point, it is a matter of reading the error messages and log files while steadily improving the quality of the portfile. Zlib required providing a discrete copy of the LICENSE to copy into the package, suppressing the build and installation of executables and headers, and removing the static libraries after they were installed.\n\n### Suggested example portfiles\nIn the `ports/` directory are many libraries that can be used as examples, including many that are not based on CMake.\n\n- Header only libraries\n    - rapidjson\n    - range-v3\n- MSBuild-based\n    - mpg123\n- Non-CMake, custom buildsystem\n    - openssl\n    - ffmpeg\n","Nav":"#"},{"Path":"/en/docs/examples/patching.html","Name":"Patching","Source":"## Patching Example: Patching libpng to work for x64-uwp\n\n### Initial error logs\nFirst, try building:\n\n```no-highlight\nPS D:\\src\\vcpkg> vcpkg install libpng:x64-uwp --editable\nComputing installation plan...\nThe following packages will be built and installed:\n    libpng[core]:x64-uwp\nStarting package 1/1: libpng:x64-uwp\nBuilding package libpng[core]:x64-uwp...\n-- Using cached D:/src/vcpkg/downloads/glennrp-libpng-v1.6.37.tar.gz\n-- Extracting source D:/src/vcpkg/downloads/glennrp-libpng-v1.6.37.tar.gz\n-- Using source at D:/src/vcpkg/buildtrees/libpng/src/v1.6.37-c993153cdf\n-- Configuring x64-uwp\n-- Building x64-uwp-rel\nCMake Error at scripts/cmake/execute_required_process.cmake:14 (message):\n  Command failed: C:/Program Files/CMake/bin/cmake.exe;--build;.;--config;Release\n\n  Working Directory: D:/src/vcpkg/buildtrees/libpng/x64-uwp-rel\n\n  See logs for more information:\n\n      D:\\src\\vcpkg\\buildtrees\\libpng\\build-x64-uwp-rel-out.log\n      D:\\src\\vcpkg\\buildtrees\\libpng\\build-x64-uwp-rel-err.log\n\nCall Stack (most recent call first):\n  scripts/cmake/vcpkg_build_cmake.cmake:3 (execute_required_process)\n  ports/libpng/portfile.cmake:22 (vcpkg_build_cmake)\n  scripts/ports.cmake:84 (include)\n\n\nError: build command failed\n```\n\nNext, looking at the above logs (build-xxx-out.log and build-xxx-err.log).\n\n```no-highlight\n// build-x64-uwp-rel-out.log\n...\n\"D:\\src\\vcpkg\\buildtrees\\libpng\\x64-uwp-rel\\ALL_BUILD.vcxproj\" (default target) (1) ->\n\"D:\\src\\vcpkg\\buildtrees\\libpng\\x64-uwp-rel\\png.vcxproj\" (default target) (3) ->\n(ClCompile target) -> \n  D:\\src\\vcpkg\\buildtrees\\libpng\\src\\v1.6.37-c993153cdf\\pngerror.c(775): warning C4013: 'ExitProcess' undefined; assuming extern returning int [D:\\src\\vcpkg\\buildtrees\\libpng\\x64-uwp-rel\\png.vcxproj]\n\n\n\"D:\\src\\vcpkg\\buildtrees\\libpng\\x64-uwp-rel\\ALL_BUILD.vcxproj\" (default target) (1) ->\n\"D:\\src\\vcpkg\\buildtrees\\libpng\\x64-uwp-rel\\png.vcxproj\" (default target) (3) ->\n(Link target) -> \n  pngerror.obj : error LNK2019: unresolved external symbol _ExitProcess referenced in function _png_longjmp [D:\\src\\vcpkg\\buildtrees\\libpng\\x64-uwp-rel\\png.vcxproj]\n  D:\\src\\vcpkg\\buildtrees\\libpng\\x64-uwp-rel\\Release\\libpng16.dll : fatal error LNK1120: 1 unresolved externals [D:\\src\\vcpkg\\buildtrees\\libpng\\x64-uwp-rel\\png.vcxproj]\n\n    1 Warning(s)\n    2 Error(s)\n\nTime Elapsed 00:00:04.19\n```\n\n### Identify the problematic code\n\nTaking a look at [MSDN](https://msdn.microsoft.com/en-us/library/windows/desktop/ms682658(v=vs.85).aspx) shows that `ExitProcess` is only available for desktop apps. Additionally, it's useful to see the surrounding context:\n\n```c\n/* buildtrees\\libpng\\src\\v1.6.37-c993153cdf\\pngerror.c:769 */\n    /* If control reaches this point, png_longjmp() must not return. The only\n    * choice is to terminate the whole process (or maybe the thread); to do\n    * this the ANSI-C abort() function is used unless a different method is\n    * implemented by overriding the default configuration setting for\n    * PNG_ABORT().\n    */\n    PNG_ABORT();\n```\n\nA recursive search for `PNG_ABORT` reveals the definition:\n```no-highlight\nPS D:\\src\\vcpkg\\buildtrees\\libpng\\src\\v1.6.37-c993153cdf> findstr /snipl \"PNG_ABORT\" *\nCHANGES:701:  Added PNG_SETJMP_SUPPORTED, PNG_SETJMP_NOT_SUPPORTED, and PNG_ABORT() macros\nlibpng-manual.txt:432:errors will result in a call to PNG_ABORT() which defaults to abort().\nlibpng-manual.txt:434:You can #define PNG_ABORT() to a function that does something\nlibpng-manual.txt:2753:errors will result in a call to PNG_ABORT() which defaults to abort().\nlibpng-manual.txt:2755:You can #define PNG_ABORT() to a function that does something\nlibpng-manual.txt:4226:PNG_NO_SETJMP, in which case it is handled via PNG_ABORT()),\nlibpng.3:942:errors will result in a call to PNG_ABORT() which defaults to abort().\nlibpng.3:944:You can #define PNG_ABORT() to a function that does something\nlibpng.3:3263:errors will result in a call to PNG_ABORT() which defaults to abort().\nlibpng.3:3265:You can #define PNG_ABORT() to a function that does something\nlibpng.3:4736:PNG_NO_SETJMP, in which case it is handled via PNG_ABORT()),\npng.h:994: * will use it; otherwise it will call PNG_ABORT().  This function was\npngerror.c:773:    * PNG_ABORT().\npngerror.c:775:   PNG_ABORT();\npngpriv.h:459:#ifndef PNG_ABORT\npngpriv.h:461:#    define PNG_ABORT() ExitProcess(0)\npngpriv.h:463:#    define PNG_ABORT() abort()\n```\n\nThis already gives us some great clues, but the full definition tells the complete story.\n\n```c\n/* buildtrees\\libpng\\src\\v1.6.37-c993153cdf\\pngpriv.h:459 */\n#ifndef PNG_ABORT\n#  ifdef _WINDOWS_\n#    define PNG_ABORT() ExitProcess(0)\n#  else\n#    define PNG_ABORT() abort()\n#  endif\n#endif\n```\n\n`abort()` is a standard CRT call and certainly available in UWP, so we just need to convince libpng to be more platform agnostic. The easiest and most reliable way to achieve this is to patch the code; while in this particular case we could pass in a compiler flag to override `PNG_ABORT` because this is a private header, in general it is more reliable to avoid adding more required compiler switches when possible (especially when it isn't already exposed as a CMake option).\n\n### Patching the code to improve compatibility\n\nWe recommend using git to create the patch file, since you'll already have it installed.\n```no-highlight\nPS D:\\src\\vcpkg\\buildtrees\\libpng\\src\\v1.6.37-c993153cdf> git init .\nInitialized empty Git repository in D:/src/vcpkg/buildtrees/libpng/src/v1.6.37-c993153cdf/.git/\n\nPS D:\\src\\vcpkg\\buildtrees\\libpng\\src\\v1.6.37-c993153cdf> git add .\nwarning: LF will be replaced by CRLF in ANNOUNCE.\nThe file will have its original line endings in your working directory.\n...\n\nPS D:\\src\\vcpkg\\buildtrees\\libpng\\src\\v1.6.37-c993153cdf> git commit -m \"temp\"\n[master (root-commit) 68f253f] temp\n 422 files changed, 167717 insertions(+)\n...\n```\n\nNow we can modify `pngpriv.h` to use `abort()` everywhere.\n```c\n/* buildtrees\\libpng\\src\\v1.6.37-c993153cdf\\pngpriv.h:459 */\n#ifndef PNG_ABORT\n#  define PNG_ABORT() abort()\n#endif\n```\n\nThe output of `git diff` is already in patch format, so we just need to save the patch into the `ports/libpng` directory.\n```no-highlight\nPS buildtrees\\libpng\\src\\v1.6.37-c993153cdf> git diff --ignore-space-at-eol | out-file -enc ascii ..\\..\\..\\..\\ports\\libpng\\use-abort-on-all-platforms.patch\n```\n\nFinally, we need to apply the patch after extracting the source.\n```cmake\n# ports\\libpng\\portfile.cmake\n...\nvcpkg_extract_source_archive_ex(\n  OUT_SOURCE_PATH SOURCE_PATH\n  ARCHIVE ${ARCHIVE}\n  PATCHES \n    \"use-abort-on-all-platforms.patch\"\n)\n\nvcpkg_cmake_configure(\n...\n```\n\n### Verification\n\nTo be completely sure this works from scratch, we need to remove the package and rebuild it:\n\n```no-highlight\nPS D:\\src\\vcpkg> vcpkg remove libpng:x64-uwp\nPackage libpng:x64-uwp was successfully removed\n```\n\nNow we try a fresh, from scratch install.\n\n```no-highlight\nPS D:\\src\\vcpkg> vcpkg install libpng:x64-uwp\nComputing installation plan...\nThe following packages will be built and installed:\n    libpng[core]:x64-uwp\nStarting package 1/1: libpng:x64-uwp\nBuilding package libpng[core]:x64-uwp...\nCould not locate cached archive: C:\\Users\\me\\AppData\\Local\\vcpkg/archives\\f4\\f44b54f818f78b9a4ccd34b3666f566f94286850.zip\n-- Using cached D:/src/vcpkg/downloads/glennrp-libpng-v1.6.37.tar.gz\n-- Extracting source D:/src/vcpkg/downloads/glennrp-libpng-v1.6.37.tar.gz\n-- Applying patch use_abort.patch\n-- Applying patch cmake.patch\n-- Applying patch pkgconfig.patch\n-- Applying patch pkgconfig.2.patch\n-- Using source at D:/src/vcpkg/buildtrees/libpng/src/v1.6.37-10db9f58e4.clean\n-- Configuring x64-uwp\n-- Building x64-uwp-dbg\n-- Building x64-uwp-rel\n-- Fixing pkgconfig file: D:/src/vcpkg/packages/libpng_x64-uwp/lib/pkgconfig/libpng.pc\n-- Fixing pkgconfig file: D:/src/vcpkg/packages/libpng_x64-uwp/lib/pkgconfig/libpng16.pc\n-- Fixing pkgconfig file: D:/src/vcpkg/packages/libpng_x64-uwp/debug/lib/pkgconfig/libpng.pc\n-- Fixing pkgconfig file: D:/src/vcpkg/packages/libpng_x64-uwp/debug/lib/pkgconfig/libpng16.pc\n-- Installing: D:/src/vcpkg/packages/libpng_x64-uwp/share/libpng/copyright\n-- Performing post-build validation\n-- Performing post-build validation done\nStored binary cache: C:\\Users\\me\\AppData\\Local\\vcpkg/archives\\f4\\f44b54f818f78b9a4ccd34b3666f566f94286850.zip\nBuilding package libpng[core]:x64-uwp... done\nInstalling package libpng[core]:x64-uwp...\nInstalling package libpng[core]:x64-uwp... done\nElapsed time for package libpng:x64-uwp: 11.94 s\n\nTotal elapsed time: 11.95 s\n\nThe package libpng:x64-uwp provides CMake targets:\n\n    find_package(libpng CONFIG REQUIRED)\n    target_link_libraries(main PRIVATE png)\n```\n\nFinally, to fully commit and publish the changes, we need to bump the port version in `vcpkg.json`,\nand add the patch file to source control, then make a Pull Request!\n\n```json\n{\n  \"name\": \"libpng\",\n  \"version\": \"1.6.37\",\n  \"port-version\": 1,\n  \"dependencies\": [\n    \"zlib\"\n  ]\n}\n```\n","Nav":"#"},{"Path":"/en/docs/examples/versioning.getting-started.html","Name":"Get Started with Versioning","Source":"# Getting started with versioning\r\n\r\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/examples/versioning.getting-started.md).**\r\n\r\nVcpkg lets you take control of which version of packages to install in your projects using manifests. \r\n\r\n## Using versions with manifests\r\n\r\nLet's start with creating a simple CMake project that depends on `fmt` and `zlib`.\r\n\r\nCreate a folder with the following files:\r\n\r\n**vcpkg.json**\r\n```json\r\n{\r\n    \"name\": \"versions-test\",\r\n    \"version\": \"1.0.0\",\r\n    \"dependencies\": [\r\n        {\r\n            \"name\": \"fmt\",\r\n            \"version>=\": \"7.1.3#1\"\r\n        }, \r\n        \"zlib\"\r\n    ],\r\n    \"builtin-baseline\": \"3426db05b996481ca31e95fff3734cf23e0f51bc\"\r\n}\r\n```\r\n\r\n**main.cpp**\r\n```c++\r\n#include <fmt/core.h>\r\n#include <zlib.h>\r\n\r\nint main()\r\n{\r\n    fmt::print(\"fmt version is {}\\n\"\r\n               \"zlib version is {}\\n\", \r\n               FMT_VERSION, ZLIB_VERSION);\r\n    return 0;\r\n}\r\n```\r\n\r\n**CMakeLists.txt**\r\n```CMake\r\ncmake_minimum_required(VERSION 3.18)\r\n\r\nproject(versionstest CXX)\r\n\r\nadd_executable(main main.cpp)\r\n\r\nfind_package(ZLIB REQUIRED)\r\nfind_package(fmt CONFIG REQUIRED)\r\ntarget_link_libraries(main PRIVATE ZLIB::ZLIB fmt::fmt)\r\n```\r\n\r\nAnd now we build and run our project with CMake:\r\n\r\n1. Create the build directory for the project.\r\n```\r\nPS D:\\versions-test> mkdir build\r\nPS D:\\versions-test> cd build\r\n```\r\n\r\n2. Configure CMake.  \r\n```\r\nPS D:\\versions-test\\build> cmake -G Ninja -DCMAKE_TOOLCHAIN_FILE=D:/vcpkg/scripts/buildsystems/vcpkg.cmake ..\r\n-- Running vcpkg install\r\nDetecting compiler hash for triplet x86-windows...\r\nThe following packages will be built and installed:\r\n    fmt[core]:x64-windows -> 7.1.3#1 -- D:\\Work\\viromer\\vcpkg\\buildtrees\\versioning\\versions\\fmt\\4f8427eb0bd40da1856d4e67bde39a4fda689d72\r\n    vcpkg-cmake[core]:x64-windows -> 2021-02-26 -- D:\\Work\\viromer\\vcpkg\\buildtrees\\versioning\\versions\\vcpkg-cmake\\51896aa8073adb5c8450daa423d03eedf0dfc61f\r\n    vcpkg-cmake-config[core]:x64-windows -> 2021-02-26 -- D:\\Work\\viromer\\vcpkg\\buildtrees\\versioning\\versions\\vcpkg-cmake-config\\d255b3d566a8861dcc99a958240463e678528066\r\n    zlib[core]:x64-windows -> 1.2.11#9 -- D:\\Work\\viromer\\vcpkg\\buildtrees\\versioning\\versions\\zlib\\827111046e37c98153d9d82bb6fa4183b6d728e4\r\n...\r\n```\r\n\r\n3. Build the project.\r\n```\r\nPS D:\\versions-test\\build> cmake --build .\r\n[2/2] Linking CXX executable main.exe\r\n```\r\n\r\n4. Run it!\r\n```\r\nPS D:\\versions-test\\build> ./main.exe\r\nfmt version is 70103\r\nzlib version is 1.2.11\r\n```\r\n\r\nTake a look at the output:\r\n\r\n```\r\nfmt[core]:x86-windows -> 7.1.3#1 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\fmt\\4f8427eb0bd40da1856d4e67bde39a4fda689d72\r\n...\r\nzlib[core]:x86-windows -> 1.2.11#9 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\zlib\\827111046e37c98153d9d82bb6fa4183b6d728e4\r\n```\r\n\r\nInstead of using the portfiles in `ports/`, vcpkg is checking out the files for each version in `buildtrees/versioning/versions/`. The files in `ports/` are still used when running vcpkg in classic mode.\r\n\r\n_NOTE: Output from vcpkg while configuring CMake is only available when using CMake version `3.18` or newer. If you're using an older CMake you can check the `vcpkg-manifest-install.log` file in your build directory instead._\r\n\r\nRead our [manifests announcement blog post](https://devblogs.microsoft.com/cppblog/vcpkg-accelerate-your-team-development-environment-with-binary-caching-and-manifests/#using-manifests-with-msbuild-projects) to learn how to use manifests with MSBuild.\r\n\r\n### Manifest changes\r\nIf you have used manifests before you will notice that there are some new JSON properties. Let's review these changes:\r\n\r\n#### **`version`**\r\n```json\r\n{\r\n    \"name\": \"versions-test\",\r\n    \"version\": \"1.0.0\"\r\n}\r\n```\r\n\r\nThis is your project's version declaration. Previously, you could only declare versions for your projects using the `version-string` property. Now that versioning has come around, vcpkg is aware of some new versioning schemes.\r\n\r\nVersion scheme   | Description\r\n---------------- | ---------------\r\n`version`        | Dot-separated numerics: `1.0.0.5`.\r\n`version-semver` | Compliant [semantic versions](https://semver.org): `1.2.0` and `1.2.0-rc`.\r\n`version-date`   | Dates in `YYYY-MM-DD` format: `2021-01-01`\r\n`version-string` | Arbitrary strings: `vista`, `candy`.\r\n\r\n#### **`version>=`** \r\n```json\r\n{\r\n    \"dependencies\": [\r\n        { \"name\": \"fmt\", \"version>=\": \"7.1.3\" },\r\n        \"zlib\"\r\n    ]\r\n}\r\n```\r\n\r\nThis property is used to express minimum version constraints, it is allowed only as part of the `\"dependencies\"` declarations. In our example we set an explicit constraint on version `7.1.3#1` of `fmt`. \r\n\r\nVcpkg is allowed to upgrade this constraint if a transitive dependency requires a newer version. For example, if `zlib` were to declare a dependency on `fmt` version `7.1.4` then vcpkg would install `7.1.4` instead.\r\n\r\nVcpkg uses a minimum version approach, in our example, even if `fmt` version `8.0.0` were to be released, vcpkg would still install version `7.1.3#1` as that is the minimum version that satisfies the constraint. The advantages of this approach are that you don't get unexpected dependency upgrades when you update vcpkg and you get reproducible builds (in terms of version used) as long as you use the same manifest. \r\n\r\nIf you want to upgrade your dependencies, you can bump the minimum version constraint or use a newer baseline.\r\n\r\n#### **`builtin-baseline`**\r\n\r\n```json\r\n{ \"builtin-baseline\": \"3426db05b996481ca31e95fff3734cf23e0f51bc\" }\r\n```\r\n\r\nThis field declares the versioning baseline for all ports. Setting a baseline is required to enable versioning, otherwise you will get the current versions on the ports directory. You can run 'git rev-parse HEAD' to get the current commit of vcpkg and set it as the builtin-baseline. See the [`builtin-baseline` documentation](../users/versioning.md#builtin-baseline) for more information.\r\n\r\nIn our example, you can notice that we do not declare a version constraint for `zlib`; instead, the version is taken from the baseline. Internally, vcpkg will look in commit `3426db05b996481ca31e95fff3734cf23e0f51bc` to find out what version of `zlib` was the latest at that point in time (in our case it was `1.2.11#9`).\r\n\r\nDuring version resolution, baseline versions are treated as minimum version constraints. If you declare an explicit constraint that is lower than a baseline version, the explicit constraint will be upgraded to the baseline version. \r\n\r\nFor example, if we modified our dependencies like this:\r\n```json\r\n{ \"dependencies\": [\r\n    {\r\n        \"name\": \"fmt\",\r\n        \"version>=\": \"7.1.3#1\"\r\n    },\r\n    {\r\n        \"name\": \"zlib\",\r\n        \"version>=\": \"1.2.11#7\"\r\n    }\r\n] }\r\n```\r\n\r\n_NOTE: The value `1.2.11#7` represents version `1.2.11`, port version `7`._\r\n\r\nSince the baseline introduces a minimum version constraint for `zlib` at `1.2.11#9` and a higher version does satisfy the minimum version constraint for `1.2.11#7`, vcpkg is allowed to upgrade it. \r\n\r\nBaselines are also a convenient mechanism to upgrade multiple versions at a time, for example, if you wanted to depend on multiple `boost` libraries, it is more convenient to set the `baseline` once than declaring a version constraint on each package.\r\n\r\nBut what if you want to pin a version older than the baseline? \r\n\r\n#### **`overrides`**\r\n\r\nSince baselines establish a version floor for all packages and explicit constraints get upgraded when they are lower than the baseline, we need another mechanism to downgrade versions past the baseline.\r\n\r\nThe mechanism vcpkg provides for that scenario is `overrides`. When an override is declared on a package, vcpkg will ignore all other version constraints either directly declared in the manifest or from transitive dependencies. In short, `overrides` will force vcpkg to use the exact version declared, period.\r\n\r\nLet's modify our example once more, this time to force vcpkg to use version `6.0.0` of `fmt`.\r\n\r\n```json\r\n{\r\n    \"name\": \"versions-test\",\r\n    \"version\": \"1.0.0\",\r\n    \"dependencies\": [\r\n        {\r\n            \"name\": \"fmt\",\r\n            \"version>=\": \"7.1.3#1\"\r\n        },\r\n        {\r\n            \"name\": \"zlib\",\r\n            \"version>=\": \"1.2.11#7\"\r\n        }\r\n    ],\r\n    \"builtin-baseline\": \"3426db05b996481ca31e95fff3734cf23e0f51bc\",\r\n    \"overrides\": [\r\n        {\r\n            \"name\": \"fmt\",\r\n            \"version\": \"6.0.0\"\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\nRebuild our project:\r\n\r\n```\r\nPS D:\\versions-test\\build> rm ./CMakeCache.txt\r\nPS D:\\versions-test\\build> rm -r ./vcpkg_installed\r\nPS D:\\versions-test\\build> cmake -G Ninja -DCMAKE_TOOLCHAIN_FILE=D:/vcpkg/scripts/buildsystems/vcpkg.cmake ..\r\n-- Running vcpkg install\r\nDetecting compiler hash for triplet x86-windows...\r\nThe following packages will be built and installed:\r\n    fmt[core]:x86-windows -> 6.0.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\fmt\\d99b6a35e1406ba6b6e09d719bebd086f83ed5f3\r\n    zlib[core]:x86-windows -> 1.2.11#9 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\zlib\\827111046e37c98153d9d82bb6fa4183b6d728e4\r\n...\r\nPS D:\\versions-test\\build> cmake --build .\r\n[2/2] Linking CXX executable main.exe\r\n```\r\n\r\nAnd run it!\r\n```\r\nPS D:\\versions-test\\build> .\\main.exe\r\nfmt version is 60000\r\nzlib version is 1.2.11\r\n```\r\n\r\nNotice how the `fmt` is now at version `6.0.0` just like we wanted.\r\n\r\n## Versions and custom ports\r\n\r\nThe last thing to discuss is how overlay ports interact with versioning resolution. The answer is: they don't.\r\n\r\nGoing into more detail, when you provide an overlay for a port, vcpkg will always use the overlay port without caring what version is contained in it. The reasons are two-fold: (1) it is consistent with the existing behavior of overlay ports of completely masking the existing port, and (2) overlay ports do not (and are not expected to) provide enough information to power vcpkg's versioning feature.\r\n\r\nIf you want to have flexible port customization along with versioning, you should consider making your own custom registry. See our [registries specification for more details](../specifications/registries.md).\r\n\r\n## Further reading\r\n\r\nIf you're interested in delving deeper into the details of how versioning works we recommended that you read the [original versioning specification](../specifications/versioning.md) and the [implementation details](../users/versioning.implementation-details.md).\r\n\r\nSee also:\r\n\r\n* [Versioning docs](../users/versioning.md)\r\n* [Original specification](../specifications/versioning.md)\r\n* [Versioning implementation details](../users/versioning.implementation-details.md)\r\n","Nav":"#"},{"Path":"/en/docs/maintainers/authoring-script-ports.html","Name":"Authoring-script-ports","Source":"# Authoring Script Ports\r\n\r\nPorts can expose functions for other ports to consume during their build. For\r\nexample, the `vcpkg-cmake` helper port exposes the `vcpkg_cmake_configure()`\r\nhelper function. Packaging common scripts into a shared helper port makes\r\nmaintenance easier because all consumers can be updated from a single place.\r\nBecause the scripts come from a port, they can be versioned and depended upon\r\nvia all the same mechanisms as any other port.\r\n\r\nScript ports are implemented via the `vcpkg-port-config.cmake` extension\r\nmechanism. Before invoking the `portfile.cmake` of a port, vcpkg will first\r\nimport `share/<port>/vcpkg-port-config.cmake` from each direct dependency. If\r\nthe direct dependency is a host dependency, the import will be performed in the\r\nhost installed tree (e.g.\r\n`${HOST_INSTALLED_DIR}/share/<port>/vcpkg-port-config.cmake`).\r\n\r\nOnly direct dependencies are considered for `vcpkg-port-config.cmake` inclusion.\r\nThis means that if a script port relies on another script port, it must\r\nexplicitly import the `vcpkg-port-config.cmake` of its dependency.\r\n\r\nScript-to-script dependencies should not be marked as host. The dependency from\r\na target port to a script should be marked host, which means that scripts should\r\nalways already be natively compiling. By making script-to-script dependencies\r\n`\"host\": false`, it ensures that one script can depend upon the other being in\r\nits same install directory.\r\n\r\nPorts should never provide a `vcpkg-port-config.cmake` file under a different\r\n`share/` subdirectory than the current port (`${PORT}`).\r\n\r\n## Example\r\n\r\n```cmake\r\n# ${CURRENT_PACKAGES_DIR}/share/my-helper/vcpkg-port-config.cmake\r\n\r\n# This include guard ensures the file will be loaded only once\r\ninclude_guard(GLOBAL)\r\n\r\n# This is how you could pull in a transitive dependency\r\ninclude(\"${CMAKE_CURRENT_LIST_DIR}/../my-other-helper/vcpkg-port-config.cmake\")\r\n\r\n# Finally, it is convention to put each public function into a separate file with a matching name\r\ninclude(\"${CMAKE_CURRENT_LIST_DIR}/my_helper_function_01.cmake\")\r\ninclude(\"${CMAKE_CURRENT_LIST_DIR}/my_helper_function_02.cmake\")\r\ninclude(\"${CMAKE_CURRENT_LIST_DIR}/my_helper_function_03.cmake\")\r\n```\r\n","Nav":"#"},{"Path":"/en/docs/maintainers/cmake-guidelines.html","Name":"CMake-guidelines","Source":"# CMake Guidelines\r\n\r\nWe expect that all CMake scripts that are either:\r\n\r\n- In the `scripts/` directory, or\r\n- In a `vcpkg-*` port\r\n\r\nshould follow the guidelines laid out in this document.\r\nExisting scripts may not follow these guidelines yet;\r\nit is expected that we will continue to update old scripts\r\nto fall in line with these guidelines.\r\n\r\nThese guidelines are intended to create stability in our scripts.\r\nWe hope that they will make both forwards and backwards compatibility easier.\r\n\r\n## The Guidelines\r\n\r\n- Except for out-parameters, we always use `cmake_parse_arguments()`\r\n  rather than function parameters or referring to `${ARG<N>}`.\r\n  - This doesn't necessarily need to be followed for \"script-local helper functions\"\r\n    - In this case, positional parameters should be put in the function\r\n      declaration (rather than using `${ARG<N>}`),\r\n      and should be named according to local rules (i.e. `snake_case`).\r\n    - Exception: positional parameters that are optional should be\r\n      given a name via `set(argument_name \"${ARG<N>}\")`, after checking `ARGC`.\r\n  - Out-parameters should be the first parameter to a function. Example:\r\n  ```cmake\r\n  function(format out_var)\r\n    cmake_parse_arguments(PARSE_ARGV 1 \"arg\" ...)\r\n    # ... set(buffer \"output\")\r\n    set(\"${out_var}\" \"${buffer}\" PARENT_SCOPE)\r\n  endfunction()\r\n  ```\r\n- There are no unparsed or unused arguments.\r\n  Always check for `ARGN` or `arg_UNPARSED_ARGUMENTS`.\r\n  `FATAL_ERROR` when possible, `WARNING` if necessary for backwards compatibility.\r\n- All `cmake_parse_arguments` must use `PARSE_ARGV`.\r\n- All `foreach` loops must use `IN LISTS`, `IN ITEMS`, or `RANGE`.\r\n- The variables `${ARGV}` and `${ARGN}` are unreferenced,\r\n  except in helpful messages to the user.\r\n  - (i.e., `message(FATAL_ERROR \"blah was passed extra arguments: ${ARGN}\")`)\r\n- We always use functions, not macros or top level code.\r\n  - Exception: \"script-local helper macros\". It is sometimes helpful to define a small macro.\r\n    This should be done sparingly, and functions should be preferred.\r\n  - Exception: `vcpkg.cmake`'s `find_package`.\r\n- Scripts in the scripts tree should not be expected to need observable changes\r\n  as part of normal operation.\r\n  - Example violation: `vcpkg_acquire_msys()` has hard-coded packages and versions\r\n    that need updating over time due to the MSYS project dropping old packages.\r\n  - Example exception: `vcpkg_from_sourceforge()` has a list of mirrors which\r\n    needs maintenance, but does not have an observable behavior impact on the callers.\r\n- Rules for quoting: there are three kinds of arguments in CMake -\r\n  unquoted (`foo(BAR)`), quoted (`foo(\"BAR\")`), and bracketed (`foo([[BAR]])`).\r\n  Follow these rules to quote correctly:\r\n  - If an argument contains a variable expansion `${...}`,\r\n    it must be quoted.\r\n    - Exception: a \"splat\" variable expansion, when one variable will be\r\n      passed to a function as multiple arguments. In this case, the argument\r\n      should simply be `${foo}`:\r\n      ```cmake\r\n      vcpkg_list(SET working_directory)\r\n      if(DEFINED \"arg_WORKING_DIRECTORY\")\r\n        vcpkg_list(SET working_directory WORKING_DIRECTORY \"${arg_WORKING_DIRECTORY}\")\r\n      endif()\r\n      # calls do_the_thing() if NOT DEFINED arg_WORKING_DIRECTORY,\r\n      # else calls do_the_thing(WORKING_DIRECTORY \"${arg_WORKING_DIRECTORY}\")\r\n      do_the_thing(${working_directory})\r\n      ```\r\n  - Otherwise, if the argument contains any escape sequences that are not\r\n    `\\\\`, `\\\"`, or `\\$`, that argument must be a quoted argument.\r\n    - For example: `\"foo\\nbar\"` must be quoted.\r\n  - Otherwise, if the argument contains a `\\`, a `\"`, or a `$`,\r\n    that argument should be bracketed.\r\n    - Example:\r\n      ```cmake\r\n      set(x [[foo\\bar]])\r\n      set(y [=[foo([[bar\\baz]])]=])\r\n      ```\r\n  - Otherwise, if the argument contains characters that are\r\n    not alphanumeric or `_`, that argument should be quoted.\r\n  - Otherwise, the argument should be unquoted.\r\n  - Exception: arguments to `if()` of type `<variable|string>` should always be quoted:\r\n    - Both arguments to the comparison operators -\r\n      `EQUAL`, `STREQUAL`, `VERSION_LESS`, etc.\r\n    - The first argument to `MATCHES` and `IN_LIST`\r\n    - Example:\r\n      ```cmake\r\n      if(\"${FOO}\" STREQUAL \"BAR\") # ...\r\n      if(\"${BAZ}\" EQUAL \"0\") # ...\r\n      if(\"FOO\" IN_LIST list_variable) # ...\r\n      if(\"${bar}\" MATCHES [[a[bcd]+\\.[bcd]+]]) # ...\r\n      ```\r\n    - For single expressions and for other types of predicates that do not\r\n    take `<variable|string>`, use the normal rules.\r\n- There are no \"pointer\" or \"in-out\" parameters\r\n  (where a user passes a variable name rather than the contents),\r\n  except for simple out-parameters.\r\n- Variables are not assumed to be empty.\r\n  If the variable is intended to be used locally,\r\n  it must be explicitly initialized to empty with `set(foo \"\")` if it is a string variable,\r\n  and `vcpkg_list(SET foo)` if it is a list variable.\r\n- `set(var)` should not be used. Use `unset(var)` to unset a variable,\r\n  `set(var \"\")` to set it to the empty string,\r\n  and `vcpkg_list(SET var)` to set it to the empty list.\r\n  _Note: the empty string and the empty list are the same value;_\r\n  _this is a notational difference rather than a difference in result_\r\n- All variables expected to be inherited from the parent scope across an API boundary\r\n  (i.e. not a file-local function) should be documented.\r\n  Note that all variables mentioned in triplets.md are considered documented.\r\n- Out parameters are only set in `PARENT_SCOPE` and are never read.\r\n  See also the helper `z_vcpkg_forward_output_variable()` to forward out parameters through a function scope.\r\n- `CACHE` variables are used only for global variables which are shared internally among strongly coupled\r\n  functions and for internal state within a single function to avoid duplicating work.\r\n  These should be used extremely sparingly and should use the `Z_VCPKG_` prefix to avoid\r\n  colliding with any local variables that would be defined by any other code.\r\n  - Examples:\r\n    - `vcpkg_cmake_configure`'s `Z_VCPKG_CMAKE_GENERATOR`\r\n    - `z_vcpkg_get_cmake_vars`'s `Z_VCPKG_GET_CMAKE_VARS_FILE`\r\n- `include()`s are only allowed in `ports.cmake` or `vcpkg-port-config.cmake`.\r\n- `foreach(RANGE)`'s arguments _must always be_ natural numbers,\r\n  and `<start>` _must always be_ less than or equal to `<stop>`.\r\n  - This must be checked by something like:\r\n  ```cmake\r\n  if(\"${start}\" LESS_EQUAL \"${end}\")\r\n    foreach(RANGE \"${start}\" \"${end}\")\r\n      ...\r\n    endforeach()\r\n  endif()\r\n  ```\r\n- All port-based scripts must use `include_guard(GLOBAL)`\r\n  to avoid being included multiple times.\r\n\r\n### CMake Versions to Require\r\n\r\n- All CMake scripts, except for `vcpkg.cmake`,\r\n  may assume the version of CMake that is present in the\r\n  `cmake_minimum_required` of `ports.cmake`.\r\n  - This `cmake_minimum_required` should be bumped every time a new version\r\n    of CMake is added to `vcpkgTools.xml`, as should the\r\n    `cmake_minimum_required` in all of the helper `CMakeLists.txt` files.\r\n- `vcpkg.cmake` must assume a version of CMake back to 3.7.2 in general\r\n  - Specific functions and options may assume a greater CMake version;\r\n    if they do, make sure to comment that function or option\r\n    with the required CMake version.\r\n\r\n\r\n### Changing Existing Functions\r\n\r\n- Never remove arguments in non-internal functions;\r\n  if they should no longer do anything, just take them as normal and warn on use.\r\n- Never add a new mandatory argument.\r\n\r\n### Naming Variables\r\n\r\n- `cmake_parse_arguments`: set prefix to `\"arg\"`\r\n- Local variables are named with `snake_case`\r\n- Internal global variable names are prefixed with `Z_VCPKG_`.\r\n- External experimental global variable names are prefixed with `X_VCPKG_`.\r\n\r\n- Internal functions are prefixed with `z_vcpkg_`\r\n  - Functions which are internal to a single function (i.e., helper functions)\r\n    are named `[z_]<func>_<name>`, where `<func>` is the name of the function they are\r\n    a helper to, and `<name>` is what the helper function does.\r\n    - `z_` should be added to the front if `<func>` doesn't have a `z_`,\r\n      but don't name a helper function `z_z_foo_bar`.\r\n- Public global variables are named `VCPKG_`.\r\n","Nav":"#"},{"Path":"/en/docs/maintainers/control-files.html","Name":"Control-files","Source":"# CONTROL files\n\n**CONTROL files are retained for backwards compatibility with earlier versions of vcpkg;\nall new features are added only to [vcpkg.json manifest files](manifest-files.md), and we recommend using vcpkg.json for any newly authored port.\nUse `./vcpkg format-manifest ports/<portname>/CONTROL` to convert an existing CONTROL file to a vcpkg.json file.**\n\nThe `CONTROL` file contains metadata about the port.  The syntax is based on [the Debian `control` format][debian] although we only support the subset of fields documented here.\n\nField names are case-sensitive and start the line without leading whitespace.  Paragraphs are separated by one or more empty lines.\n\n[debian]: https://www.debian.org/doc/debian-policy/ch-controlfields.html\n\n## Source Paragraph\n\nThe first paragraph in a `CONTROL` file is the Source paragraph.  It must have a `Source`, `Version`, and `Description` field. The full set of fields is documented below.\n\n### Examples:\n```no-highlight\nSource: ace\nVersion: 6.5.5\nDescription: The ADAPTIVE Communication Environment\n```\n\n```no-highlight\nSource: vtk\nVersion: 8.2.0\nPort-Version: 2\nDescription: Software system for 3D computer graphics, image processing, and visualization\nBuild-Depends: zlib, libpng, tiff, libxml2, jsoncpp, glew, freetype, expat, hdf5, libjpeg-turbo, proj4, lz4, libtheora, atlmfc (windows), eigen3, double-conversion, pugixml, libharu, sqlite3, netcdf-c\n```\n\n\n### Recognized fields\n\n#### Source\nThe name of the port.\n\nWhen adding new ports be aware that the name may conflict with other projects that are not a part of vcpkg.  For example `json` conflicts with too many other projects so you should add a scope to the name such as `taocpp-json` to make it unique.  Verify there are no conflicts on a search engine as well as on other package collections.\n\nPackage collections to check for conflicts:\n\n+ [Repology](https://repology.org/projects/)\n+ [Debian packages](https://www.debian.org/distrib/packages)\n+ [Packages search](https://pkgs.org/)\n\n#### Version\nThe library version.\n\nThis field is an alphanumeric string that may also contain `.`, `_`, or `-`. No attempt at ordering versions is made; all versions are treated as bit strings and are only evaluated for equality.\n\nFor tagged-release ports, we follow the following convention:\n\n1. If the port follows a scheme like `va.b.c`, we remove the leading `v`. In this case, it becomes `a.b.c`.\n2. If the port includes its own name in the version like `curl-7_65_1`, we remove the leading name: `7_65_1`\n\nFor rolling-release ports, we use the date that the _commit was accessed by you_, formatted as `YYYY-MM-DD`. Stated another way: if someone had a time machine and went to that date, they would see this commit as the latest master.\n\nFor example, given:\n1. The latest commit was made on 2019-04-19\n2. The current version string is `2019-02-14-1`\n3. Today's date is 2019-06-01.\n\nThen if you update the source version today, you should give it version `2019-06-01`.\n\n#### Port-Version\nThe version of the port.\n\nThis field is a non-negative integer. It allows one to version the port file separately from the version of the underlying library; if you make a change to a port, without changing the underlying version of the library, you should increment this field by one (starting at `0`, which is equivalent to no `Port-Version` field). When the version of the underlying library is upgraded, this field should be set back to `0` (i.e., delete the `Port-Version` field).\n\n##### Examples:\n```no-highlight\nVersion: 1.0.5\nPort-Version: 2\n```\n```no-highlight\nVersion: 2019-03-21\n```\n\n#### Description\nA description of the library.\n\nBy convention the first line of the description is a summary of the library.  An optional detailed description follows.  The detailed description can be multiple lines, all starting with whitespace.\n\n##### Examples:\n```no-highlight\nDescription: C++ header-only JSON library\n```\n```no-highlight\nDescription: Mosquitto is an open source message broker that implements the MQ Telemetry Transport protocol versions 3.1 and 3.1.1.\n  MQTT provides a lightweight method of carrying out messaging using a publish/subscribe model. This makes it suitable for \"machine\n  to machine\" messaging such as with low power sensors or mobile devices such as phones, embedded computers or microcontrollers like the Arduino.\n```\n\n#### Homepage\nThe URL of the homepage for the library where a user is able to find additional documentation or the original source code.\n\nExample:\n```no-highlight\nHomepage: https://github.com/Microsoft/vcpkg\n```\n\n#### Build-Depends\nComma separated list of vcpkg ports the library has a dependency on.\n\nVcpkg does not distinguish between build-only dependencies and runtime dependencies. The complete list of dependencies needed to successfully use the library should be specified.\n\n*For example: websocketpp is a header only library, and thus does not require any dependencies at install time. However, downstream users need boost and openssl to make use of the library. Therefore, websocketpp lists boost and openssl as dependencies*\n\nIf the port is dependent on optional features of another library those can be specified using the `portname[featurelist]` syntax. If the port does not require any features from the dependency, this should be specified as `portname[core]`.\n\nDependencies can be filtered based on the target triplet to support differing requirements. These filters use the same syntax as the Supports field below and are surrounded in parentheses following the portname and feature list.\n\n##### Example:\n```no-highlight\nBuild-Depends: rapidjson, curl[core,openssl] (!windows), curl[core,winssl] (windows)\n```\n\n#### Default-Features\nComma separated list of optional port features to install by default.\n\nThis field is optional.\n\n##### Example:\n```no-highlight\nDefault-Features: dynamodb, s3, kinesis\n```\n\n<a name=\"Supports\"></a>\n#### Supports\nExpression that evaluates to true when the port is expected to build successfully for a triplet.\n\nCurrently, this field is only used in the CI testing to skip ports. In the future, this mechanism is intended to warn users in advance that a given install tree is not expected to succeed. Therefore, this field should be used optimistically; in cases where a port is expected to succeed 10% of the time, it should still be marked \"supported\".\n\nThe grammar for the supports expression uses standard operators:\n- `!expr` - negation\n- `expr|expr` - or (`||` is also supported)\n- `expr&expr` - and (`&&` is also supported)\n- `(expr)` - grouping/precedence\n\nThe predefined expressions are computed from standard triplet settings:\n- `native` - `TARGET_TRIPLET` == `HOST_TRIPLET`\n- `x64` - `VCPKG_TARGET_ARCHITECTURE` == `\"x64\"`\n- `x86` - `VCPKG_TARGET_ARCHITECTURE` == `\"x86\"`\n- `arm` - `VCPKG_TARGET_ARCHITECTURE` == `\"arm\"` or `VCPKG_TARGET_ARCHITECTURE` == `\"arm64\"`\n- `arm64` - `VCPKG_TARGET_ARCHITECTURE` == `\"arm64\"`\n- `windows` - `VCPKG_CMAKE_SYSTEM_NAME` == `\"\"` or `VCPKG_CMAKE_SYSTEM_NAME` == `\"WindowsStore\"`\n- `uwp` - `VCPKG_CMAKE_SYSTEM_NAME` == `\"WindowsStore\"`\n- `linux` - `VCPKG_CMAKE_SYSTEM_NAME` == `\"Linux\"`\n- `osx` - `VCPKG_CMAKE_SYSTEM_NAME` == `\"Darwin\"`\n- `android` - `VCPKG_CMAKE_SYSTEM_NAME` == `\"Android\"`\n- `static` - `VCPKG_LIBRARY_LINKAGE` == `\"static\"`\n- `wasm32` - `VCPKG_TARGET_ARCHITECTURE` == `\"wasm32\"`\n- `emscripten` - `VCPKG_CMAKE_SYSTEM_NAME` == `\"Emscripten\"`\n\nThese predefined expressions can be overridden in the triplet file via the [`VCPKG_DEP_INFO_OVERRIDE_VARS`](../users/triplets.md) option.\n\nThis field is optional and defaults to true.\n\n> Implementers' Note: these terms are computed from the triplet via the `vcpkg_get_dep_info` mechanism.\n\n##### Example:\n```no-highlight\nSupports: !(uwp|arm)\n```\n\n## Feature Paragraphs\n\nMultiple optional features can be specified in the `CONTROL` files.  It must have a `Feature` and `Description` field.  It can optionally have a `Build-Depends` field.  It must be separated from other paragraphs by one or more empty lines.\n\n### Example:\n```no-highlight\nSource: vtk\nVersion: 8.2.0-2\nDescription: Software system for 3D computer graphics, image processing, and visualization\nBuild-Depends: zlib, libpng, tiff, libxml2, jsoncpp, glew, freetype, expat, hdf5, libjpeg-turbo, proj4, lz4, libtheora, atlmfc (windows), eigen3, double-conversion, pugixml, libharu, sqlite3, netcdf-c\n\nFeature: openvr\nDescription: OpenVR functionality for VTK\nBuild-Depends: sdl2, openvr\n\nFeature: qt\nDescription: Qt functionality for VTK\nBuild-Depends: qt5\n\nFeature: mpi\nDescription: MPI functionality for VTK\nBuild-Depends: mpi, hdf5[parallel]\n\nFeature: python\nDescription: Python functionality for VTK\nBuild-Depends: python3\n```\n\n### Recognized fields\n\n#### Feature\nThe name of the feature.\n\n#### Description\nA description of the feature using the same syntax as the port  `Description` field.\n\n#### Build-Depends\nThe list of dependencies required to build and use this feature.\n\nOn installation the dependencies from all selected features are combined to produce the full dependency list for the build. This field follows the same syntax as `Build-Depends` in the Source Paragraph.\n","Nav":"#"},{"Path":"/en/docs/maintainers/execute_process.html","Name":"Execute_process","Source":"# execute_process\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/execute_process.md).\n\nIntercepts all calls to execute_process() inside portfiles and fails when Download Mode\nis enabled.\n\nIn order to execute a process in Download Mode call `vcpkg_execute_in_download_mode()` instead.\n\n## Source\n[scripts/cmake/execute\\_process.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/execute_process.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/internal/vcpkg_catalog_release_process.html","Name":"vcpkg_catalog_release_process","Source":"# vcpkg_catalog_release_process\r\n\r\nThis document describes the acceptance criteria / process we use when doing a vcpkg release.\r\n\r\n1. Generate a new GitHub Personal Access Token with repo permissions.\r\n2. Using the PAT, invoke $/scripts/Get-Changelog.ps1 `-StartDate (previous release date) -EndDate (Get-Date) -OutFile path/to/results.md`\r\n3. Create a new GitHub release in this repo.\r\n4. Submit a vcpkg.ci (full tree rebuild) run with the same SHA as that release.\r\n5. Use the \"auto-generate release notes\". Copy the \"new contributors\" and \"full changelog\" parts to the end of `path/to/results.md`.\r\n6. Change `## New Contributors` to `#### New Contributors`\r\n7. In `path/to/results.md`, update `LINK TO BUILD` with the most recent link to vcpkg.ci run.\r\n8. In `path/to/results.md`, fill out the tables for number of existing ports and successful ports.\r\n9. Replace the contents of the release notes with the contents of `path/to/results.md`\r\n10. After the full rebuild submission completes, update the link to the one for the exact SHA, the counts, and remove \"(tentative)\".\r\n","Nav":"#"},{"Path":"/en/docs/maintainers/internal/vcpkg_tool_release_process.html","Name":"vcpkg_tool_release_process","Source":"# vcpkg_tool_release_process\r\n\r\nThis document describes the acceptance criteria / process we use when doing a vcpkg-tool update,\r\nsuch as https://github.com/microsoft/vcpkg/pull/23757\r\n\r\n1. Verify that all tests etc. are passing in the vcpkg-tool repo's `main` branch, and that the\r\n  contents therein are acceptable for release. (Steps after this will sign code there, so this\r\n  review is responsible gating what has access to code signing.)\r\n2. On your machine, in a prompt changed to the vcpkg-tool repo,\r\n  `git fetch https://github.com/microsoft/vcpkg-tool main && git switch -d FETCH_HEAD`\r\n3. Check that the changes there are in fact the changes that we want in that release. (Be aware,\r\n  you are responsible for what is about to be signed with a Microsoft code signing certificate by\r\n  proceeding)\r\n4. `git push https://devdiv.visualstudio.com/DevDiv/_git/vcpkg FETCH_HEAD:main`\r\n5. Monitor the resulting signed build at:\r\n  https://devdiv.visualstudio.com/DefaultCollection/DevDiv/_build?definitionId=13610\r\n  and/or manually submit one. (The push is supposed to automatically submit a build but that\r\n  has been somewhat unstable at the time of this writing.)\r\n6. The signed build will automatically create a draft GitHub release at\r\n  https://github.com/microsoft/vcpkg-tool/releases . Erase the contents filled in there and press\r\n  the \"auto generate release notes\" button. Manually remove any entries created by the automated\r\n  localization tools which will start with `* LEGO: Pull request from juno/`.\r\n7. Publish that draft release as \"pre-release\".\r\n8. Smoke test the 'one liner' installer: (Where 2022-03-30 is replaced with the right release name)\r\n    * Powershell:\r\n        `iex (iwr https://github.com/microsoft/vcpkg-tool/releases/download/2022-03-30/vcpkg-init.ps1)`\r\n    * Batch:\r\n        `curl -L -o vcpkg-init.cmd https://github.com/microsoft/vcpkg-tool/releases/download/2022-03-30/vcpkg-init.ps1 && .\\vcpkg-init.cmd`\r\n    * Bash:\r\n        `. <(curl https://github.com/microsoft/vcpkg-tool/releases/download/2022-03-30/vcpkg-init.sh -L)`\r\n9. In the vcpkg repo, draft a PR which updates `bootstrap-vcpkg.sh` and `boostrap-vcpkg.ps1`\r\n  with the new release date, and update SHAs as appropriate in the .sh script. (For example, see\r\n  https://github.com/microsoft/vcpkg/pull/23757)\r\n10. Submit a new full tree rebuild by https://dev.azure.com/vcpkg/public/_build?definitionId=29\r\n  (microsoft.vcpkg.ci as of this writing) and queue a new build targeting branch\r\n  `refs/pull/ The PR number created in the previous step /head` (for example\r\n  `refs/pull/24131/head`\r\n  https://dev.azure.com/vcpkg/public/_build/results?buildId=70703&view=results)\r\n11. (Probably the next day) Check over the failures and ensure any differences with the most recent\r\n  full rebuild using the previous tool version are understood.\r\n12. Merge the tool update PR.\r\n13. Change the github release in vcpkg-tool from \"prerelease\" to \"release\". (This automatically\r\n  updates the aka.ms links)\r\n","Nav":"#"},{"Path":"/en/docs/maintainers/internal/z_vcpkg_apply_patches.html","Name":"Z_vcpkg_apply_patches","Source":"# z_vcpkg_apply_patches\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/).\n\n**Only for internal use in vcpkg helpers. Behavior and arguments will change without notice.**\n\nApply a set of patches to a source tree.\n\n```cmake\nz_vcpkg_apply_patches(\n    SOURCE_PATH <path-to-source>\n    [QUIET]\n    PATCHES <patch>...\n)\n```\n\nThe `<path-to-source>` should be set to `${SOURCE_PATH}` by convention,\nand is the path to apply the patches in.\n\n`z_vcpkg_apply_patches` will take the list of `<patch>`es,\nwhich are by default relative to the port directory,\nand apply them in order using `git apply`.\nGenerally, these `<patch>`es take the form of `some.patch`\nto select patches in the port directory.\nOne may also download patches and use `${VCPKG_DOWNLOADS}/path/to/some.patch`.\n\nIf `QUIET` is not passed, it is a fatal error for a patch to fail to apply;\notherwise, if `QUIET` is passed, no message is printed.\nThis should only be used for edge cases, such as patches that are known to fail even on a clean source tree.\n\n## Source\n[scripts/cmake/z\\_vcpkg\\_apply\\_patches.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/z_vcpkg_apply_patches.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/internal/z_vcpkg_forward_output_variable.html","Name":"Z_vcpkg_forward_output_variable","Source":"# z_vcpkg_forward_output_variable\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/).\n\nThis macro helps with forwarding values from inner function calls,\nthrough a local function scope, into pointer out parameters.\n\n```cmake\nz_vcpkg_forward_output_variable(ptr_to_parent_var var_to_forward)\n```\n\nis equivalent to\n\n```cmake\nif(DEFINED ptr_to_parent_var)\n    if(DEFINED value_var)\n        set(\"${ptr_to_parent_var}\" \"${value_var}\" PARENT_SCOPE)\n    else()\n        unset(\"${ptr_to_parent_var}\" PARENT_SCOPE)\n    endif()\nendif()\n```\n\nTake note that the first argument should be a local variable that has a value of the parent variable name.\nMost commonly, this local is the result of a pointer-out parameter to a function.\nIf the variable in the first parameter is not defined, this function does nothing,\nsimplifying functions with optional out parameters.\nMost commonly, this should be used in cases like:\n\n```cmake\nfunction(my_function out_var)\n    file(SHA512 \"somefile.txt\" local_var)\n    z_vcpkg_forward_output_variable(out_var local_var)\nendfunction()\n```\n\n## Source\n[scripts/cmake/z\\_vcpkg\\_forward\\_output\\_variable.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/z_vcpkg_forward_output_variable.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/internal/z_vcpkg_function_arguments.html","Name":"Z_vcpkg_function_arguments","Source":"# z_vcpkg_function_arguments\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/).\n\n**Only for internal use in vcpkg helpers. Behavior and arguments will change without notice.**\nGet a list of the arguments which were passed in.\nUnlike `ARGV`, which is simply the arguments joined with `;`,\nso that `(A B)` is not distinguishable from `(\"A;B\")`,\nthis macro gives `\"A;B\"` for the first argument list,\nand `\"A\\;B\"` for the second.\n\n```cmake\nz_vcpkg_function_arguments(<out-var> [<N>])\n```\n\n`z_vcpkg_function_arguments` gets the arguments between `ARGV<N>` and the last argument.\n`<N>` defaults to `0`, so that all arguments are taken.\n\n## Example:\n```cmake\nfunction(foo_replacement)\n    z_vcpkg_function_arguments(ARGS)\n    foo(${ARGS})\n    ...\nendfunction()\n```\n\n## Source\n[scripts/cmake/z\\_vcpkg\\_function\\_arguments.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/z_vcpkg_function_arguments.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/internal/z_vcpkg_get_cmake_vars.html","Name":"Z_vcpkg_get_cmake_vars","Source":"# z_vcpkg_get_cmake_vars\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/).\n\n**Only for internal use in vcpkg helpers. Behavior and arguments will change without notice.**\nRuns a cmake configure with a dummy project to extract certain cmake variables\n\n## Usage\n```cmake\nz_vcpkg_get_cmake_vars(<out-var>)\n```\n\n`z_vcpkg_get_cmake_vars(cmake_vars_file)` sets `<out-var>` to\na path to a generated CMake file, with the detected `CMAKE_*` variables\nre-exported as `VCPKG_DETECTED_*`.\n\n## Notes\nAvoid usage in portfiles. \n\nAll calls to `z_vcpkg_get_cmake_vars` will result in the same output file;\nthe output file is not generated multiple times.\n\n## Examples\n\n* [vcpkg_configure_make](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_configure_make.cmake)\n\n### Basic Usage\n\n```cmake\nz_vcpkg_get_cmake_vars(cmake_vars_file)\ninclude(\"${cmake_vars_file}\")\nmessage(STATUS \"detected CXX flags: ${VCPKG_DETECTED_CXX_FLAGS}\")\n```\n\n## Source\n[scripts/cmake/z\\_vcpkg\\_get\\_cmake\\_vars.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/z_vcpkg_get_cmake_vars.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/internal/z_vcpkg_prettify_command_line.html","Name":"Z_vcpkg_prettify_command_line","Source":"# z_vcpkg_prettify_command_line\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/).\n\n**Only for internal use in vcpkg helpers. Behavior and arguments will change without notice.**\nTurn a command line into a formatted string.\n\n```cmake\nz_vcpkg_prettify_command_line(<out-var> <argument>...)\n```\n\nThis command is for internal use, when printing out to a message.\n\n## Examples\n\n* `scripts/cmake/vcpkg_execute_build_process.cmake`\n* `scripts/cmake/vcpkg_execute_required_process.cmake`\n* `scripts/cmake/vcpkg_execute_required_process_repeat.cmake`\n\n## Source\n[scripts/cmake/z\\_vcpkg\\_prettify\\_command\\_line.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/z_vcpkg_prettify_command_line.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/internal/z_vcpkg_setup_pkgconfig_path.cmake.html","Name":"Z_vcpkg_setup_pkgconfig_path.cmake","Source":"# z_vcpkg_setup_pkgconfig_path\n\nSetup the generated pkgconfig file path to PKG_CONFIG_PATH environment variable or restore PKG_CONFIG_PATH environment variable.\n\n```cmake\nz_vcpkg_setup_pkgconfig_path(BASE_DIRS <\"${CURRENT_INSTALLED_DIR}\" ...>)\nz_vcpkg_restore_pkgconfig_path()\n```\n\n`z_vcpkg_setup_pkgconfig_path` prepends `lib/pkgconfig` and `share/pkgconfig` directories for the given `BASE_DIRS` to the `PKG_CONFIG_PATH` environment variable. It creates or updates a backup of the previous value.\n`z_vcpkg_restore_pkgconfig_path` shall be called when leaving the scope which called `z_vcpkg_setup_pkgconfig_path` in order to restore the original value from the backup.\n","Nav":"#"},{"Path":"/en/docs/maintainers/internal/z_vcpkg_setup_pkgconfig_path.html","Name":"Z_vcpkg_setup_pkgconfig_path","Source":"# z_vcpkg_setup_pkgconfig_path\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/).\n\n`z_vcpkg_setup_pkgconfig_path` sets up environment variables to use `pkgconfig`, such as `PKG_CONFIG` and `PKG_CONFIG_PATH`.\nThe original values are restored with `z_vcpkg_restore_pkgconfig_path`. `BASE_DIRS` indicates the base directories to find `.pc` files; typically `${CURRENT_INSTALLED_DIR}`, or `${CURRENT_INSTALLED_DIR}/debug`.\n\n```cmake\nz_vcpkg_setup_pkgconfig_path(BASE_DIRS <\"${CURRENT_INSTALLED_DIR}\" ...>)\n# Build process that may transitively invoke pkgconfig\nz_vcpkg_restore_pkgconfig_path()\n```\n\n\n## Source\n[scripts/cmake/z\\_vcpkg\\_setup\\_pkgconfig\\_path.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/z_vcpkg_setup_pkgconfig_path.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/maintainer-guide.html","Name":"Maintainer-guide","Source":"# Maintainer Guidelines and Policies\r\n\r\nThis document lists a set of policies that you should apply when adding or updating a port recipe.\r\nIt is intended to serve the role of\r\n[Debian's Policy Manual](https://www.debian.org/doc/debian-policy/),\r\n[Homebrew's Maintainer Guidelines](https://docs.brew.sh/Maintainer-Guidelines), and\r\n[Homebrew's Formula Cookbook](https://docs.brew.sh/Formula-Cookbook).\r\n\r\n## PR Structure\r\n\r\n### Make separate Pull Requests per port\r\n\r\nWhenever possible, separate changes into multiple PRs.\r\nThis makes them significantly easier to review and prevents issues with one set of changes from holding up every other change.\r\n\r\n### Avoid trivial changes in untouched files\r\n\r\nFor example, avoid reformatting or renaming variables in portfiles that otherwise have no reason to be modified for the issue at hand.\r\nHowever, if you need to modify the file for the primary purpose of the PR (updating the library),\r\nthen obviously beneficial changes like fixing typos are appreciated!\r\n\r\n### Check names against other repositories\r\n\r\nA good service to check many at once is [Repology](https://repology.org/).\r\nIf the library you are adding could be confused with another one,\r\nconsider renaming to make it clear. We prefer when names are longer and/or\r\nunlikely to conflict with any future use of the same name. If the port refers\r\nto a library on GitHub, a good practice is to prefix the name with the organization\r\nif there is any chance of confusion.\r\n\r\n### Use GitHub Draft PRs\r\n\r\nGitHub Draft PRs are a great way to get CI or human feedback on work that isn't yet ready to merge.\r\nMost new PRs should be opened as drafts and converted to normal PRs once the CI passes.\r\n\r\nMore information about GitHub Draft PRs:\r\nhttps://github.blog/2019-02-14-introducing-draft-pull-requests/\r\n\r\n## Portfiles\r\n\r\n### Avoid deprecated helper functions\r\n\r\nAt this time, the following helpers are deprecated:\r\n\r\n1. `vcpkg_extract_source_archive()` should be replaced by [`vcpkg_extract_source_archive_ex()`](vcpkg_extract_source_archive_ex.md)\r\n2. `vcpkg_apply_patches()` should be replaced by the `PATCHES` arguments to the \"extract\" helpers (e.g. [`vcpkg_from_github()`](vcpkg_from_github.md))\r\n3. `vcpkg_build_msbuild()` should be replaced by [`vcpkg_install_msbuild()`](vcpkg_install_msbuild.md)\r\n4. `vcpkg_copy_tool_dependencies()` should be replaced by [`vcpkg_copy_tools()`](vcpkg_copy_tools.md)\r\n5. `vcpkg_configure_cmake` should be replaced by [`vcpkg_cmake_configure()`](ports/vcpkg-cmake/vcpkg_cmake_configure.md#vcpkg_cmake_configure) after removing `PREFER_NINJA` (from port [`vcpkg-cmake`](ports/vcpkg-cmake.md#vcpkg-cmake))\r\n6. `vcpkg_build_cmake` should be replaced by [`vcpkg_cmake_build()`](ports/vcpkg-cmake/vcpkg_cmake_build.md#vcpkg_cmake_build) (from port [`vcpkg-cmake`](ports/vcpkg-cmake.md#vcpkg-cmake))\r\n7. `vcpkg_install_cmake` should be replaced by [`vcpkg_cmake_install()`](ports/vcpkg-cmake/vcpkg_cmake_install.md#vcpkg_cmake_install) (from port [`vcpkg-cmake`](ports/vcpkg-cmake.md#vcpkg-cmake))\r\n8. `vcpkg_fixup_cmake_targets` should be replaced by [`vcpkg_cmake_config_fixup`](ports/vcpkg-cmake-config/vcpkg_cmake_config_fixup.md#vcpkg_cmake_config_fixup) (from port [`vcpkg-cmake-config`](ports/vcpkg-cmake-config.md#vcpkg-cmake-config))\r\n\r\nSome of the replacement helper functions are in \"tools ports\" to allow consumers to pin their\r\nbehavior at specific versions, to allow locking the behavior of the helpers at a particular\r\nversion. Tools ports need to be added to your port's `\"dependencies\"`, like so:\r\n\r\n```json\r\n{\r\n  \"name\": \"vcpkg-cmake\",\r\n  \"host\": true\r\n},\r\n{\r\n  \"name\": \"vcpkg-cmake-config\",\r\n  \"host\": true\r\n}\r\n```\r\n\r\n### Avoid excessive comments in portfiles\r\n\r\nIdeally, portfiles should be short, simple, and as declarative as possible.\r\nRemove any boiler plate comments introduced by the `create` command before submitting a PR.\r\n\r\n### Ports must not be path dependent\r\n\r\nPorts must not change their behavior based on which ports are already installed in a form that would change which contents that port installs. For example, given:\r\n\r\n```\r\n> vcpkg install a\r\n> vcpkg install b\r\n> vcpkg remove a\r\n```\r\n\r\nand\r\n\r\n```\r\n> vcpkg install b\r\n```\r\n\r\nthe files installed by `b` must be the same, regardless of influence by the previous installation of `a`. This means that ports must not try to detect whether something is provided in the installed tree by another port before taking some action. A specific and common cause of such \"path dependent\" behavior is described below in \"When defining features, explicitly control dependencies.\"\r\n\r\n### Unique port attribution rule\r\n\r\nIn the entire vcpkg system, no two ports a user is expected to use concurrently may provide the same file. If a port tries to install a file already provided by another file, installation will fail. If a port wants to use an extremely common name for a header, for example, it should place those headers in a subdirectory rather than in `include`.\r\n\r\n### Add CMake exports in an unofficial- namespace\r\n\r\nA core design ideal of vcpkg is to not create \"lock-in\" for customers. In the build system, there should be no difference between depending on a library from the system, and depending on a library from vcpkg. To that end, we avoid adding CMake exports or targets to existing libraries with \"the obvious name\", to allow upstreams to add their own official CMake exports without conflicting with vcpkg.\r\n\r\nTo that end, any CMake configs that the port exports, which are not in the upstream library, should have `unofficial-` as a prefix. Any additional targets should be in the `unofficial::<port>::` namespace.\r\n\r\nThis means that the user should see:\r\n * `find_package(unofficial-<port> CONFIG)` as the way to get at the unique-to-vcpkg package\r\n * `unofficial::<port>::<target>` as an exported target from that port.\r\n\r\nExamples:\r\n * [`brotli`](https://github.com/microsoft/vcpkg/blob/4f0a640e4c5b74166b759a862d7527c930eff32e/ports/brotli/install.patch) creates the `unofficial-brotli` package, producing target `unofficial::brotli::brotli`.\r\n\r\n## Features\r\n\r\n### Do not use features to implement alternatives\r\n\r\nFeatures must be treated as additive functionality. If port[featureA] installs and port[featureB] installs, then port[featureA,featureB] must install. Moreover, if a second port depends on [featureA] and a third port depends on [featureB], installing both the second and third ports should have their dependencies satisfied.\r\n\r\nLibraries in this situation must choose one of the available options as expressed in vcpkg, and users who want a different setting must use overlay ports at this time.\r\n\r\nExisting examples we would not accept today retained for backwards compatibility:\r\n  * `libgit2`, `libzip`, `open62541` all have features for selecting a TLS or crypto backend. Note that `curl` has different crypto backend options but allows selecting between them at runtime, meaning the above tenet is maintained.\r\n  * `darknet` has `opencv2`, `opencv3`, features to control which version of opencv to use for its dependencies.\r\n\r\n### A feature may engage preview or beta functionality\r\n\r\nNotwithstanding the above, if there is a preview branch or similar where the preview functionality has a high probability of not disrupting the non-preview functionality (for example, no API removals), a feature is acceptable to model this setting.\r\n\r\nExamples:\r\n  * The Azure SDKs (of the form `azure-Xxx`) have a `public-preview` feature.\r\n  * `imgui` has an `experimental-docking` feature which engages their preview docking branch which uses a merge commit attached to each of their public numbered releases.\r\n\r\n### Default features should enable behaviors, not APIs\r\n\r\nIf a consumer is depending directly upon a library, they can list out any desired features easily (`library[feature1,feature2]`). However, if a consumer _does not know_ they are using a library, they cannot list out those features. If that hidden library is like `libarchive` where features are adding additional compression algorithms (and thus behaviors) to an existing generic interface, default features offer a way to ensure a reasonably functional transitive library is built even if the final consumer doesn't name it directly.\r\n\r\nIf the feature adds additional APIs (or executables, or library binaries) and doesn't modify the behavior of existing APIs, it should be left off by default. This is because any consumer which might want to use those APIs can easily require it via their direct reference.\r\n\r\nIf in doubt, do not mark a feature as default.\r\n\r\n### Do not use features to control alternatives in published interfaces\r\n\r\nIf a consumer of a port depends on only the core functionality of that port, with high probability they must not be broken by turning on the feature. This is even more important when the alternative is not directly controlled by the consumer, but by compiler settings like `/std:c++17` / `-std=c++17`.\r\n\r\nExisting examples we would not accept today retained for backwards compatibility:\r\n  * `redis-plus-plus[cxx17]` controls a polyfill but does not bake the setting into the installed tree.\r\n  * `ace[wchar]` changes all APIs to accept `const wchar_t*` rather than `const char*`.\r\n\r\n### A feature may replace polyfills with aliases provided that replacement is baked into the installed tree\r\n\r\nNotwithstanding the above, ports may remove polyfills with a feature, as long as:\r\n  1. Turning on the feature changes the polyfills to aliases of the polyfilled entity\r\n  2. The state of the polyfill is baked into the installed headers, such that ABI mismatch \"impossible\" runtime errors are unlikely\r\n  3. It is possible for a consumer of the port to write code which works in both modes, for example by using a typedef which is either polyfilled or not\r\n\r\nExample:\r\n  * `abseil[cxx17]` changes `absl::string_view` to a replacement or `std::string_view`; the patch\r\nhttps://github.com/microsoft/vcpkg/blob/981e65ce0ac1f6c86e5a5ded7824db8780173c76/ports/abseil/fix-cxx-standard.patch implements the baking requirement\r\n\r\n### Recommended solutions\r\n\r\nIf it's critical to expose the underlying alternatives, we recommend providing messages at build time to instruct the user on how to copy the port into a private overlay:\r\n```cmake\r\nset(USING_DOG 0)\r\nmessage(STATUS \"This version of LibContosoFrobnicate uses the Kittens backend. To use the Dog backend instead, create an overlay port of this with USING_DOG set to 1 and the `kittens` dependency replaced with `dog`.\")\r\nmessage(STATUS \"This recipe is at ${CMAKE_CURRENT_LIST_DIR}\")\r\nmessage(STATUS \"See the overlay ports documentation at https://github.com/microsoft/vcpkg/blob/master/docs/specifications/ports-overlay.md\")\r\n```\r\n\r\n## Build Techniques\r\n\r\n### Do not use vendored dependencies\r\n\r\nDo not use embedded copies of libraries.\r\nAll dependencies should be split out and packaged separately so they can be updated and maintained.\r\n\r\n### Prefer using CMake\r\n\r\nWhen multiple buildsystems are available, prefer using CMake.\r\nAdditionally, when appropriate, it can be easier and more maintainable to rewrite alternative buildsystems into CMake using `file(GLOB)` directives.\r\n\r\nExamples: [abseil](../../ports/abseil/portfile.cmake)\r\n\r\n### Choose either static or shared binaries\r\n\r\nBy default, `vcpkg_cmake_configure()` will pass in the appropriate setting for `BUILD_SHARED_LIBS`,\r\nhowever for libraries that don't respect that variable, you can switch on `VCPKG_LIBRARY_LINKAGE`:\r\n\r\n```cmake\r\nstring(COMPARE EQUAL \"${VCPKG_LIBRARY_LINKAGE}\" \"static\" KEYSTONE_BUILD_STATIC)\r\nstring(COMPARE EQUAL \"${VCPKG_LIBRARY_LINKAGE}\" \"dynamic\" KEYSTONE_BUILD_SHARED)\r\n\r\nvcpkg_cmake_configure(\r\n    SOURCE_PATH ${SOURCE_PATH}\r\n    OPTIONS\r\n        -DKEYSTONE_BUILD_STATIC=${KEYSTONE_BUILD_STATIC}\r\n        -DKEYSTONE_BUILD_SHARED=${KEYSTONE_BUILD_SHARED}\r\n)\r\n```\r\n\r\n### When defining features, explicitly control dependencies\r\n\r\nWhen defining a feature that captures an optional dependency,\r\nensure that the dependency will not be used accidentally when the feature is not explicitly enabled.\r\n\r\n```cmake\r\nset(CMAKE_DISABLE_FIND_PACKAGE_ZLIB ON)\r\nset(CMAKE_REQUIRE_FIND_PACKAGE_ZLIB OFF)\r\nif (\"zlib\" IN_LIST FEATURES)\r\n  set(CMAKE_DISABLE_FIND_PACKAGE_ZLIB OFF)\r\n  set(CMAKE_REQUIRE_FIND_PACKAGE_ZLIB ON)\r\nendif()\r\n\r\nvcpkg_cmake_configure(\r\n  SOURCE_PATH ${SOURCE_PATH}\r\n  OPTIONS\r\n    -DCMAKE_DISABLE_FIND_PACKAGE_ZLIB=${CMAKE_DISABLE_FIND_PACKAGE_ZLIB}\r\n    -DCMAKE_REQUIRE_FIND_PACKAGE_ZLIB=${CMAKE_REQUIRE_FIND_PACKAGE_ZLIB}\r\n)\r\n```\r\n\r\nThe snippet below using `vcpkg_check_features()` is equivalent,  [see the documentation](vcpkg_check_features.md).\r\n\r\n```cmake\r\nvcpkg_check_features(OUT_FEATURE_OPTIONS FEATURE_OPTIONS\r\n  FEATURES\r\n    \"zlib\"    CMAKE_REQUIRE_FIND_PACKAGE_ZLIB\r\n  INVERTED_FEATURES\r\n    \"zlib\"    CMAKE_DISABLE_FIND_PACKAGE_ZLIB\r\n)\r\n\r\nvcpkg_cmake_configure(\r\n    SOURCE_PATH ${SOURCE_PATH}\r\n    OPTIONS\r\n      ${FEATURE_OPTIONS}\r\n)\r\n```\r\n\r\nNote that `ZLIB` in the above is case-sensitive. See the [CMAKE_DISABLE_FIND_PACKAGE_PackageName](https://cmake.org/cmake/help/v3.22/variable/CMAKE_DISABLE_FIND_PACKAGE_PackageName.html) and [CMAKE_REQUIRE_FIND_PACKAGE_PackageName](https://cmake.org/cmake/help/v3.22/variable/CMAKE_REQUIRE_FIND_PACKAGE_PackageName.html) documnetation for more details.\r\n\r\n### Place conflicting libs in a `manual-link` directory\r\n\r\nA lib is considered conflicting if it does any of the following:\r\n+ Define `main`\r\n+ Define malloc\r\n+ Define symbols that are also declared in other libraries\r\n\r\nConflicting libs are typically by design and not considered a defect.  Because some build systems link against everything in the lib directory, these should be moved into a subdirectory named `manual-link`.\r\n\r\n## Manifests and CONTROL files\r\n\r\nWhen adding a new port, use the new manifest syntax for defining a port;\r\nyou may also change over to manifests when modifying an existing port.\r\nYou may do so easily by running the `vcpkg format-manifest` command, which will convert existing CONTROL\r\nfiles into manifest files. Do not convert CONTROL files that have not been modified.\r\n\r\n## Versioning\r\n\r\n### Follow common conventions for the `\"version\"` field\r\n\r\nSee our [versioning documentation](../users/versioning.md#version-schemes) for a full explanation of our conventions.\r\n\r\n### Update the `\"port-version\"` field in the manifest file of any modified ports\r\n\r\nVcpkg uses this field to determine whether a given port is out-of-date and should be changed whenever the port's behavior changes.\r\n\r\nOur convention is to use the `\"port-version\"` field for changes to the port that don't change the upstream version, and to reset the `\"port-version\"` back to zero when an update to the upstream version is made.\r\n\r\nFor Example:\r\n\r\n- Zlib's package version is currently `1.2.1`, with no explicit `\"port-version\"` (equivalent to a `\"port-version\"` of `0`).\r\n- You've discovered that the wrong copyright file has been deployed, and fixed that in the portfile.\r\n- You should update the `\"port-version\"` field in the manifest file to `1`.\r\n\r\nSee our [manifest files document](manifest-files.md#port-version) for a full explanation of our conventions.\r\n\r\n### Update the version files in `versions/` of any modified ports\r\n\r\nVcpkg uses a set of metadata files to power its versioning feature.\r\nThese files are located in the following locations:\r\n* `${VCPKG_ROOT}/versions/baseline.json`, (this file is common to all ports) and\r\n* `${VCPKG_ROOT}/versions/${first-letter-of-portname}-/${portname}.json` (one per port).\r\n\r\nFor example, for `zlib` the relevant files are:\r\n* `${VCPKG_ROOT}/versions/baseline.json`\r\n* `${VCPKG_ROOT}/versions/z-/zlib.json`\r\n\r\nWe expect that each time you update a port, you also update its version files.\r\n\r\n**The recommended method to update these files is to run the `x-add-version` command, e.g.:**\r\n\r\n```\r\nvcpkg x-add-version zlib\r\n```\r\n\r\nIf you're updating multiple ports at the same time, instead you can run:\r\n\r\n```\r\nvcpkg x-add-version --all\r\n```\r\n\r\nTo update the files for all modified ports at once.\r\n\r\n_NOTE: These commands require you to have committed your changes to the ports before running them. The reason is that the Git SHA of the port directory is required in these version files. But don't worry, the `x-add-version` command will warn you if you have local changes that haven't been committed._\r\n\r\nSee our [versioning specification](../specifications/versioning.md) and [registries specification](../specifications/registries-2.md) to learn how vcpkg interacts with these files.\r\n\r\n## Patching\r\n\r\n### Prefer options over patching\r\n\r\nIt is preferable to set options in a call to `vcpkg_configure_xyz()` over patching the settings directly.\r\n\r\nCommon options that allow avoiding patching:\r\n1. [MSBUILD] `<PropertyGroup>` settings inside the project file can be overridden via `/p:` parameters\r\n2. [CMAKE] Calls to `find_package(XYz)` in CMake scripts can be disabled via [`-DCMAKE_DISABLE_FIND_PACKAGE_XYz=ON`](https://cmake.org/cmake/help/v3.15/variable/CMAKE_DISABLE_FIND_PACKAGE_PackageName.html)\r\n3. [CMAKE] Cache variables (declared as `set(VAR \"value\" CACHE STRING \"Documentation\")` or `option(VAR \"Documentation\" \"Default Value\")`) can be overridden by just passing them in on the command line as `-DVAR:STRING=Foo`. One notable exception is if the `FORCE` parameter is passed to `set()`. See also the [CMake `set` documentation](https://cmake.org/cmake/help/v3.15/command/set.html)\r\n\r\n### Prefer patching over overriding `VCPKG_<VARIABLE>` values\r\n\r\nSome variables prefixed with `VCPKG_<VARIABLE>` have an equivalent `CMAKE_<VARIABLE>`.\r\nHowever, not all of them are passed to the internal package build [(see implementation: Windows toolchain)](../../scripts/toolchains/windows.cmake).\r\n\r\nConsider the following example:\r\n\r\n```cmake\r\nset(VCPKG_C_FLAGS \"-O2 ${VCPKG_C_FLAGS}\")\r\nset(VCPKG_CXX_FLAGS \"-O2 ${VCPKG_CXX_FLAGS}\")\r\n```\r\n\r\nUsing `vcpkg`'s built-in toolchains this works, because the value of `VCPKG_<LANG>_FLAGS` is forwarded to the appropriate `CMAKE_LANG_FLAGS` variable. But, a custom toolchain that is not aware of `vcpkg`'s variables will not forward them.\r\n\r\nBecause of this, it is preferable to patch the buildsystem directly when setting `CMAKE_<LANG>_FLAGS`.\r\n\r\n### Minimize patches\r\n\r\nWhen making changes to a library, strive to minimize the final diff. This means you should _not_ reformat the upstream source code when making changes that affect a region. Also, when disabling a conditional, it is better to add a `AND FALSE` or `&& 0` to the condition than to delete every line of the conditional.\r\n\r\nDon't add patches if the port is outdated and updating the port to a newer released version would solve the same issue. vcpkg prefers updating ports over patching outdated versions unless the version bump breaks a considerable amount of dependent ports.\r\n\r\nThis helps to keep the size of the vcpkg repository down as well as improves the likelihood that the patch will apply to future code versions.\r\n\r\n### Do not implement features in patches\r\n\r\nThe purpose of patching in vcpkg is to enable compatibility with compilers, libraries, and platforms. It is not to implement new features in lieu of following proper Open Source procedure (submitting an Issue/PR/etc).\r\n\r\n## Do not build tests/docs/examples by default\r\n\r\nWhen submitting a new port, check for any options like `BUILD_TESTS` or `WITH_TESTS` or `POCO_ENABLE_SAMPLES` and ensure the additional binaries are disabled. This minimizes build times and dependencies for the average user.\r\n\r\nOptionally, you can add a `test` feature which enables building the tests, however this should not be in the `Default-Features` list.\r\n\r\n## Enable existing users of the library to switch to vcpkg\r\n\r\n### Do not add `CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS`\r\n\r\nUnless the author of the library is already using it, we should not use this CMake functionality because it interacts poorly with C++ templates and breaks certain compiler features. Libraries that don't provide a .def file and do not use __declspec() declarations simply do not support shared builds for Windows and should be marked as such with `vcpkg_check_linkage(ONLY_STATIC_LIBRARY)`.\r\n\r\n### Do not rename binaries outside the names given by upstream\r\n\r\nThis means that if the upstream library has different names in release and debug (libx versus libxd), then the debug library should not be renamed to `libx`. Vice versa, if the upstream library has the same name in release and debug, we should not introduce a new name.\r\n\r\nImportant caveat:\r\n- Static and shared variants often should be renamed to a common scheme. This enables consumers to use a common name and be ignorant of the downstream linkage. This is safe because we only make one at a time available.\r\n\r\nNote that if a library generates CMake integration files (`foo-config.cmake`), renaming must be done through patching the CMake build itself instead of simply calling `file(RENAME)` on the output archives/LIBs.\r\n\r\nFinally, DLL files on Windows should never be renamed post-build because it breaks the generated LIBs.\r\n\r\n## Code format\r\n\r\n### Vcpkg internal code\r\n\r\nWe require the C++ code inside vcpkg to follow the clang-format, if you change them. Please perform the following steps after modification:\r\n\r\n- Use Visual Studio:\r\n1. Configure your [clang-format tools](https://devblogs.microsoft.com/cppblog/clangformat-support-in-visual-studio-2017-15-7-preview-1/).\r\n2. Open the modified file.\r\n3. Use shortcut keys Ctrl+K, Ctrl+D to format the current file.\r\n\r\n- Use tools:\r\n1. Install [llvm clang-format](https://releases.llvm.org/download.html#10.0.0)\r\n2. Run command:\r\n```cmd\r\n> LLVM_PATH/bin/clang-format.exe -style=file -i changed_file.cpp\r\n```\r\n\r\n### Manifests\r\n\r\nWe require that the manifest file be formatted. Use the following command to format all manifest files:\r\n\r\n```cmd\r\n> vcpkg format-manifest --all\r\n```\r\n\r\n## Useful implementation notes\r\n\r\n### Portfiles are run in Script Mode\r\n\r\nWhile `portfile.cmake`'s and `CMakeLists.txt`'s share a common syntax and core CMake language constructs, portfiles run in \"Script Mode\", whereas `CMakeLists.txt` files run in \"Build Mode\" (unofficial term). The most important difference between these two modes is that \"Script Mode\" does not have a concept of \"Target\" -- any behaviors that depend on the \"target\" machine (`CMAKE_CXX_COMPILER`, `CMAKE_EXECUTABLE_SUFFIX`, `CMAKE_SYSTEM_NAME`, etc) will not be correct.\r\n\r\nPortfiles have direct access to variables set in the triplet file, but `CMakeLists.txt`s do not (though there is often a translation that happens -- `VCPKG_LIBRARY_LINKAGE` versus `BUILD_SHARED_LIBS`).\r\n\r\nPortfiles and CMake builds invoked by portfiles are run in different processes. Conceptually:\r\n\r\n```no-highlight\r\n+----------------------------+       +------------------------------------+\r\n| CMake.exe                  |       | CMake.exe                          |\r\n+----------------------------+       +------------------------------------+\r\n| Triplet file               | ====> | Toolchain file                     |\r\n| (x64-windows.cmake)        |       | (scripts/buildsystems/vcpkg.cmake) |\r\n+----------------------------+       +------------------------------------+\r\n| Portfile                   | ====> | CMakeLists.txt                     |\r\n| (ports/foo/portfile.cmake) |       | (buildtrees/../CMakeLists.txt)     |\r\n+----------------------------+       +------------------------------------+\r\n```\r\n\r\nTo determine the host in a portfile, the standard CMake variables are fine (`CMAKE_HOST_WIN32`).\r\n\r\nTo determine the target in a portfile, the vcpkg triplet variables should be used (`VCPKG_CMAKE_SYSTEM_NAME`).\r\n\r\nSee also our [triplet documentation](../users/triplets.md) for a full enumeration of possible settings.\r\n","Nav":"#"},{"Path":"/en/docs/maintainers/manifest-files.html","Name":"Manifest-files","Source":"# Manifest files - `vcpkg.json`\n\nThe `vcpkg.json` file contains metadata about the port.\nIt's a JSON file, and replaces the existing CONTROL file metadata structure.\nIt must have a top level object, and all fields are case sensitive.\n\n## Examples:\n\nThe most important fields in a manifest, the ones which are required for all ports,\nare the `\"name\"` field, and a version field (for now, just `\"version-string\"`).\nThere's more information about these fields below.\n\n```json\n{\n  \"name\": \"ace\",\n  \"version-string\": \"6.5.5\"\n}\n```\n\n```json\n{\n  \"name\": \"vtk\",\n  \"version-string\": \"8.2.0\",\n  \"port-version\": 2,\n  \"description\": \"Software system for 3D computer graphics, image processing, and visualization\",\n  \"dependencies\": [\n    {\n      \"name\": \"atlmfc\",\n      \"platform\": \"windows\"\n    },\n    \"double-conversion\",\n    \"eigen3\",\n    \"expat\",\n    \"freetype\",\n    \"glew\",\n    \"hdf5\",\n    \"jsoncpp\",\n    \"libharu\",\n    \"libjpeg-turbo\",\n    \"libpng\",\n    \"libtheora\",\n    \"libxml2\",\n    \"lz4\",\n    \"netcdf-c\",\n    \"proj4\",\n    \"pugixml\",\n    \"sqlite3\",\n    \"tiff\",\n    \"zlib\"\n  ]\n}\n```\n\n## Fields\n\n### `\"name\"`\nThe name of the port.\n\nWhen adding new ports be aware that the name may conflict with other projects that are not a part of vcpkg.  For example `json` conflicts with too many other projects so you should add a scope to the name such as `taocpp-json` to make it unique.  Verify there are no conflicts on a search engine as well as on other package collections.\n\nPackage collections to check for conflicts:\n\n+ [Repology](https://repology.org/projects/)\n+ [Debian packages](https://www.debian.org/distrib/packages)\n+ [Packages search](https://pkgs.org/)\n\nA name must be an identifier: i.e., it must only consist of lowercase ascii alphabetic characters,\nnumbers, and hyphens, and it must not begin nor end with a hyphen.\n\n### Version fields\n\nCurrently there are different fields for special versioning. Namely:\n\nManifest property | Versioning scheme\n------------------|------------------------------------\n`version`         | For dot-separated numeric versions\n`version-semver`  | For SemVer compliant versions\n`version-date`    | For dates in the format YYYY-MM-DD\n`version-string`  | For arbitrary strings\n\nSee https://github.com/microsoft/vcpkg/blob/master/docs/specifications/versioning.md#22-package-versions for more details.\n\nAdditionally, `\"port-version\"` is used to differentiate between port changes that don't change the underlying library version.\n\n#### `\"version-string\"`\n\nThis field is an ascii string, and may contain alphanumeric characters, `.`, `_`, or `-`. No attempt at ordering versions is made; all versions are treated as byte strings and are only evaluated for equality.\n\nFor tagged-release ports, we follow the following convention:\n\n1. If the library follows a scheme like `va.b.c`, we remove the leading `v`. In this case, it becomes `a.b.c`.\n2. If the library includes its own name in the version like `curl-7_65_1`, we remove the leading name: `7_65_1`\n3. If the library is versioned by dates, format the resulting version string just like the upstream library;\n   for example, Abseil formats their dates `lts_2020_02_25`, so the `\"version-string\"` should be `\"lts_2020_02_25\"`.\n\nFor rolling-release ports, we use the date that the _commit was accessed by you_, formatted as `YYYY-MM-DD`. Stated another way: if someone had a time machine and went to that date, they would see this commit as the latest master.\n\nFor example, given:\n1. The latest commit was made on 2019-04-19\n2. The current version string is `2019-02-14`\n3. Today's date is 2019-06-01.\n\nThen if you update the source version today, you should give it version `2019-06-01`.\n\n#### `\"port-version\"`\n\nThe version of the port, aside from the library version.\n\nThis field is a non-negative integer.\nIt allows one to version the port file separately from the version of the underlying library;\nif you make a change to a port, without changing the underlying version of the library,\nyou should increment this field by one (starting at `0`, which is equivalent to no `\"port-version\"` field).\nWhen the version of the underlying library is upgraded,\nthis field should be set back to `0` (i.e., delete the `\"port-version\"` field).\n\n#### Examples:\n```json\n{\n  \"version\": \"1.0.5\",\n  \"port-version\": 2\n}\n```\n\n```json\n{\n  \"version\": \"2019-03-21\"\n}\n```\n\n### `\"description\"`\n\nA description of the library.\n\nThis field can either be a single string, which should be a summary of the library,\nor can be an array, with the first line being a summary and the remaining lines being the detailed description -\none string per line.\n\n#### Examples:\n```json\n{\n  \"description\": \"C++ header-only JSON library\"\n}\n```\n```json\n{\n  \"description\": [\n    \"Mosquitto is an open source message broker that implements the MQ Telemetry Transport protocol versions 3.1 and 3.1.1.\",\n    \"MQTT provides a lightweight method of carrying out messaging using a publish/subscribe model.\"\n    \"This makes it suitable for 'machine to machine' messaging such as with low power sensors or mobile devices such as phones, embedded computers or microcontrollers like the Arduino.\"\n  ]\n}\n```\n\n### `\"homepage\"`\n\nThe URL of the homepage for the library where a user is able to find additional documentation or the original source code.\n\n### `\"documentation\"`\n\nThe URL where a user would be able to find official documentation for the library. Optional.\n\n### `\"maintainers\"`\n\nA list of strings that define the set of maintainers of a package.\nIt's recommended that these take the form of `Givenname Surname <email>`,\nbut this field is not checked for consistency.\n\nOptional.\n\n#### Example:\n```json\n{\n  \"homepage\": \"https://github.com/microsoft/vcpkg\"\n}\n```\n\n### `\"dependencies\"`\n\nAn array of ports the library has a dependency on.\n\nvcpkg does not distinguish between build-only dependencies and runtime dependencies.\nThe complete list of dependencies needed to successfully use the library should be specified.\n\nFor example: websocketpp is a header only library, and thus does not require any dependencies at install time.\nHowever, downstream users need boost and openssl to make use of the library.\nTherefore, websocketpp lists boost and openssl as dependencies.\n\nEach dependency may be either an identifier, or an object.\nFor many dependencies, just listing the name of the library should be fine;\nhowever, if one needs to add extra information to that dependency, one may use the dependency object.\nFor a dependency object, the `\"name\"` field is used to designate the library;\nfor example the dependency object `{ \"name\": \"zlib\" }` is equivalent to just writing `\"zlib\"`.\n\nIf the port is dependent on optional features of another library,\nthose can be specified using the `\"features\"` field of the dependency object.\nIf the port does not require any features from the dependency,\nthis should be specified with the `\"default-features\"` fields set to `false`.\n\nDependencies can also be filtered based on the target triplet to support differing requirements.\nThese filters use the same syntax as the `\"supports\"` field below,\nand are specified in the `\"platform\"` field.\n\n#### Example:\n```json\n{\n  \"dependencies\": [\n    {\n      \"name\": \"curl\",\n      \"default-features\": false,\n      \"features\": [\n        \"winssl\"\n      ],\n      \"platform\": \"windows\"\n    },\n    {\n      \"name\": \"curl\",\n      \"default-features\": false,\n      \"features\": [\n        \"openssl\"\n      ],\n      \"platform\": \"!windows\"\n    },\n    \"rapidjson\"\n  ]\n}\n```\n\n### `\"features\"`\n\nMultiple optional features can be specified in manifest files, in the `\"features\"` object field.\nThis field is a map from the feature name, to the feature's information.\nEach one must have a `\"description\"` field, and may also optionally have a `\"dependencies\"` field.\n\nA feature's name must be an identifier -\nin other words, lowercase alphabetic characters, digits, and hyphens,\nneither starting nor ending with a hyphen.\n\nA feature's `\"description\"` is a description of the feature,\nand is the same kind of thing as the port `\"description\"` field.\n\nA feature's `\"dependencies\"` field contains the list of extra dependencies required to build and use this feature;\nthis field isn't required if the feature doesn't require any extra dependencies.\nOn installation the dependencies from all selected features are combined to produce the full dependency list for the build.\n\n#### Example:\n\n```json\n{\n  \"name\": \"vtk\",\n  \"version-string\": \"8.2.0\",\n  \"port-version\": 2,\n  \"description\": \"Software system for 3D computer graphics, image processing, and visualization\",\n  \"dependencies\": [\n    {\n      \"name\": \"atlmfc\",\n      \"platform\": \"windows\"\n    },\n    \"double-conversion\",\n    \"eigen3\",\n    \"expat\",\n    \"freetype\",\n    \"glew\",\n    \"hdf5\",\n    \"jsoncpp\",\n    \"libharu\",\n    \"libjpeg-turbo\",\n    \"libpng\",\n    \"libtheora\",\n    \"libxml2\",\n    \"lz4\",\n    \"netcdf-c\",\n    \"proj4\",\n    \"pugixml\",\n    \"sqlite3\",\n    \"tiff\",\n    \"zlib\"\n  ],\n  \"features\": {\n    \"mpi\": {\n      \"description\": \"MPI functionality for VTK\",\n      \"dependencies\": [\n        {\n          \"name\": \"hdf5\",\n          \"features\": [\n            \"parallel\"\n          ]\n        },\n        \"mpi\"\n      ]\n    },\n    \"openvr\": {\n      \"description\": \"OpenVR functionality for VTK\",\n      \"dependencies\": [\n        \"openvr\",\n        \"sdl2\"\n      ]\n    },\n    \"python\": {\n      \"description\": \"Python functionality for VTK\",\n      \"dependencies\": [\n        \"python3\"\n      ]\n    },\n    \"qt\": {\n      \"description\": \"Qt functionality for VTK\",\n      \"dependencies\": [\n        \"qt5\"\n      ]\n    }\n  }\n}\n```\n\n### `\"default-features\"`\n\nAn array of feature names that the library uses by default, if nothing else is specified.\n\n#### Example:\n```json\n{\n  \"default-features\": [\n    \"kinesis\"\n  ],\n  \"features\": {\n    \"dynamodb\": {\n      \"description\": \"Build dynamodb support\",\n      \"dependencies\": [\n        \"dynamodb\"\n      ]\n    },\n    \"kinesis\": {\n      \"description\": \"build kinesis support\"\n    }\n  }\n}\n```\n\n### `\"supports\"`\n\nA string, formatted as a platform expression,\nthat evaluates to true when the port should build successfully for a triplet.\n\nThis field is used in the CI testing to skip ports,\nand warns users in advance that a given install tree is not expected to succeed.\nTherefore, this field should be used optimistically;\nin cases where a port is expected to succeed 10% of the time, it should still be marked \"supported\".\n\nThe grammar for this top-level platform expression, in [EBNF], is as follows:\n\n```ebnf\nwhitespace-character =\n| ? U+0009 \"CHARACTER TABULATION\" ?\n| ? U+000A \"LINE FEED\" ?\n| ? U+000D \"CARRIAGE RETURN\" ?\n| ? U+0020 \"SPACE\" ? ;\noptional-whitespace = { whitespace-character } ;\nrequired-whitespace = whitespace-character, { optional-whitespace } ;\n\nlowercase-alpha =\n| \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"h\" | \"i\" | \"j\" | \"k\" | \"l\" | \"m\"\n| \"n\" | \"o\" | \"p\" | \"q\" | \"r\" | \"s\" | \"t\" | \"u\" | \"v\" | \"w\" | \"x\" | \"y\" | \"z\" ;\ndigit =\n| \"0\" | \"1\" | \"2\" | \"3\" | \"4\"\n| \"5\" | \"6\" | \"7\" | \"8\" | \"9\" ;\nidentifier-character =\n| lowercase-alpha\n| digit ;\n\nplatform-expression-list =\n| platform-expression { \",\", optional-whitespace, platform-expression } ;\n\nplatform-expression =\n| platform-expression-not\n| platform-expression-and\n| platform-expression-or ;\n\nplatform-expression-identifier =\n| identifier-character, { identifier-character }, optional-whitespace ;\n\nplatform-expression-grouped =\n| \"(\", optional-whitespace, platform-expression, \")\", optional-whitespace ;\n\nplatform-expression-simple =\n| platform-expression-identifier\n| platform-expression-grouped ;\n\nplatform-expression-unary-keyword-operand =\n| required-whitespace, platform-expression-simple\n| optional-whitespace, platform-expression-grouped ;\n\nplatform-expression-not =\n| platform-expression-simple\n| \"!\", optional-whitespace, platform-expression-simple\n| \"not\", platform-expression-unary-keyword-operand ;\n\nplatform-expression-binary-keyword-first-operand =\n| platform-expression-not, required-whitespace\n| platform-expression-grouped ;\n\nplatform-expression-binary-keyword-second-operand =\n| required-whitespace, platform-expression-not\n| platform-expression-grouped ;\n\nplatform-expression-and =\n| platform-expression-not, { \"&\", optional-whitespace, platform-expression-not }\n| platform-expression-binary-keyword-first-operand, { \"and\", platform-expression-binary-keyword-second-operand } ;\n\nplatform-expression-or =\n| platform-expression-not, { \"|\", optional-whitespace, platform-expression-not }\n| platform-expression-binary-keyword-first-operand, { \"or\", platform-expression-binary-keyword-second-operand } (* to allow for future extension *) ;\n\ntop-level-platform-expression = optional-whitespace, platform-expression-list ;\n```\n\nBasically, there are four kinds of expressions -- identifiers, negations, ands, and ors.\nNegations may only negate an identifier or a grouped expression.\nAnds and ors are a list of `&` or `|` separated identifiers, negated expressions, and grouped expressions.\nOne may not mix `&` and `|` without parentheses for grouping.\n\nThese predefined identifier expressions are computed from standard triplet settings:\n- `native` - `TARGET_TRIPLET` == `HOST_TRIPLET`;\n  useful for ports which depend on their own built binaries in their build.\n- `x64` - `VCPKG_TARGET_ARCHITECTURE` == `\"x64\"`\n- `x86` - `VCPKG_TARGET_ARCHITECTURE` == `\"x86\"`\n- `arm` - `VCPKG_TARGET_ARCHITECTURE` == `\"arm\"` or `VCPKG_TARGET_ARCHITECTURE` == `\"arm64\"`\n- `arm64` - `VCPKG_TARGET_ARCHITECTURE` == `\"arm64\"`\n- `windows` - `VCPKG_CMAKE_SYSTEM_NAME` == `\"\"` or `VCPKG_CMAKE_SYSTEM_NAME` == `\"WindowsStore\"`\n- `mingw` - `VCPKG_CMAKE_SYSTEM_NAME` == `\"MinGW\"`\n- `uwp` - `VCPKG_CMAKE_SYSTEM_NAME` == `\"WindowsStore\"`\n- `linux` - `VCPKG_CMAKE_SYSTEM_NAME` == `\"Linux\"`\n- `osx` - `VCPKG_CMAKE_SYSTEM_NAME` == `\"Darwin\"`\n- `android` - `VCPKG_CMAKE_SYSTEM_NAME` == `\"Android\"`\n- `static` - `VCPKG_LIBRARY_LINKAGE` == `\"static\"`\n- `wasm32` - `VCPKG_TARGET_ARCHITECTURE` == `\"wasm32\"`\n- `emscripten` - `VCPKG_CMAKE_SYSTEM_NAME` == `\"Emscripten\"`\n- `staticcrt` - `VCPKG_CRT_LINKAGE` == `\"static\"`\n\nThese predefined identifier expressions can be overridden in the triplet file,\nvia the [`VCPKG_DEP_INFO_OVERRIDE_VARS`](../users/triplets.md) option,\nand new identifier expressions can be added via the same mechanism.\n\nThis field is optional and defaults to true.\n\n> Implementers' Note: these terms are computed from the triplet via the `vcpkg_get_dep_info` mechanism.\n\n[EBNF]: https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form\n\n#### Example:\n```json\n{\n  \"supports\": \"!uwp & !(arm & !arm64)\"\n}\n```\n\nThis means \"doesn't support uwp, nor arm32 (but does support arm64)\".\n\n### `\"license\"`\n\nThe license of the port. This is an [SPDX license expression],\nor `null` for proprietary licenses and other licenses for which\none should \"just read the `copyright` file\" (e.g., Qt).\n\n[SPDX license expression]: https://spdx.dev/ids/#how\n\nAdditionally, you can find the list of [recognized license IDs]\nand [recognized license exception IDs] in Annex A of the SPDX specification.\n\n[recognized license IDs]: https://spdx.github.io/spdx-spec/SPDX-license-list/#a1-licenses-with-short-identifiers\n[recognized license exception IDs]: https://spdx.github.io/spdx-spec/SPDX-license-list/#a2-exceptions-list\n\nThe following is an EBNF conversion of the ABNF located at\n<https://spdx.github.io/spdx-spec/SPDX-license-expressions/>,\nand this is what we actually parse in vcpkg.\nNote that vcpkg does not support DocumentRefs.\n\n```ebnf\nidchar = ? regex /[-.a-zA-Z0-9]/ ?\nidstring = ( idchar ), { idchar } ;\n\n(* note that unrecognized license and license exception IDs will be warned against *)\nlicense-id = idstring ;\nlicense-exception-id = idstring ;\n(* note that DocumentRefs are unsupported by this implementation *)\nlicense-ref = \"LicenseRef-\", idstring ;\n\nwith = [ whitespace ], \"WITH\", [ whitespace ] ;\nand = [ whitespace ], \"AND\", [ whitespace ] ;\nor = [ whitespace ], \"OR\", [ whitespace ] ;\n\nsimple-expression = [ whitespace ], (\n  | license-id\n  | license-id, \"+\"\n  | license-ref\n  ), [ whitespace ] ;\n\n(* the following are split up from compound-expression to make precedence obvious *)\nparenthesized-expression =\n  | simple-expression\n  | [ whitespace ], \"(\", or-expression, \")\", [ whitespace ] ;\n\nwith-expression =\n  | parenthesized-expression\n  | simple-expression, with, license-exception-id, [ whitespace ] ;\n\n(* note: \"a AND b OR c\" gets parsed as \"(a AND b) OR c\" *)\nand-expression = with-expression, { and, with-expression } ;\nor-expression = and-expression, { or, and-exression } ;\n\nlicense-expression = or-expression ;\n```\n\n#### Examples\n\nFor libraries with simple licensing,\nonly one license identifier may be needed;\n\nvcpkg, for example, would use this since it uses the MIT license:\n\n```json\n{\n  \"license\": \"MIT\"\n}\n```\n\nMany GPL'd projects allow either the GPL 2 or any later versions:\n\n```json\n{\n  \"license\": \"GPL-2.0-or-later\"\n}\n```\n\nMany Rust projects, in order to make certain they're useable with GPL,\nbut also desiring the MIT license, will allow licensing under either\nthe MIT license or Apache 2.0:\n\n```json\n{\n  \"license\": \"Apache-2.0 OR MIT\"\n}\n```\n\nSome major projects include exceptions;\nthe Microsoft C++ standard library, and the LLVM project,\nare licensed under Apache 2.0 with the LLVM exception:\n\n```json\n{\n  \"license\": \"Apache-2.0 WITH LLVM-exception\"\n}\n```\n","Nav":"#"},{"Path":"/en/docs/maintainers/portfile-functions.html","Name":"Portfile Helper Functions","Source":"<!-- Run regenerate.ps1 to extract scripts documentation -->\n\n# Portfile helper functions\n- [execute\\_process](execute_process.md)\n- [vcpkg\\_acquire\\_msys](vcpkg_acquire_msys.md)\n- [vcpkg\\_add\\_to\\_path](vcpkg_add_to_path.md)\n- [vcpkg\\_apply\\_patches](vcpkg_apply_patches.md) (deprecated)\n- [vcpkg\\_backup\\_restore\\_env\\_vars](vcpkg_backup_restore_env_vars.md)\n- [vcpkg\\_build\\_cmake](vcpkg_build_cmake.md) (deprecated, use [vcpkg\\_cmake\\_build](ports/vcpkg-cmake/vcpkg_cmake_build.md))\n- [vcpkg\\_build\\_make](vcpkg_build_make.md)\n- [vcpkg\\_build\\_msbuild](vcpkg_build_msbuild.md)\n- [vcpkg\\_build\\_ninja](vcpkg_build_ninja.md)\n- [vcpkg\\_build\\_nmake](vcpkg_build_nmake.md)\n- [vcpkg\\_build\\_qmake](vcpkg_build_qmake.md)\n- [vcpkg\\_buildpath\\_length\\_warning](vcpkg_buildpath_length_warning.md)\n- [vcpkg\\_check\\_features](vcpkg_check_features.md)\n- [vcpkg\\_check\\_linkage](vcpkg_check_linkage.md)\n- [vcpkg\\_clean\\_executables\\_in\\_bin](vcpkg_clean_executables_in_bin.md)\n- [vcpkg\\_clean\\_msbuild](vcpkg_clean_msbuild.md)\n- [vcpkg\\_common\\_definitions](vcpkg_common_definitions.md)\n- [vcpkg\\_configure\\_cmake](vcpkg_configure_cmake.md) (deprecated, use [vcpkg\\_cmake\\_configure](ports/vcpkg-cmake/vcpkg_cmake_configure.md))\n- [vcpkg\\_configure\\_gn](vcpkg_configure_gn.md) (deprecated, use [vcpkg\\_gn\\_configure](ports/vcpkg-gn/vcpkg_gn_configure.md))\n- [vcpkg\\_configure\\_make](vcpkg_configure_make.md)\n- [vcpkg\\_configure\\_meson](vcpkg_configure_meson.md)\n- [vcpkg\\_configure\\_qmake](vcpkg_configure_qmake.md)\n- [vcpkg\\_copy\\_pdbs](vcpkg_copy_pdbs.md)\n- [vcpkg\\_copy\\_tool\\_dependencies](vcpkg_copy_tool_dependencies.md)\n- [vcpkg\\_copy\\_tools](vcpkg_copy_tools.md)\n- [vcpkg\\_download\\_distfile](vcpkg_download_distfile.md)\n- [vcpkg\\_execute\\_build\\_process](vcpkg_execute_build_process.md)\n- [vcpkg\\_execute\\_in\\_download\\_mode](vcpkg_execute_in_download_mode.md)\n- [vcpkg\\_execute\\_required\\_process](vcpkg_execute_required_process.md)\n- [vcpkg\\_execute\\_required\\_process\\_repeat](vcpkg_execute_required_process_repeat.md)\n- [vcpkg\\_extract\\_source\\_archive](vcpkg_extract_source_archive.md)\n- [vcpkg\\_extract\\_source\\_archive\\_ex](vcpkg_extract_source_archive_ex.md)\n- [vcpkg\\_fail\\_port\\_install](vcpkg_fail_port_install.md) (deprecated)\n- [vcpkg\\_find\\_acquire\\_program](vcpkg_find_acquire_program.md)\n- [vcpkg\\_find\\_fortran](vcpkg_find_fortran.md)\n- [vcpkg\\_fixup\\_cmake\\_targets](vcpkg_fixup_cmake_targets.md) (deprecated, use [vcpkg\\_cmake\\_config\\_fixup](ports/vcpkg-cmake-config/vcpkg_cmake_config_fixup.md))\n- [vcpkg\\_fixup\\_pkgconfig](vcpkg_fixup_pkgconfig.md)\n- [vcpkg\\_from\\_bitbucket](vcpkg_from_bitbucket.md)\n- [vcpkg\\_from\\_git](vcpkg_from_git.md)\n- [vcpkg\\_from\\_github](vcpkg_from_github.md)\n- [vcpkg\\_from\\_gitlab](vcpkg_from_gitlab.md)\n- [vcpkg\\_from\\_sourceforge](vcpkg_from_sourceforge.md)\n- [vcpkg\\_get\\_program\\_files\\_platform\\_bitness](vcpkg_get_program_files_platform_bitness.md)\n- [vcpkg\\_get\\_windows\\_sdk](vcpkg_get_windows_sdk.md)\n- [vcpkg\\_host\\_path\\_list](vcpkg_host_path_list.md)\n- [vcpkg\\_install\\_cmake](vcpkg_install_cmake.md) (deprecated, use [vcpkg\\_cmake\\_install](ports/vcpkg-cmake/vcpkg_cmake_install.md))\n- [vcpkg\\_install\\_gn](vcpkg_install_gn.md) (deprecated, use [vcpkg\\_gn\\_install](ports/vcpkg-gn/vcpkg_gn_install.md))\n- [vcpkg\\_install\\_make](vcpkg_install_make.md)\n- [vcpkg\\_install\\_meson](vcpkg_install_meson.md)\n- [vcpkg\\_install\\_msbuild](vcpkg_install_msbuild.md)\n- [vcpkg\\_install\\_nmake](vcpkg_install_nmake.md)\n- [vcpkg\\_install\\_qmake](vcpkg_install_qmake.md)\n- [vcpkg\\_list](vcpkg_list.md)\n- [vcpkg\\_minimum\\_required](vcpkg_minimum_required.md)\n- [vcpkg\\_replace\\_string](vcpkg_replace_string.md)\n\n## Internal Functions\n\n- [z\\_vcpkg\\_apply\\_patches](internal/z_vcpkg_apply_patches.md)\n- [z\\_vcpkg\\_forward\\_output\\_variable](internal/z_vcpkg_forward_output_variable.md)\n- [z\\_vcpkg\\_function\\_arguments](internal/z_vcpkg_function_arguments.md)\n- [z\\_vcpkg\\_get\\_cmake\\_vars](internal/z_vcpkg_get_cmake_vars.md)\n- [z\\_vcpkg\\_prettify\\_command\\_line](internal/z_vcpkg_prettify_command_line.md)\n- [z\\_vcpkg\\_setup\\_pkgconfig\\_path](internal/z_vcpkg_setup_pkgconfig_path.md)\n\n## Scripts from Ports\n\n### [vcpkg-cmake](ports/vcpkg-cmake.md)\n\n- [vcpkg\\_cmake\\_build](ports/vcpkg-cmake/vcpkg_cmake_build.md)\n- [vcpkg\\_cmake\\_configure](ports/vcpkg-cmake/vcpkg_cmake_configure.md)\n- [vcpkg\\_cmake\\_install](ports/vcpkg-cmake/vcpkg_cmake_install.md)\n\n### [vcpkg-gn](ports/vcpkg-gn.md)\n\n- [vcpkg\\_gn\\_configure](ports/vcpkg-gn/vcpkg_gn_configure.md)\n- [vcpkg\\_gn\\_install](ports/vcpkg-gn/vcpkg_gn_install.md)\n\n### [vcpkg-cmake-config](ports/vcpkg-cmake-config.md)\n\n- [vcpkg\\_cmake\\_config\\_fixup](ports/vcpkg-cmake-config/vcpkg_cmake_config_fixup.md)\n\n### [vcpkg-cmake-get-vars](ports/vcpkg-cmake-get-vars.md)\n\n- [vcpkg\\_cmake\\_get\\_vars](ports/vcpkg-cmake-get-vars/vcpkg_cmake_get_vars.md)\n\n### [vcpkg-pkgconfig-get-modules](ports/vcpkg-pkgconfig-get-modules.md)\n\n- [x\\_vcpkg\\_pkgconfig\\_get\\_modules](ports/vcpkg-pkgconfig-get-modules/x_vcpkg_pkgconfig_get_modules.md)\n","Nav":"#"},{"Path":"/en/docs/maintainers/ports/vcpkg-cmake/vcpkg_cmake_build.html","Name":"vcpkg_cmake_build","Source":"# vcpkg_cmake_build\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/ports/vcpkg-cmake/vcpkg_cmake_build.md).\n\nBuild a cmake project.\n\n```cmake\nvcpkg_cmake_build(\n    [TARGET <target>]\n    [LOGFILE_BASE <base>]\n    [DISABLE_PARALLEL]\n    [ADD_BIN_TO_PATH]\n)\n```\n\n`vcpkg_cmake_build` builds an already-configured cmake project.\nYou can use the alias [`vcpkg_cmake_install()`] function\nif your CMake build system supports the `install` TARGET,\nand this is something we recommend doing whenever possible.\nOtherwise, you can use `TARGET` to set the target to build.\nThis function defaults to not passing a target to cmake.\n\n[`vcpkg_cmake_install()`]: vcpkg_cmake_install.md\n\n`LOGFILE_BASE` is used to set the base of the logfile names;\nby default, this is `build`, and thus the logfiles end up being something like\n`build-x86-windows-dbg.log`; if you use `vcpkg_cmake_install`,\nthis is set to `install`, so you'll get log names like `install-x86-windows-dbg.log`.\n\nFor build systems that are buggy when run in parallel,\nusing `DISABLE_PARALLEL` will run the build with only one job.\n\nFinally, `ADD_BIN_TO_PATH` adds the appropriate (either release or debug)\n`bin/` directories to the path during the build,\nsuch that executables run during the build will be able to access those DLLs.\n\n## Source\n[ports/vcpkg-cmake/vcpkg\\_cmake\\_build.cmake](https://github.com/Microsoft/vcpkg/blob/master/ports/vcpkg-cmake/vcpkg_cmake_build.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/ports/vcpkg-cmake/vcpkg_cmake_configure.html","Name":"vcpkg_cmake_configure","Source":"# vcpkg_cmake_configure\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/ports/vcpkg-cmake/vcpkg_cmake_configure.md).\n\nConfigure a CMake buildsystem.\n\n```cmake\nvcpkg_cmake_configure(\n    SOURCE_PATH <source-path>\n    [LOGFILE_BASE <logname-base>]\n    [DISABLE_PARALLEL_CONFIGURE]\n    [NO_CHARSET_FLAG]\n    [WINDOWS_USE_MSBUILD]\n    [GENERATOR <generator>]\n    [OPTIONS\n        <configure-setting>...]\n    [OPTIONS_RELEASE\n        <configure-setting>...]\n    [OPTIONS_DEBUG\n        <configure-setting>...]\n    [MAYBE_UNUSED_VARIABLES\n        <option-name>...]\n)\n```\n\n`vcpkg_cmake_configure` configures a CMake build system for use with\n`vcpkg_cmake_buildsystem_build` and `vcpkg_cmake_buildsystem_install`.\n`source-path` is where the source is located; by convention,\nthis is usually `${SOURCE_PATH}`, which is set by one of the `vcpkg_from_*` functions.\nThis function configures the build system for both Debug and Release builds by default,\nassuming that `VCPKG_BUILD_TYPE` is not set; if it is, then it will only configure for\nthat build type.\n\nUse the `OPTIONS` argument to set the configure settings for both release and debug,\nand use `OPTIONS_RELEASE` and `OPTIONS_DEBUG` to set the configure settings for\nrelease only and debug only respectively.\n\nBy default, when possible, `vcpkg_cmake_configure` uses [ninja-build]\nas its build system. If the `WINDOWS_USE_MSBUILD` argument is passed, then\n`vcpkg_cmake_configure` will use a Visual Studio generator on Windows;\non every other platform, `vcpkg_cmake_configure` just uses Ninja.\n\n[ninja-build]: https://ninja-build.org/\n\nAdditionally, one may pass the specific generator a port should use with `GENERATOR`.\nThis is useful if some project-specific buildsystem\nhas been wrapped in a CMake build system that doesn't perform an actual build.\nIf used for this purpose, it should be set to `\"NMake Makefiles\"`.\n`vcpkg_cmake_buildsystem_build` and `install` do not support this being set to anything\nexcept for NMake.\n\nFor libraries which cannot be configured in parallel,\npass the `DISABLE_PARALLEL_CONFIGURE` flag. This is needed, for example,\nif the library's build system writes back into the source directory during configure.\nThis also disables the `CMAKE_DISABLE_SOURCE_CHANGES` option.\n\nBy default, this function adds flags to `CMAKE_C_FLAGS` and `CMAKE_CXX_FLAGS`\nwhich set the default character set to utf-8 for MSVC.\nIf the library sets its own code page, pass the `NO_CHARSET_FLAG` option.\n\nThis function makes certain that all options passed in are used by the\nunderlying CMake build system. If there are options that might be unused,\nperhaps on certain platforms, pass those variable names to\n`MAYBE_UNUSED_VARIABLES`. For example:\n```cmake\nvcpkg_cmake_configure(\n    ...\n    OPTIONS\n        -DBUILD_EXAMPLE=OFF\n    ...\n    MAYBE_UNUSED_VARIABLES\n        BUILD_EXAMPLE\n)\n```\n\n`LOGFILE_BASE` is used to set the base of the logfile names;\nby default, this is `config`, and thus the logfiles end up being something like\n`config-x86-windows-dbg.log`. You can set it to anything you like;\nif you set it to `config-the-first`,\nyou'll get something like `config-the-first-x86-windows.dbg.log`.\n\n## Notes\nThis command supplies many common arguments to CMake. To see the full list, examine the source.\n\n## Examples\n\n* [zlib](https://github.com/Microsoft/vcpkg/blob/master/ports/zlib/portfile.cmake)\n* [cpprestsdk](https://github.com/Microsoft/vcpkg/blob/master/ports/cpprestsdk/portfile.cmake)\n* [poco](https://github.com/Microsoft/vcpkg/blob/master/ports/poco/portfile.cmake)\n* [opencv4](https://github.com/Microsoft/vcpkg/blob/master/ports/opencv4/portfile.cmake)\n\n## Source\n[ports/vcpkg-cmake/vcpkg\\_cmake\\_configure.cmake](https://github.com/Microsoft/vcpkg/blob/master/ports/vcpkg-cmake/vcpkg_cmake_configure.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/ports/vcpkg-cmake/vcpkg_cmake_install.html","Name":"vcpkg_cmake_install","Source":"# vcpkg_cmake_install\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/ports/vcpkg-cmake/vcpkg_cmake_install.md).\n\nBuild and install a cmake project.\n\n```cmake\nvcpkg_cmake_install(\n    [DISABLE_PARALLEL]\n    [ADD_BIN_TO_PATH]\n)\n```\n\n`vcpkg_cmake_install` transparently forwards to [`vcpkg_cmake_build()`],\nwith additional parameters to set the `TARGET` to `install`,\nand to set the `LOGFILE_ROOT` to `install` as well.\n\n[`vcpkg_cmake_build()`]: vcpkg_cmake_build.md\n\n## Examples:\n\n* [zlib](https://github.com/Microsoft/vcpkg/blob/master/ports/zlib/portfile.cmake)\n\n## Source\n[ports/vcpkg-cmake/vcpkg\\_cmake\\_install.cmake](https://github.com/Microsoft/vcpkg/blob/master/ports/vcpkg-cmake/vcpkg_cmake_install.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/ports/vcpkg-cmake-config/vcpkg_cmake_config_fixup.html","Name":"vcpkg_cmake_config_fixup","Source":"# vcpkg_cmake_config_fixup\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/ports/vcpkg-cmake-config/vcpkg_cmake_config_fixup.md).\n\nMerge release and debug CMake targets and configs to support multiconfig generators.\n\nAdditionally corrects common issues with targets, such as absolute paths and incorrectly placed binaries.\n\n```cmake\nvcpkg_cmake_config_fixup(\n    [PACKAGE_NAME <name>]\n    [CONFIG_PATH <config-directory>]\n    [TOOLS_PATH <tools/${PORT}>]\n    [DO_NOT_DELETE_PARENT_CONFIG_PATH]\n    [NO_PREFIX_CORRECTION]\n)\n```\n\nFor many ports, `vcpkg_cmake_config_fixup()` on its own should work,\nas `PACKAGE_NAME` defaults to `${PORT}` and `CONFIG_PATH` defaults to `share/${PACKAGE_NAME}`.\nFor ports where the package name passed to `find_package` is distinct from the port name,\n`PACKAGE_NAME` should be changed to be that name instead.\nFor ports where the directory of the `*config.cmake` files cannot be set,\nuse the `CONFIG_PATH` to change the directory where the files come from.\n\nBy default the parent directory of CONFIG_PATH is removed if it is named \"cmake\".\nPassing the `DO_NOT_DELETE_PARENT_CONFIG_PATH` option disable such behavior,\nas it is convenient for ports that install\nmore than one CMake package configuration file.\n\nThe `NO_PREFIX_CORRECTION` option disables the correction of `_IMPORT_PREFIX`\ndone by vcpkg due to moving the config files.\nCurrently the correction does not take into account how the files are moved,\nand applies a rather simply correction which in some cases will yield the wrong results.\n\n## How it Works\n\n1. Moves `/debug/<CONFIG_PATH>/*targets-debug.cmake` to `/share/${PACKAGE_NAME}`.\n2. Transforms all references matching `/bin/*.exe` to `/${TOOLS_PATH}/*.exe` on Windows.\n3. Transforms all references matching `/bin/*` to `/${TOOLS_PATH}/*` on other platforms.\n4. Fixes `${_IMPORT_PREFIX}` in auto generated targets.\n5. Replaces `${CURRENT_INSTALLED_DIR}` with `${_IMPORT_PREFIX}` in configs.\n6. Merges INTERFACE_LINK_LIBRARIES of release and debug configurations.\n7. Replaces `${CURRENT_INSTALLED_DIR}` with `${VCPKG_IMPORT_PREFIX}` in targets.\n8. Removes `/debug/<CONFIG_PATH>/*config.cmake`.\n\n## Examples\n\n* [concurrentqueue](https://github.com/Microsoft/vcpkg/blob/master/ports/concurrentqueue/portfile.cmake)\n* [curl](https://github.com/Microsoft/vcpkg/blob/master/ports/curl/portfile.cmake)\n* [nlohmann-json](https://github.com/Microsoft/vcpkg/blob/master/ports/nlohmann-json/portfile.cmake)\n\n## Source\n[ports/vcpkg-cmake-config/vcpkg\\_cmake\\_config\\_fixup.cmake](https://github.com/Microsoft/vcpkg/blob/master/ports/vcpkg-cmake-config/vcpkg_cmake_config_fixup.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/ports/vcpkg-cmake-config.html","Name":"vcpkg-cmake-config","Source":"# vcpkg-cmake-config\n\n`vcpkg-cmake-config` provides `vcpkg_cmake_config_fixup()`,\na function which both:\n\n- Fixes common mistakes in port build systems, like using absolute paths\n- Merges the debug and release config files.\n\nThis function should almost always be used when a port has `*config.cmake` files,\neven when the buildsystem of the project is not CMake.\n","Nav":"#"},{"Path":"/en/docs/maintainers/ports/vcpkg-cmake-get-vars/vcpkg_cmake_get_vars.html","Name":"vcpkg_cmake_get_vars","Source":"# vcpkg_cmake_get_vars\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/ports/vcpkg-cmake-get-vars/vcpkg_cmake_get_vars.md).\n\nRuns a cmake configure with a dummy project to extract certain cmake variables\n\n## Usage\n```cmake\nvcpkg_cmake_get_vars(<out-var>)\n```\n\n`vcpkg_cmake_get_vars(<out-var>)` sets `<out-var>` to\na path to a generated CMake file, with the detected `CMAKE_*` variables\nre-exported as `VCPKG_DETECTED_CMAKE_*`.\n\nAdditionally sets, for `RELEASE` and `DEBUG`:\n- VCPKG_COMBINED_CXX_FLAGS_<config>\n- VCPKG_COMBINED_C_FLAGS_<config>\n- VCPKG_COMBINED_SHARED_LINKER_FLAGS_<config>\n- VCPKG_COMBINED_STATIC_LINKER_FLAGS_<config>\n- VCPKG_COMBINED_EXE_LINKER_FLAGS_<config>\n\nMost users should use these pre-combined flags instead of attempting\nto read the `VCPKG_DETECTED_*` flags directly.\n\n## Notes\nAvoid usage in portfiles.\n\nAll calls to `vcpkg_cmake_get_vars` will result in the same output file;\nthe output file is not generated multiple times.\n\n### Basic Usage\n\n```cmake\nvcpkg_cmake_get_vars(cmake_vars_file)\ninclude(\"${cmake_vars_file}\")\nmessage(STATUS \"detected CXX flags: ${VCPKG_DETECTED_CMAKE_CXX_FLAGS}\")\n```\n\n## Source\n[ports/vcpkg-cmake-get-vars/vcpkg\\_cmake\\_get\\_vars.cmake](https://github.com/Microsoft/vcpkg/blob/master/ports/vcpkg-cmake-get-vars/vcpkg_cmake_get_vars.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/ports/vcpkg-cmake-get-vars.html","Name":"vcpkg-cmake-get-vars","Source":"# vcpkg-cmake-get-vars\n\nThis port contains a helper function to extract CMake variables into the scope of the portfile or other scripts\n","Nav":"#"},{"Path":"/en/docs/maintainers/ports/vcpkg-cmake.html","Name":"vcpkg-cmake","Source":"# vcpkg-cmake\n\nThis port contains cmake functions for dealing with a CMake buildsystem.\n\nIn the common case, `vcpkg_cmake_configure()` (with appropriate arguments)\nfollowed by `vcpkg_cmake_install()` will be enough to build and install a port.\n`vcpkg_cmake_build()` is provided for more complex cases.\n","Nav":"#"},{"Path":"/en/docs/maintainers/ports/vcpkg-gn/vcpkg_gn_configure.html","Name":"vcpkg_gn_configure","Source":"# vcpkg_gn_configure\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/ports/vcpkg-gn/vcpkg_gn_configure.md).\n\nGenerate Ninja (GN) targets\n\n## Usage:\n```cmake\nvcpkg_gn_configure(\n    SOURCE_PATH <SOURCE_PATH>\n    [OPTIONS <OPTIONS>]\n    [OPTIONS_DEBUG <OPTIONS_DEBUG>]\n    [OPTIONS_RELEASE <OPTIONS_RELEASE>]\n)\n```\n\n## Parameters:\n### SOURCE_PATH (required)\nThe path to the GN project.\n\n### OPTIONS\nOptions to be passed to both the debug and release targets.\nNote: Must be provided as a space-separated string.\n\n### OPTIONS_DEBUG (space-separated string)\nOptions to be passed to the debug target.\n\n### OPTIONS_RELEASE (space-separated string)\nOptions to be passed to the release target.\n\n## Source\n[ports/vcpkg-gn/vcpkg\\_gn\\_configure.cmake](https://github.com/Microsoft/vcpkg/blob/master/ports/vcpkg-gn/vcpkg_gn_configure.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/ports/vcpkg-gn/vcpkg_gn_install.html","Name":"vcpkg_gn_install","Source":"# vcpkg_gn_install\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/ports/vcpkg-gn/vcpkg_gn_install.md).\n\nInstalls a GN project.\n\nIn order to build a GN project without installing, use [`vcpkg_build_ninja()`].\n\n## Usage:\n```cmake\nvcpkg_gn_install(\n     SOURCE_PATH <SOURCE_PATH>\n     [TARGETS <target>...]\n)\n```\n\n## Parameters:\n### SOURCE_PATH\nThe path to the source directory\n\n### TARGETS\nOnly install the specified targets.\n\nNote: includes must be handled separately\n\n[`vcpkg_build_ninja()`]: vcpkg_build_ninja.md\n\n## Source\n[ports/vcpkg-gn/vcpkg\\_gn\\_install.cmake](https://github.com/Microsoft/vcpkg/blob/master/ports/vcpkg-gn/vcpkg_gn_install.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/ports/vcpkg-gn.html","Name":"vcpkg-gn","Source":"# vcpkg-gn\n\nThis port contains cmake functions for dealing with a GN buildsystem.\n\n## Example\n\n```cmake\nvcpkg_gn_configure(\n    SOURCE_PATH \"${SOURCE_PATH}\"\n)\nvcpkg_gn_install()\n```\n","Nav":"#"},{"Path":"/en/docs/maintainers/ports/vcpkg-pkgconfig-get-modules/x_vcpkg_pkgconfig_get_modules.html","Name":"X_vcpkg_pkgconfig_get_modules","Source":"# x_vcpkg_pkgconfig_get_modules\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/ports/vcpkg-pkgconfig-get-modules/x_vcpkg_pkgconfig_get_modules.md).\n\nExperimental\nRetrieve required module information from pkgconfig modules\n\n## Usage\n```cmake\nx_vcpkg_pkgconfig_get_modules(\n    PREFIX <prefix>\n    MODULES <pkgconfig_modules>...\n    [CFLAGS]\n    [LIBS]\n    [LIBRARIES]\n    [LIBRARIES_DIRS]\n    [INCLUDE_DIRS]\n)\n```\n## Parameters\n\n### PREFIX\nUsed variable prefix to use\n\n### MODULES\nList of pkgconfig modules to retrieve information for.\n\n### LIBS\nReturns `\"${PKGCONFIG}\" --libs` in <prefix>_LIBS_(DEBUG|RELEASE)\n\n### LIBRARIES\nReturns `\"${PKGCONFIG}\" --libs-only-l` in <prefix>_LIBRARIES_(DEBUG|RELEASE)\n\n### LIBRARIES_DIRS\nReturns `\"${PKGCONFIG}\" --libs-only-L` in <prefix>_LIBRARIES_DIRS_(DEBUG|RELEASE)\n\n### INCLUDE_DIRS\nReturns `\"${PKGCONFIG}\"  --cflags-only-I` in <prefix>_INCLUDE_DIRS_(DEBUG|RELEASE)\n\n## Examples\n\n* [qt5-base](https://github.com/microsoft/vcpkg/blob/master/ports/qt5-base/portfile.cmake)\n\n## Source\n[ports/vcpkg-pkgconfig-get-modules/x\\_vcpkg\\_pkgconfig\\_get\\_modules.cmake](https://github.com/Microsoft/vcpkg/blob/master/ports/vcpkg-pkgconfig-get-modules/x_vcpkg_pkgconfig_get_modules.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/ports/vcpkg-pkgconfig-get-modules.html","Name":"vcpkg-pkgconfig-get-modules","Source":"# vcpkg-pkgconfig-get-modules\n\n**Experimental: will change or be removed at any time**\n\n`vcpkg-pkgconfig-get-modules` provides `x_vcpkg_pkgconfig_get_modules()`, a function which simplifies calling\n`pkg-config` in portfiles in order to gather dependencies for exotic buildsystems.\n","Nav":"#"},{"Path":"/en/docs/maintainers/pr-review-checklist.html","Name":"PR Checklist","Source":"Vcpkg PR Checklist\n=====================\nRevision: 1\n\n## Overview\nThis document provides an annotated checklist which vcpkg team members use to apply the \"reviewed\" label on incoming pull requests. If a pull request violates any of these points, we may ask contributors to make necessary changes before we can merge the changeset.\n\nFeel free to create an issue or pull request if you feel that this checklist can be improved. Please increment the revision number when modifying the checklist content.\n\n## Checklist\nYou can link any of these checklist items in a GitHub comment by copying the link address attached to each item code.\n\n<details id=\"c000001\">\n<summary><a href=\"#c000001\">c000001</a>: No deprecated helper functions are used</summary>\n\nSee our [Maintainer Guidelines and Policies](maintainer-guide.md#avoid-deprecated-helper-functions) for more information.\n\n</details>\n\n<details id=\"c000002\">\n<summary><a href=\"#c000002\">c000002</a>: `\"port-version\"` field is updated</summary>\n\nSee our [Maintainer Guidelines and Policies](maintainer-guide.md#versioning) for more information.\n\n</details>\n\n<details id=\"c000003\">\n<summary><a href=\"#c000003\">c000003</a>: New ports contain a `\"description\"` field written in English</summary>\n\nA description only one or a few sentences long is helpful. Consider using the library's official description from their `README.md` or similar if possible. Automatic translations are acceptable and we are happy to clean up translations to English for our contributors.\n\nSee our [manifest file documentation](manifest-files.md#description) for more information.\n    \n</details>\n\n<details id=\"c000004\">\n<summary><a href=\"#c000004\">c000004</a>: No unnecessary comments are present in the changeset</summary>\n\nSee our [Maintainer Guidelines and Policies](maintainer-guide.md#avoid-excessive-comments-in-portfiles) for more information.\n\n</details>\n\n<details id=\"c000005\">\n<summary><a href=\"#c000005\">c000005</a>: Downloaded archives are versioned if available</summary\n\nTo ensure archive content does not change, archives downloaded preferably have an associated version tag that can be incremented alongside the port's `\"version\"`.\n\n</details>\n\n<details id=\"c000006\">\n<summary><a href=\"#c000006\">c000006</a>: New ports pass CI checks for triplets that the library officially supports</summary>\n\nTo ensure vcpkg ports are of a high quality, we ask that incoming ports support the official platforms for the library in question.\n\n</details>\n\n<details id=\"c000007\">\n<summary><a href=\"#c000007\">c000007</a>: Patches fix issues that are vcpkg-specific only</summary>\n\nIf possible, patches to the library source code should be upstreamed to the library's official repository. Opening up a pull request on the library's repository will help to improve the library for everyone, not just vcpkg users.\n\n</details>\n\n<details id=\"c000008\">\n<summary><a href=\"#c000008\">c000008</a>: New ports download source code from the official source if available</summary>\n\nTo respect library authors and keep code secure, please have ports download source code from the official source. We may make exceptions if the original source code is not available and there is substantial community interest in maintaining the library in question.\n\n</details>\n\n<details id=\"c000009\">\n<summary><a href=\"#c000009\">c000009</a>: Ports and port features are named correctly</summary>\n\nFor user accessibility, we prefer names of ports and port features to be intuitive and close to their counterparts in official sources and other package managers. If you are unsure about the naming of a port or port feature, we recommend checking repology.org, packages.ubuntu.com, or searching for additional information using a search engine. We can also help our contributors with this, so feel free to ask for naming suggestions if you are unsure.\n\n</details>\n\n<details id=\"c000010\">\n<summary><a href=\"#c000010\">c000010</a>: Library targets are exported when appropriate</summary>\n\nTo provide users with a seamless build system integration, please be sure to export and provide a means of finding the library targets intended to be used downstream. Targets not meant to be exported should be be marked private and not exported.\n\n</details>\n\n<details id=\"c000011\">\n<summary><a href=\"#c000011\">c000011</a>: Ports do not use applications which modify the user's system</summary>\n    \nPorts should uphold vcpkg's contract of not modifying the user's system by avoiding applications which do so. Examples of these applications are `sudo`, `apt`, `brew`, or `pip`. Please use an alternative to these types of programs wherever possible.\n\n</details>\n\n<details id=\"c000012\">\n<summary><a href=\"#c000012\">c000012</a>: Ports with system dependencies include an information message during installation</summary>\n\nSome ports have library and tool dependencies that do not exist within vcpkg. For these missing dependencies, we ask that contributors add a message to the top of the port's `portfile.cmake` stating the missing dependencies and how to acquire them. We ask that the message is displayed before any major work is done to ensure that users can \"early out\" of the installation process as soon as possible in case they are missing the dependency.\n\nExample:\n```cmake\nmessage(\n\"${PORT} currently requires the following libraries from the system package manager:\n    autoconf libtool\nThese can be installed on Ubuntu systems via sudo apt install autoconf libtool\"\n)\n```\n\n</details>\n\n<details id=\"c000013\">\n<summary><a href=\"#c000013\">c000013</a>: Manifest files are used instead of CONTROL files for new ports</summary>\n\nMany existing ports use the CONTROL file syntax; while this syntax will be supported for some time to come,\nnew ports should not use these. Any newly added port _must_ use the manifest files.\n\nWe also recommend, when significant modifications are made to ports, that one switches to manifest files;\nhowever, this is not required. You may find `vcpkg format-manifest` useful.\n","Nav":"#"},{"Path":"/en/docs/maintainers/registries.html","Name":"Registries","Source":"# Creating Registries\n\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/maintainers/registries.md).**\n\nThere are two parts to using registries; this documents the creation side of\nthe relationship. In order to learn more about using registries that others\nhave created, please read [this documentation](../users/registries.md).\n## Table of Contents\n\n- [Creating Registries](#creating-registries)\n  - [Table of Contents](#table-of-contents)\n  - [Overview](#overview)\n    - [Git Registries](#git-registries)\n      - [Adding a New Version](#adding-a-new-version)\n    - [Filesystem Registries](#filesystem-registries)\n      - [Adding a New Version](#adding-a-new-version-1)\n    - [Builtin Registries](#builtin-registries)\n\n## Overview\n\nRegistries are collections of ports and their versions. There are two major\nchoices of implementation for registries, if you want to create your own -\ngit registries, and filesystem registries.\n\nGit registries are simple git repositories, and can be shared publicly or\nprivately via normal mechanisms for git repositories. The vcpkg repository at\n<https://github.com/microsoft/vcpkg>, for example, is a git registry.\n\nFilesystem registries are designed as more of a testing ground. Given that they\nliterally live on your filesystem, the only way to share them is via shared\ndirectories. However, filesystem registries can be useful as a way to represent\nregistries held in non-git version control systems, assuming one has some way\nto get the registry onto the disk.\n\nNote that we expect the set of registry types to grow over time; if you would\nlike support for registries built in your favorite public version control\nsystem, don't hesitate to open a PR.\n\nThe basic structure of a registry is:\n\n- The set of versions that are considered \"latest\" at certain times in history,\n  known as the \"baseline\".\n- The set of all the versions of all the ports, and where to find each of\n  these in the registry.\n\n### Git Registries\n\nAs you're following along with this documentation, it may be helpful to have\na working example to refer to. We've written one and put it here:\n<https://github.com/northwindtraders/vcpkg-registry>.\n\nAll git registries must have a `versions/baseline.json` file. This file\ncontains the set of \"latest versions\" at a certain commit. It is laid out as\na top-level object containing only the `\"default\"` field. This field should\ncontain an object mapping port names to the version which is currently the\nlatest.\n\nHere's an example of a valid baseline.json:\n\n```json\n{\n  \"default\": {\n    \"kitten\": {\n      \"baseline\": \"2.6.2\",\n      \"port-version\": 0\n    },\n    \"port-b\": {\n      \"baseline\": \"19.00\",\n      \"port-version\": 2\n    }\n  }\n}\n```\n\nThe `versions` directory contains all the information about which versions of\nwhich packages are contained in the registry, along with where those versions\nare stored. The rest of the registry just acts as a backing store, as far as\nvcpkg is concerned: only things inside the `versions` directory will be used\nto direct how your registry is seen by vcpkg.\n\nEach port in a registry should exist in the versions directory as\n`<first letter of port>-/<name of port>.json`; in other words, the\ninformation about the `kitten` port would be located in\n`versions/k-/kitten.json`. This should be a top-level object with only a\nsingle field: `\"versions\"`. This field should contain an array of version \nobjects:\n\n- The version of the port in question; should be exactly the same as the\n  `vcpkg.json` file, including the version fields and `\"port-version\"`.\n- The `\"git-tree\"` field, which is a git tree; in other words, what you get\n  when you write `git rev-parse COMMIT-ID:path/to/port`.\n\nNote that the version fields for ports with `CONTROL` files, is \n`\"version-string\"`; we do not recommend using `CONTROL` files in new\nregistries, however.\n\n_WARNING_: One very important part of registries is that versions should\n_never_ be changed. Updating to a later ref should never remove or change an\nexisting version. It must always be safe to update a registry.\n\nHere's an example of a valid version database for a `kitten` port with one \nversion:\n\n```json\n{\n  \"versions\": [\n    {\n      \"version\": \"2.6.2\",\n      \"port-version\": 0,\n      \"git-tree\": \"67d60699c271b7716279fdea5a5c6543929eb90e\"\n    }\n  ]\n}\n```\n\nIn general, it's not important where you place port directories. However, the\nidiom in vcpkg is to follow what the built in vcpkg registry does: your \n`kitten` port should be placed in `ports/kitten`.\n\n_WARNING_: One other thing to keep in mind is that when you update a registry,\nall previous versions should also be accessible. Since your user will set their\nbaseline to a commit ID, that commit ID must always exist, and be accessible\nfrom your HEAD commit, which is what is actually fetched. This means that your\nHEAD commit should be a child of all previous HEAD commits.\n\n### Builtin Registries\n\nBuiltin registries are treated as special Git registries. Instead of fetching\nfrom a remote url, builtin registries consult the `$VCPKG_ROOT/.git` directory\nof the vcpkg clone. They use the currently checked out `$VCPKG_ROOT/versions`\ndirectory as the source for versioning information.\n\n#### Adding a New Version\n\nThere is some git trickery involved in creating a new version of a port. The\nfirst thing to do is make some changes, update the `\"port-version\"` and regular\nversion field as you need to, and then test with `overlay-ports`:\n`vcpkg install kitten --overlay-ports=ports/kitten`.\n\nOnce you've finished your testing, you'll need to make sure that the directory\nas it is is under git's purview. You'll do this by creating a temporary commit:\n\n```pwsh\n> git add ports/kitten\n> git commit -m 'temporary commit'\n```\n\nThen, get the git tree ID of the directory:\n\n```pwsh\n> git rev-parse HEAD:ports/kitten\n73ad3c823ef701c37421b450a34271d6beaf7b07\n```\n\nThen, you can add this version to the versions database. At the top of your\n`versions/k-/kitten.json`, you can add (assuming you're adding version\n`2.6.3#0`):\n\n```json\n{\n  \"versions\": [\n    {\n      \"version\": \"2.6.3\",\n      \"port-version\": 0,\n      \"git-tree\": \"73ad3c823ef701c37421b450a34271d6beaf7b07\"\n    },\n    {\n      \"version\": \"2.6.2\",\n      \"port-version\": 0,\n      \"git-tree\": \"67d60699c271b7716279fdea5a5c6543929eb90e\"\n    }\n  ]\n}\n```\n\nthen, you'll want to modify your `versions/baseline.json` with your new version \nas well:\n\n```json\n{\n  \"default\": {\n    \"kitten\": {\n      \"baseline\": \"2.6.3\",\n      \"port-version\": 0\n    },\n    \"port-b\": {\n      \"baseline\": \"19.00\",\n      \"port-version\": 2\n    }\n  }\n}\n```\n\nand amend your current commit:\n\n```pwsh\n> git commit --amend\n```\n\nthen share away!\n\n### Filesystem Registries\n\nAs you're following along with this documentation, it may be helpful to have\na working example to refer to. We've written one and put it here:\n<https://github.com/vcpkg/example-filesystem-registry>.\n\nAll filesystem registries must have a `versions/baseline.json` file. This file\ncontains the set of \"latest versions\" for a certain version of the registry.\nIt is laid out as a top-level object containing a map from version name to\n\"baseline objects\", which map port names to the version which is considered\n\"latest\" for that version of the registry.\n\nFilesystem registries need to decide on a versioning scheme. Unlike git \nregistries, which have the implicit versioning scheme of refs, filesystem\nregistries can't rely on the version control system here. One possible option\nis to do a daily release, and have your \"versions\" be dates.\n\n_WARNING_: A baseline must always refer to the same set of versions. If you\nwant to add new versions, you need to create a new version of the registry in\nthe `baseline.json` file.\n\nHere's an example of a valid `baseline.json`, for a registry that has decided\nupon dates for their versions:\n\n```json\n{\n  \"2021-04-16\": {\n    \"kitten\": {\n      \"baseline\": \"2.6.2\",\n      \"port-version\": 0\n    },\n    \"port-b\": {\n      \"baseline\": \"19.00\",\n      \"port-version\": 2\n    }\n  },\n  \"2021-04-15\": {\n    \"kitten\": {\n      \"baseline\": \"2.6.2\",\n      \"port-version\": 0\n    },\n    \"port-b\": {\n      \"baseline\": \"19.00\",\n      \"port-version\": 1\n    }\n  }\n}\n```\n\nThe `versions` directory contains all the information about which versions of\nwhich packages are contained in the registry, along with where those versions\nare stored. The rest of the registry just acts as a backing store, as far as\nvcpkg is concerned: only things inside the `versions` directory will be used\nto direct how your registry is seen by vcpkg.\n\nEach port in a registry should exist in the versions directory as\n`<first letter of port>-/<name of port>.json`; in other words, the\ninformation about the `kitten` port would be located in\n`versions/k-/kitten.json`. This should be a top-level object with only a\nsingle field: `\"versions\"`. This field should contain an array of version \nobjects:\n\n- The version of the port in question; should be exactly the same as the\n  `vcpkg.json` file, including the version fields and `\"port-version\"`.\n- The `\"path\"` field: a relative directory, rooted at the base of the registry\n  (in other words, the directory where `versions` is located), to the port \n  directory. It should look something like `\"$/path/to/port/dir`\"\n\nNote that the version fields for ports with `CONTROL` files, is \n`\"version-string\"`; we do not recommend using `CONTROL` files in new\nregistries, however.\n\nIn general, it's not important where you place port directories. However, the\nidiom in vcpkg is to follow somewhat closely to what the built in vcpkg\nregistry does: your `kitten` port at version `x.y.z` should be placed in\n`ports/kitten/x.y.z`, with port versions appended as you see fit (although\nsince `#` is not a good character to use for file names, perhaps use `_`).\n\n_WARNING_: One very important part of registries is that versions should\n_never_ be changed. One should never remove or change an existing version.\nYour changes to your registry shouldn't change behavior to downstream users.\n\nHere's an example of a valid version database for a `kitten` port with one \nversion:\n\n```json\n{\n  \"versions\": [\n    {\n      \"version\": \"2.6.2\",\n      \"port-version\": 0,\n      \"path\": \"$/ports/kitten/2.6.2_0\"\n    }\n  ]\n}\n```\n\n#### Adding a New Version\n\nUnlike git registries, adding a new version to a filesystem registry mostly\ninvolves a lot of copying. The first thing to do is to copy the latest\nversion of your port into a new version directory, update the version and\n`\"port-version\"` fields as you need to, and then test with `overlay-ports`:\n`vcpkg install kitten --overlay-ports=ports/kitten/new-version`.\n\nOnce you've finished your testing, you can add this new version to the top of\nyour `versions/k-/kitten.json`:\n\n```json\n{\n  \"versions\": [\n    {\n      \"version\": \"2.6.3\",\n      \"port-version\": 0,\n      \"path\": \"$/ports/kitten/2.6.3_0\"\n    },\n    {\n      \"version\": \"2.6.2\",\n      \"port-version\": 0,\n      \"path\": \"$/ports/kitten/2.6.2_0\"\n    }\n  ]\n}\n```\n\nthen, you'll want to modify your `versions/baseline.json` with your new version \nas well (remember not to modify existing baselines):\n\n```json\n{\n  \"2021-04-17\": {\n    \"kitten\": {\n      \"baseline\": \"2.6.3\",\n      \"port-version\": 0\n    },\n    \"port-b\": {\n      \"baseline\": \"19.00\",\n      \"port-version\": 2\n    }\n  },\n  \"2021-04-16\": {\n    \"kitten\": {\n      \"baseline\": \"2.6.2\",\n      \"port-version\": 0\n    },\n    \"port-b\": {\n      \"baseline\": \"19.00\",\n      \"port-version\": 2\n    }\n  },\n  \"2021-04-15\": {\n    \"kitten\": {\n      \"baseline\": \"2.6.2\",\n      \"port-version\": 0\n    },\n    \"port-b\": {\n      \"baseline\": \"19.00\",\n      \"port-version\": 1\n    }\n  }\n}\n```\n\nand you're done!\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_acquire_msys.html","Name":"vcpkg_acquire_msys","Source":"# vcpkg_acquire_msys\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_acquire_msys.md).\n\nDownload and prepare an MSYS2 instance.\n\n## Usage\n```cmake\nvcpkg_acquire_msys(<MSYS_ROOT_VAR>\n    PACKAGES <package>...\n    [NO_DEFAULT_PACKAGES]\n    [DIRECT_PACKAGES <URL> <SHA512> <URL> <SHA512> ...]\n)\n```\n\n## Parameters\n### MSYS_ROOT_VAR\nAn out-variable that will be set to the path to MSYS2.\n\n### PACKAGES\nA list of packages to acquire in msys.\n\nTo ensure a package is available: `vcpkg_acquire_msys(MSYS_ROOT PACKAGES make automake1.16)`\n\n### NO_DEFAULT_PACKAGES\nExclude the normal base packages.\n\nThe list of base packages includes: bash, coreutils, sed, grep, gawk, gzip, diffutils, make, and pkg-config\n\n### DIRECT_PACKAGES\nA list of URL/SHA512 pairs to acquire in msys.\n\nThis parameter can be used by a port to privately extend the list of msys packages to be acquired.\nThe URLs can be found on the msys2 website[1] and should be a direct archive link:\n\n    https://repo.msys2.org/mingw/i686/mingw-w64-i686-gettext-0.19.8.1-9-any.pkg.tar.zst\n\n[1] https://packages.msys2.org/search\n\n## Notes\nA call to `vcpkg_acquire_msys` will usually be followed by a call to `bash.exe`:\n```cmake\nvcpkg_acquire_msys(MSYS_ROOT)\nset(BASH ${MSYS_ROOT}/usr/bin/bash.exe)\n\nvcpkg_execute_required_process(\n    COMMAND ${BASH} --noprofile --norc \"${CMAKE_CURRENT_LIST_DIR}\\\\build.sh\"\n    WORKING_DIRECTORY ${CURRENT_BUILDTREES_DIR}/${TARGET_TRIPLET}-rel\n    LOGNAME build-${TARGET_TRIPLET}-rel\n)\n```\n\n## Examples\n\n* [ffmpeg](https://github.com/Microsoft/vcpkg/blob/master/ports/ffmpeg/portfile.cmake)\n* [icu](https://github.com/Microsoft/vcpkg/blob/master/ports/icu/portfile.cmake)\n* [libvpx](https://github.com/Microsoft/vcpkg/blob/master/ports/libvpx/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_acquire\\_msys.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_acquire_msys.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_add_to_path.html","Name":"vcpkg_add_to_path","Source":"# vcpkg_add_to_path\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_add_to_path.md).\n\nAdd a directory or directories to the PATH environment variable\n\n```cmake\nvcpkg_add_to_path([PREPEND] [<path>...])\n```\n\n`vcpkg_add_to_path` adds all of the paths passed to it to the PATH environment variable.\nIf PREPEND is passed, then those paths are prepended to the PATH environment variable,\nso that they are searched first; otherwise, those paths are appended, so they are\nsearched after the paths which are already in the environment variable.\n\nThe paths are added in the order received, so that the first path is always searched\nbefore a later path.\n\nIf no paths are passed, then nothing will be done.\n\n## Examples:\n* [curl](https://github.com/Microsoft/vcpkg/blob/master/ports/curl/portfile.cmake#L75)\n* [folly](https://github.com/Microsoft/vcpkg/blob/master/ports/folly/portfile.cmake#L15)\n* [z3](https://github.com/Microsoft/vcpkg/blob/master/ports/z3/portfile.cmake#L13)\n\n## Source\n[scripts/cmake/vcpkg\\_add\\_to\\_path.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_add_to_path.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_apply_patches.html","Name":"vcpkg_apply_patches","Source":"# vcpkg_apply_patches\n\n**This function has been deprecated in favor of the `PATCHES` argument to [`vcpkg_from_github()`](vcpkg_from_github.md) et al.**\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_apply_patches.md).\n\nApply a set of patches to a source tree.\n\n```cmake\nvcpkg_apply_patches(\n    SOURCE_PATH <${SOURCE_PATH}>\n    [QUIET]\n    PATCHES <patch1.patch>...\n)\n```\n\n## Source\n[scripts/cmake/vcpkg\\_apply\\_patches.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_apply_patches.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_backup_restore_env_vars.html","Name":"vcpkg_backup_restore_env_vars","Source":"# vcpkg_backup_restore_env_vars\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_backup_restore_env_vars.md).\n\nBackup or restore the environment variables\n\n## Usage:\n```cmake\nvcpkg_backup_env_variables(VARS [<environment-variable>...])\nvcpkg_restore_env_variables(VARS [<environment-variable>...])\n```\n\n### VARS\nThe variables to back up or restore.\nThese are placed in the parent scope, so you must backup and restore\nfrom the same scope.\n\n## Notes\nOne must always call `vcpkg_backup_env_variables` before\n`vcpkg_restore_env_variables`; however, `vcpkg_restore_env_variables`\ndoes not change the back up variables, and so you may call `restore`\nmultiple times for one `backup`.\n\n\n## Source\n[scripts/cmake/vcpkg\\_backup\\_restore\\_env\\_vars.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_backup_restore_env_vars.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_build_cmake.html","Name":"vcpkg_build_cmake","Source":"# vcpkg_build_cmake\n\n**This function has been deprecated in favor of [`vcpkg_cmake_build`](ports/vcpkg-cmake/vcpkg_cmake_build.md) from the vcpkg-cmake port.**\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_build_cmake.md).\n\nBuild a cmake project.\n\n## Usage:\n```cmake\nvcpkg_build_cmake([DISABLE_PARALLEL] [TARGET <target>])\n```\n\n## Parameters:\n### DISABLE_PARALLEL\nThe underlying buildsystem will be instructed to not parallelize\n\n### TARGET\nThe target passed to the cmake build command (`cmake --build . --target <target>`). If not specified, no target will\nbe passed.\n\n### ADD_BIN_TO_PATH\nAdds the appropriate Release and Debug `bin` directories to the path during the build such that executables can run against the in-tree DLLs.\n\n## Notes:\nThis command should be preceded by a call to [`vcpkg_configure_cmake()`](vcpkg_configure_cmake.md).\nYou can use the alias [`vcpkg_install_cmake()`](vcpkg_configure_cmake.md) function if your CMake script supports the\n\"install\" target\n\n## Examples:\n\n* [zlib](https://github.com/Microsoft/vcpkg/blob/master/ports/zlib/portfile.cmake)\n* [cpprestsdk](https://github.com/Microsoft/vcpkg/blob/master/ports/cpprestsdk/portfile.cmake)\n* [poco](https://github.com/Microsoft/vcpkg/blob/master/ports/poco/portfile.cmake)\n* [opencv](https://github.com/Microsoft/vcpkg/blob/master/ports/opencv/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_build\\_cmake.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_build_cmake.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_build_make.html","Name":"vcpkg_build_make","Source":"# vcpkg_build_make\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_build_make.md).\n\nBuild a linux makefile project.\n\n## Usage:\n```cmake\nvcpkg_build_make([BUILD_TARGET <target>]\n                 [INSTALL_TARGET <target>]\n                 [ADD_BIN_TO_PATH]\n                 [ENABLE_INSTALL]\n                 [MAKEFILE <makefileName>]\n                 [LOGFILE_ROOT <logfileroot>]\n                 [DISABLE_PARALLEL]\n                 [SUBPATH <path>])\n```\n\n### BUILD_TARGET\nThe target passed to the make build command (`./make <target>`). If not specified, the 'all' target will\nbe passed.\n\n### INSTALL_TARGET\nThe target passed to the make build command (`./make <target>`) if `ENABLE_INSTALL` is used. Defaults to 'install'.\n\n### ADD_BIN_TO_PATH\nAdds the appropriate Release and Debug `bin\\` directories to the path during the build such that executables can run against the in-tree DLLs.\n\n### ENABLE_INSTALL\nIF the port supports the install target use vcpkg_install_make() instead of vcpkg_build_make()\n\n### MAKEFILE\nSpecifies the Makefile as a relative path from the root of the sources passed to `vcpkg_configure_make()`\n\n### LOGFILE_ROOT\nSpecifies a log file prefix.\n\n### DISABLE_PARALLEL\nThe underlying buildsystem will be instructed to not parallelize\n\n### SUBPATH\nAdditional subdir to invoke make in. Useful if only parts of a port should be built. \n\n## Notes:\nThis command should be preceded by a call to [`vcpkg_configure_make()`](vcpkg_configure_make.md).\nYou can use the alias [`vcpkg_install_make()`](vcpkg_install_make.md) function if your makefile supports the\n\"install\" target\n\n## Examples\n\n* [x264](https://github.com/Microsoft/vcpkg/blob/master/ports/x264/portfile.cmake)\n* [tcl](https://github.com/Microsoft/vcpkg/blob/master/ports/tcl/portfile.cmake)\n* [freexl](https://github.com/Microsoft/vcpkg/blob/master/ports/freexl/portfile.cmake)\n* [libosip2](https://github.com/Microsoft/vcpkg/blob/master/ports/libosip2/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_build\\_make.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_build_make.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_build_msbuild.html","Name":"vcpkg_build_msbuild","Source":"# vcpkg_build_msbuild\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_build_msbuild.md).\n\nBuild a msbuild-based project. Deprecated in favor of `vcpkg_install_msbuild()`.\n\n## Usage\n```cmake\nvcpkg_build_msbuild(\n    PROJECT_PATH <${SOURCE_PATH}/port.sln>\n    [RELEASE_CONFIGURATION <Release>]\n    [DEBUG_CONFIGURATION <Debug>]\n    [TARGET <Build>]\n    [TARGET_PLATFORM_VERSION <10.0.15063.0>]\n    [PLATFORM <${TRIPLET_SYSTEM_ARCH}>]\n    [PLATFORM_TOOLSET <${VCPKG_PLATFORM_TOOLSET}>]\n    [OPTIONS </p:ZLIB_INCLUDE_PATH=X>...]\n    [OPTIONS_RELEASE </p:ZLIB_LIB=X>...]\n    [OPTIONS_DEBUG </p:ZLIB_LIB=X>...]\n    [USE_VCPKG_INTEGRATION]\n)\n```\n\n## Parameters\n### USE_VCPKG_INTEGRATION\nApply the normal `integrate install` integration for building the project.\n\nBy default, projects built with this command will not automatically link libraries or have header paths set.\n\n### PROJECT_PATH\nThe path to the solution (`.sln`) or project (`.vcxproj`) file.\n\n### RELEASE_CONFIGURATION\nThe configuration (``/p:Configuration`` msbuild parameter) used for Release builds.\n\n### DEBUG_CONFIGURATION\nThe configuration (``/p:Configuration`` msbuild parameter)\nused for Debug builds.\n\n### TARGET_PLATFORM_VERSION\nThe WindowsTargetPlatformVersion (``/p:WindowsTargetPlatformVersion`` msbuild parameter)\n\n### TARGET\nThe MSBuild target to build. (``/t:<TARGET>``)\n\n### PLATFORM\nThe platform (``/p:Platform`` msbuild parameter) used for the build.\n\n### PLATFORM_TOOLSET\nThe platform toolset (``/p:PlatformToolset`` msbuild parameter) used for the build.\n\n### OPTIONS\nAdditional options passed to msbuild for all builds.\n\n### OPTIONS_RELEASE\nAdditional options passed to msbuild for Release builds. These are in addition to `OPTIONS`.\n\n### OPTIONS_DEBUG\nAdditional options passed to msbuild for Debug builds. These are in addition to `OPTIONS`.\n\n## Examples\n\n* [chakracore](https://github.com/Microsoft/vcpkg/blob/master/ports/chakracore/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_build\\_msbuild.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_build_msbuild.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_build_ninja.html","Name":"vcpkg_build_ninja","Source":"# vcpkg_build_ninja\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_build_ninja.md).\n\nBuild a ninja project\n\n## Usage:\n```cmake\nvcpkg_build_ninja(\n    [TARGETS <target>...]\n)\n```\n\n## Parameters:\n### TARGETS\nOnly build the specified targets.\n\n## Source\n[scripts/cmake/vcpkg\\_build\\_ninja.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_build_ninja.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_build_nmake.html","Name":"vcpkg_build_nmake","Source":"# vcpkg_build_nmake\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_build_nmake.md).\n\nBuild a msvc makefile project.\n\n## Usage:\n```cmake\nvcpkg_build_nmake(\n    SOURCE_PATH <${SOURCE_PATH}>\n    [NO_DEBUG]\n    [ENABLE_INSTALL]\n    [TARGET <all>]\n    [PROJECT_SUBPATH <${SUBPATH}>]\n    [PROJECT_NAME <${MAKEFILE_NAME}>]\n    [PRERUN_SHELL <${SHELL_PATH}>]\n    [PRERUN_SHELL_DEBUG <${SHELL_PATH}>]\n    [PRERUN_SHELL_RELEASE <${SHELL_PATH}>]\n    [OPTIONS <-DUSE_THIS_IN_ALL_BUILDS=1>...]\n    [OPTIONS_RELEASE <-DOPTIMIZE=1>...]\n    [OPTIONS_DEBUG <-DDEBUGGABLE=1>...]\n    [TARGET <target>])\n```\n\n## Parameters\n### SOURCE_PATH\nSpecifies the directory containing the source files.\nBy convention, this is usually set in the portfile as the variable `SOURCE_PATH`.\n\n### PROJECT_SUBPATH\nSpecifies the sub directory containing the `makefile.vc`/`makefile.mak`/`makefile.msvc` or other msvc makefile.\n\n### PROJECT_NAME\nSpecifies the name of msvc makefile name.\nDefault is `makefile.vc`\n\n### ENABLE_INSTALL\nInstall binaries after build.\n\n### PRERUN_SHELL\nScript that needs to be called before build\n\n### PRERUN_SHELL_DEBUG\nScript that needs to be called before debug build\n\n### PRERUN_SHELL_RELEASE\nScript that needs to be called before release build\n\n### OPTIONS\nAdditional options passed to generate during the generation.\n\n### OPTIONS_RELEASE\nAdditional options passed to generate during the Release generation. These are in addition to `OPTIONS`.\n\n### OPTIONS_DEBUG\nAdditional options passed to generate during the Debug generation. These are in addition to `OPTIONS`.\n\n### TARGET\nThe target passed to the nmake build command (`nmake/nmake install`). If not specified, no target will\nbe passed.\n\n## Notes:\nYou can use the alias [`vcpkg_install_nmake()`](vcpkg_install_nmake.md) function if your makefile supports the\n\"install\" target\n\n## Examples\n\n* [tcl](https://github.com/Microsoft/vcpkg/blob/master/ports/tcl/portfile.cmake)\n* [freexl](https://github.com/Microsoft/vcpkg/blob/master/ports/freexl/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_build\\_nmake.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_build_nmake.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_build_qmake.html","Name":"vcpkg_build_qmake","Source":"# vcpkg_build_qmake\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_build_qmake.md).\n\nBuild a qmake-based project, previously configured using vcpkg_configure_qmake.\n\n```cmake\nvcpkg_build_qmake()\n```\n\n## Source\n[scripts/cmake/vcpkg\\_build\\_qmake.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_build_qmake.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_buildpath_length_warning.html","Name":"vcpkg_buildpath_length_warning","Source":"# vcpkg_buildpath_length_warning\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_buildpath_length_warning.md).\n\nWarns the user if their vcpkg installation path might be too long for the package they're installing.\n\n```cmake\nvcpkg_buildpath_length_warning(<N>)\n```\n\n`vcpkg_buildpath_length_warning` warns the user if the number of bytes in the\npath to `buildtrees` is bigger than `N`. Note that this is simply a warning,\nand isn't relied on for correctness.\n\n## Source\n[scripts/cmake/vcpkg\\_buildpath\\_length\\_warning.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_buildpath_length_warning.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_check_features.html","Name":"vcpkg_check_features","Source":"# vcpkg_check_features\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_check_features.md).\nCheck if one or more features are a part of a package installation.\n\n```cmake\nvcpkg_check_features(\n    OUT_FEATURE_OPTIONS <out-var>\n    [PREFIX <prefix>]\n    [FEATURES\n        [<feature-name> <feature-var>]...\n        ]\n    [INVERTED_FEATURES\n        [<feature-name> <feature-var>]...\n        ]\n)\n```\n\nThe `<out-var>` should be set to `FEATURE_OPTIONS` by convention.\n\n`vcpkg_check_features()` will:\n\n- for each `<feature-name>` passed in `FEATURES`:\n    - if the feature is set, add `-D<feature-var>=ON` to `<out-var>`,\n      and set `<prefix>_<feature-var>` to ON.\n    - if the feature is not set, add `-D<feature-var>=OFF` to `<out-var>`,\n      and set `<prefix>_<feature-var>` to OFF.\n- for each `<feature-name>` passed in `INVERTED_FEATURES`:\n    - if the feature is set, add `-D<feature-var>=OFF` to `<out-var>`,\n      and set `<prefix>_<feature-var>` to OFF.\n    - if the feature is not set, add `-D<feature-var>=ON` to `<out-var>`,\n      and set `<prefix>_<feature-var>` to ON.\n\nIf `<prefix>` is not passed, then the feature vars set are simply `<feature-var>`,\nnot `_<feature-var>`.\n\nIf `INVERTED_FEATURES` is not passed, then the `FEATURES` keyword is optional.\nThis behavior is deprecated.\n\nIf the same `<feature-var>` is passed multiple times,\nthen `vcpkg_check_features` will cause a fatal error,\nsince that is a bug.\n\n## Examples\n\n### Example 1: Regular features\n\n```cmake\n$ ./vcpkg install mimalloc[asm,secure]\n\n# ports/mimalloc/portfile.cmake\nvcpkg_check_features(OUT_FEATURE_OPTIONS FEATURE_OPTIONS\n    FEATURES\n        asm       MI_SEE_ASM\n        override  MI_OVERRIDE\n        secure    MI_SECURE\n)\n\nvcpkg_cmake_configure(\n    SOURCE_PATH ${SOURCE_PATH}\n    OPTIONS\n        # Expands to \"-DMI_SEE_ASM=ON;-DMI_OVERRIDE=OFF;-DMI_SECURE=ON\"\n        ${FEATURE_OPTIONS}\n)\n```\n\n### Example 2: Inverted features\n\n```cmake\n$ ./vcpkg install cpprestsdk[websockets]\n\n# ports/cpprestsdk/portfile.cmake\nvcpkg_check_features(\n    INVERTED_FEATURES\n        brotli      CPPREST_EXCLUDE_BROTLI\n        websockets  CPPREST_EXCLUDE_WEBSOCKETS\n)\n\nvcpkg_cmake_configure(\n    SOURCE_PATH ${SOURCE_PATH}\n    OPTIONS\n        # Expands to \"-DCPPREST_EXCLUDE_BROTLI=ON;-DCPPREST_EXCLUDE_WEBSOCKETS=OFF\"\n        ${FEATURE_OPTIONS}\n)\n```\n\n### Example 3: Set multiple options for same feature\n\n```cmake\n$ ./vcpkg install pcl[cuda]\n\n# ports/pcl/portfile.cmake\nvcpkg_check_features(\n    FEATURES\n        cuda  WITH_CUDA\n        cuda  BUILD_CUDA\n        cuda  BUILD_GPU\n)\n\nvcpkg_cmake_configure(\n    SOURCE_PATH ${SOURCE_PATH}\n    OPTIONS\n        # Expands to \"-DWITH_CUDA=ON;-DBUILD_CUDA=ON;-DBUILD_GPU=ON\"\n        ${FEATURE_OPTIONS}\n)\n```\n\n### Example 4: Use regular and inverted features\n\n```cmake\n$ ./vcpkg install rocksdb[tbb]\n\n# ports/rocksdb/portfile.cmake\nvcpkg_check_features(\n    FEATURES\n        tbb   WITH_TBB\n    INVERTED_FEATURES\n        tbb   ROCKSDB_IGNORE_PACKAGE_TBB\n)\n\nvcpkg_cmake_configure(\n    SOURCE_PATH ${SOURCE_PATH}\n    OPTIONS\n        # Expands to \"-DWITH_TBB=ON;-DROCKSDB_IGNORE_PACKAGE_TBB=OFF\"\n        ${FEATURE_OPTIONS}\n)\n```\n\n## Examples in portfiles\n\n* [cpprestsdk](https://github.com/microsoft/vcpkg/blob/master/ports/cpprestsdk/portfile.cmake)\n* [pcl](https://github.com/microsoft/vcpkg/blob/master/ports/pcl/portfile.cmake)\n* [rocksdb](https://github.com/microsoft/vcpkg/blob/master/ports/rocksdb/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_check\\_features.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_check_features.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_check_linkage.html","Name":"vcpkg_check_linkage","Source":"# vcpkg_check_linkage\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_check_linkage.md).\n\nAsserts the available library and CRT linkage options for the port.\n\n## Usage\n```cmake\nvcpkg_check_linkage(\n    [ONLY_STATIC_LIBRARY | ONLY_DYNAMIC_LIBRARY]\n    [ONLY_STATIC_CRT | ONLY_DYNAMIC_CRT]\n)\n```\n\n## Parameters\n### ONLY_STATIC_LIBRARY\nIndicates that this port can only be built with static library linkage.\n\nNote: If the user requested a dynamic build ONLY_STATIC_LIBRARY will result in a note being printed, not a fatal error.\n\n### ONLY_DYNAMIC_LIBRARY\nIndicates that this port can only be built with dynamic/shared library linkage.\n\n### ONLY_STATIC_CRT\nIndicates that this port can only be built with static CRT linkage.\n\n### ONLY_DYNAMIC_CRT\nIndicates that this port can only be built with dynamic/shared CRT linkage.\n\n## Notes\nThis command will either alter the settings for `VCPKG_LIBRARY_LINKAGE` or fail, depending on what was requested by the user versus what the library supports.\n\n## Examples\n\n* [abseil](https://github.com/Microsoft/vcpkg/blob/master/ports/abseil/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_check\\_linkage.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_check_linkage.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_clean_executables_in_bin.html","Name":"vcpkg_clean_executables_in_bin","Source":"# vcpkg_clean_executables_in_bin\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_clean_executables_in_bin.md).\n\nRemove specified executables found in `${CURRENT_PACKAGES_DIR}/bin` and `${CURRENT_PACKAGES_DIR}/debug/bin`. If, after all specified executables have been removed, and the `bin` and `debug/bin` directories are empty, then also delete `bin` and `debug/bin` directories.\n\n## Usage\n```cmake\nvcpkg_clean_executables_in_bin(\n    FILE_NAMES <file1>...\n)\n```\n\n## Parameters\n### FILE_NAMES\nA list of executable filenames without extension.\n\n## Notes\nGenerally, there is no need to call this function manually. Instead, pass an extra `AUTO_CLEAN` argument when calling `vcpkg_copy_tools`.\n\n## Examples\n* [czmq](https://github.com/microsoft/vcpkg/blob/master/ports/czmq/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_clean\\_executables\\_in\\_bin.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_clean_executables_in_bin.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_clean_msbuild.html","Name":"vcpkg_clean_msbuild","Source":"# vcpkg_clean_msbuild\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_clean_msbuild.md).\n\nClean intermediate files generated by `vcpkg_install_msbuild()`.\n\n## Usage\n```cmake\nvcpkg_clean_msbuild()\n```\n\n## Examples\n\n* [python3](https://github.com/Microsoft/vcpkg/blob/master/ports/python3/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_clean\\_msbuild.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_clean_msbuild.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_common_definitions.html","Name":"vcpkg_common_definitions","Source":"# vcpkg_common_definitions\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_common_definitions.md).\n\nThis file defines the following variables which are commonly needed or used in portfiles:\n\n```cmake\nVCPKG_TARGET_IS_<target>                 with <target> being one of the following: WINDOWS, UWP, MINGW, LINUX, OSX, ANDROID, FREEBSD, OPENBSD. only defined if <target>\nVCPKG_HOST_IS_<host>                     with <host> being one of the following: WINDOWS, LINUX, OSX, FREEBSD, OPENBSD. only defined if <host>\nVCPKG_HOST_PATH_SEPARATOR                Host specific path separator (USAGE: \"<something>${VCPKG_HOST_PATH_SEPARATOR}<something>\"; only use and pass variables with VCPKG_HOST_PATH_SEPARATOR within \"\")\nVCPKG_HOST_EXECUTABLE_SUFFIX             executable suffix of the host\nVCPKG_TARGET_EXECUTABLE_SUFFIX           executable suffix of the target\nVCPKG_HOST_BUNDLE_SUFFIX                 bundle suffix of the host\nVCPKG_TARGET_BUNDLE_SUFFIX               bundle suffix of the target\nVCPKG_TARGET_STATIC_LIBRARY_PREFIX       static library prefix for target (same as CMAKE_STATIC_LIBRARY_PREFIX)\nVCPKG_TARGET_STATIC_LIBRARY_SUFFIX       static library suffix for target (same as CMAKE_STATIC_LIBRARY_SUFFIX)\nVCPKG_TARGET_SHARED_LIBRARY_PREFIX       shared library prefix for target (same as CMAKE_SHARED_LIBRARY_PREFIX)\nVCPKG_TARGET_SHARED_LIBRARY_SUFFIX       shared library suffix for target (same as CMAKE_SHARED_LIBRARY_SUFFIX)\nVCPKG_TARGET_IMPORT_LIBRARY_PREFIX       import library prefix for target (same as CMAKE_IMPORT_LIBRARY_PREFIX)\nVCPKG_TARGET_IMPORT_LIBRARY_SUFFIX       import library suffix for target (same as CMAKE_IMPORT_LIBRARY_SUFFIX)\nVCPKG_FIND_LIBRARY_PREFIXES              target dependent prefixes used for find_library calls in portfiles\nVCPKG_FIND_LIBRARY_SUFFIXES              target dependent suffixes used for find_library calls in portfiles\nVCPKG_SYSTEM_LIBRARIES                   list of libraries are provide by the toolchain and are not managed by vcpkg\nTARGET_TRIPLET                           the name of the current triplet to build for\nCURRENT_INSTALLED_DIR                    the absolute path to the installed files for the current triplet\nHOST_TRIPLET                             the name of the triplet corresponding to the host\nCURRENT_HOST_INSTALLED_DIR               the absolute path to the installed files for the host triplet\nVCPKG_CROSSCOMPILING                     Whether vcpkg is cross-compiling: in other words, whether TARGET_TRIPLET and HOST_TRIPLET are different\n```\n\nCMAKE_STATIC_LIBRARY_(PREFIX|SUFFIX), CMAKE_SHARED_LIBRARY_(PREFIX|SUFFIX) and CMAKE_IMPORT_LIBRARY_(PREFIX|SUFFIX) are defined for the target\nFurthermore the variables CMAKE_FIND_LIBRARY_(PREFIXES|SUFFIXES) are also defined for the target so that\nportfiles are able to use find_library calls to discover dependent libraries within the current triplet for ports.\n\n## Source\n[scripts/cmake/vcpkg\\_common\\_definitions.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_common_definitions.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_configure_cmake.html","Name":"vcpkg_configure_cmake","Source":"# vcpkg_configure_cmake\n\n**This function has been deprecated in favor of [`vcpkg_cmake_configure`](ports/vcpkg-cmake/vcpkg_cmake_configure.md) from the vcpkg-cmake port.**\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_configure_cmake.md).\n\nConfigure CMake for Debug and Release builds of a project.\n\n## Usage\n```cmake\nvcpkg_configure_cmake(\n    SOURCE_PATH <${SOURCE_PATH}>\n    [PREFER_NINJA]\n    [DISABLE_PARALLEL_CONFIGURE]\n    [NO_CHARSET_FLAG]\n    [GENERATOR <\"NMake Makefiles\">]\n    [OPTIONS <-DUSE_THIS_IN_ALL_BUILDS=1>...]\n    [OPTIONS_RELEASE <-DOPTIMIZE=1>...]\n    [OPTIONS_DEBUG <-DDEBUGGABLE=1>...]\n    [MAYBE_UNUSED_VARIABLES <OPTION_NAME>...]\n)\n```\n\n## Parameters\n### SOURCE_PATH\nSpecifies the directory containing the `CMakeLists.txt`.\nBy convention, this is usually set in the portfile as the variable `SOURCE_PATH`.\n\n### PREFER_NINJA\nIndicates that, when available, Vcpkg should use Ninja to perform the build.\nThis should be specified unless the port is known to not work under Ninja.\n\n### DISABLE_PARALLEL_CONFIGURE\nDisables running the CMake configure step in parallel.\nThis is needed for libraries which write back into their source directory during configure.\n\nThis also disables CMAKE_DISABLE_SOURCE_CHANGES.\n\n### NO_CHARSET_FLAG\nDisables passing `utf-8` as the default character set to `CMAKE_C_FLAGS` and `CMAKE_CXX_FLAGS`.\n\nThis is needed for libraries that set their own source code's character set.\n\n### GENERATOR\nSpecifies the precise generator to use.\n\nThis is useful if some project-specific buildsystem has been wrapped in a cmake script that won't perform an actual build.\nIf used for this purpose, it should be set to `\"NMake Makefiles\"`.\n\n### OPTIONS\nAdditional options passed to CMake during the configuration.\n\n### OPTIONS_RELEASE\nAdditional options passed to CMake during the Release configuration. These are in addition to `OPTIONS`.\n\n### OPTIONS_DEBUG\nAdditional options passed to CMake during the Debug configuration. These are in addition to `OPTIONS`.\n\n### MAYBE_UNUSED_VARIABLES\nAny CMake variables which are explicitly passed in, but which may not be used on all platforms.\nFor example:\n```cmake\nvcpkg_cmake_configure(\n    ...\n    OPTIONS\n        -DBUILD_EXAMPLE=OFF\n    ...\n    MAYBE_UNUSED_VARIABLES\n        BUILD_EXAMPLE\n)\n```\n\n### LOGNAME\nName of the log to write the output of the configure call to.\n\n## Notes\nThis command supplies many common arguments to CMake. To see the full list, examine the source.\n\n## Examples\n\n* [zlib](https://github.com/Microsoft/vcpkg/blob/master/ports/zlib/portfile.cmake)\n* [cpprestsdk](https://github.com/Microsoft/vcpkg/blob/master/ports/cpprestsdk/portfile.cmake)\n* [poco](https://github.com/Microsoft/vcpkg/blob/master/ports/poco/portfile.cmake)\n* [opencv](https://github.com/Microsoft/vcpkg/blob/master/ports/opencv/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_configure\\_cmake.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_configure_cmake.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_configure_gn.html","Name":"vcpkg_configure_gn","Source":"# vcpkg_configure_gn\n\n**This function has been deprecated in favor of [`vcpkg_gn_configure`](ports/vcpkg-gn/vcpkg_gn_configure.md) from the vcpkg-gn port.**\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_configure_gn.md).\n\nGenerate Ninja (GN) targets\n\n## Usage:\n```cmake\nvcpkg_configure_gn(\n    SOURCE_PATH <SOURCE_PATH>\n    [OPTIONS <OPTIONS>]\n    [OPTIONS_DEBUG <OPTIONS_DEBUG>]\n    [OPTIONS_RELEASE <OPTIONS_RELEASE>]\n)\n```\n\n## Parameters:\n### SOURCE_PATH (required)\nThe path to the GN project.\n\n### OPTIONS\nOptions to be passed to both the debug and release targets.\nNote: Must be provided as a space-separated string.\n\n### OPTIONS_DEBUG (space-separated string)\nOptions to be passed to the debug target.\n\n### OPTIONS_RELEASE (space-separated string)\nOptions to be passed to the release target.\n\n## Source\n[scripts/cmake/vcpkg\\_configure\\_gn.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_configure_gn.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_configure_make.html","Name":"vcpkg_configure_make","Source":"# vcpkg_configure_make\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_configure_make.md).\n\nConfigure configure for Debug and Release builds of a project.\n\n## Usage\n```cmake\nvcpkg_configure_make(\n    SOURCE_PATH <${SOURCE_PATH}>\n    [AUTOCONFIG]\n    [USE_WRAPPERS]\n    [DETERMINE_BUILD_TRIPLET]\n    [BUILD_TRIPLET \"--host=x64 --build=i686-unknown-pc\"]\n    [NO_ADDITIONAL_PATHS]\n    [CONFIG_DEPENDENT_ENVIRONMENT <SOME_VAR>...]\n    [CONFIGURE_ENVIRONMENT_VARIABLES <SOME_ENVVAR>...]\n    [ADD_BIN_TO_PATH]\n    [DISABLE_VERBOSE_FLAGS]\n    [NO_DEBUG]\n    [SKIP_CONFIGURE]\n    [PROJECT_SUBPATH <${PROJ_SUBPATH}>]\n    [PRERUN_SHELL <${SHELL_PATH}>]\n    [OPTIONS <-DUSE_THIS_IN_ALL_BUILDS=1>...]\n    [OPTIONS_RELEASE <-DOPTIMIZE=1>...]\n    [OPTIONS_DEBUG <-DDEBUGGABLE=1>...]\n)\n```\n\n## Parameters\n### SOURCE_PATH\nSpecifies the directory containing the `configure`/`configure.ac`.\nBy convention, this is usually set in the portfile as the variable `SOURCE_PATH`.\n\n### PROJECT_SUBPATH\nSpecifies the directory containing the ``configure`/`configure.ac`.\nBy convention, this is usually set in the portfile as the variable `SOURCE_PATH`.\n\n### SKIP_CONFIGURE\nSkip configure process\n\n### USE_WRAPPERS\nUse autotools ar-lib and compile wrappers (only applies to windows cl and lib)\n\n### BUILD_TRIPLET\nUsed to pass custom --build/--target/--host to configure. Can be globally overwritten by VCPKG_MAKE_BUILD_TRIPLET\n\n### DETERMINE_BUILD_TRIPLET\nFor ports having a configure script following the autotools rules for selecting the triplet\n\n### NO_ADDITIONAL_PATHS\nDon't pass any additional paths except for --prefix to the configure call\n\n### AUTOCONFIG\nNeed to use autoconfig to generate configure file.\n\n### PRERUN_SHELL\nScript that needs to be called before configuration (do not use for batch files which simply call autoconf or configure)\n\n### ADD_BIN_TO_PATH\nAdds the appropriate Release and Debug `bin\\` directories to the path during configure such that executables can run against the in-tree DLLs.\n\n### DISABLE_VERBOSE_FLAGS\nDo not pass '--disable-silent-rules --verbose' to configure.\n\n### OPTIONS\nAdditional options passed to configure during the configuration.\n\n### OPTIONS_RELEASE\nAdditional options passed to configure during the Release configuration. These are in addition to `OPTIONS`.\n\n### OPTIONS_DEBUG\nAdditional options passed to configure during the Debug configuration. These are in addition to `OPTIONS`.\n\n### CONFIG_DEPENDENT_ENVIRONMENT\nList of additional configuration dependent environment variables to set. \nPass SOMEVAR to set the environment and have SOMEVAR_(DEBUG|RELEASE) set in the portfile to the appropriate values\nGeneral environment variables can be set from within the portfile itself. \n\n### CONFIGURE_ENVIRONMENT_VARIABLES\nList of additional environment variables to pass via the configure call. \n\n## Notes\nThis command supplies many common arguments to configure. To see the full list, examine the source.\n\n## Examples\n\n* [x264](https://github.com/Microsoft/vcpkg/blob/master/ports/x264/portfile.cmake)\n* [tcl](https://github.com/Microsoft/vcpkg/blob/master/ports/tcl/portfile.cmake)\n* [freexl](https://github.com/Microsoft/vcpkg/blob/master/ports/freexl/portfile.cmake)\n* [libosip2](https://github.com/Microsoft/vcpkg/blob/master/ports/libosip2/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_configure\\_make.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_configure_make.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_configure_meson.html","Name":"vcpkg_configure_meson","Source":"# vcpkg_configure_meson\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_configure_meson.md).\n\nConfigure Meson for Debug and Release builds of a project.\n\n## Usage\n```cmake\nvcpkg_configure_meson(\n    SOURCE_PATH <${SOURCE_PATH}>\n    [NO_PKG_CONFIG]\n    [OPTIONS <-DUSE_THIS_IN_ALL_BUILDS=1>...]\n    [OPTIONS_RELEASE <-DOPTIMIZE=1>...]\n    [OPTIONS_DEBUG <-DDEBUGGABLE=1>...]\n)\n```\n\n## Parameters\n### SOURCE_PATH\nSpecifies the directory containing the `meson.build`.\nBy convention, this is usually set in the portfile as the variable `SOURCE_PATH`.\n\n### OPTIONS\nAdditional options passed to Meson during the configuration.\n\n### OPTIONS_RELEASE\nAdditional options passed to Meson during the Release configuration. These are in addition to `OPTIONS`.\n\n### OPTIONS_DEBUG\nAdditional options passed to Meson during the Debug configuration. These are in addition to `OPTIONS`.\n\n### NO_PKG_CONFIG\nDisable pkg-config setup \n\n## Notes\nThis command supplies many common arguments to Meson. To see the full list, examine the source.\n\n## Examples\n\n* [fribidi](https://github.com/Microsoft/vcpkg/blob/master/ports/fribidi/portfile.cmake)\n* [libepoxy](https://github.com/Microsoft/vcpkg/blob/master/ports/libepoxy/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_configure\\_meson.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_configure_meson.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_configure_qmake.html","Name":"vcpkg_configure_qmake","Source":"# vcpkg_configure_qmake\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_configure_qmake.md).\n\nConfigure a qmake-based project.\n\n```cmake\nvcpkg_configure_qmake(\n    SOURCE_PATH <pro_file_path>\n    [OPTIONS arg1 [arg2 ...]]\n    [OPTIONS_RELEASE arg1 [arg2 ...]]\n    [OPTIONS_DEBUG arg1 [arg2 ...]]\n    [BUILD_OPTIONS arg1 [arg2 ...]]\n    [BUILD_OPTIONS_RELEASE arg1 [arg2 ...]]\n    [BUILD_OPTIONS_DEBUG arg1 [arg2 ...]]\n)\n```\n\n### SOURCE_PATH\nThe path to the *.pro qmake project file.\n\n### OPTIONS, OPTIONS\\_RELEASE, OPTIONS\\_DEBUG\nThe options passed to qmake to the configure step.\n\n### BUILD\\_OPTIONS, BUILD\\_OPTIONS\\_RELEASE, BUILD\\_OPTIONS\\_DEBUG\nThe options passed to qmake to the build step.\n\n## Source\n[scripts/cmake/vcpkg\\_configure\\_qmake.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_configure_qmake.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_copy_pdbs.html","Name":"vcpkg_copy_pdbs","Source":"# vcpkg_copy_pdbs\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_copy_pdbs.md).\n\nAutomatically locate pdbs in the build tree and copy them adjacent to all DLLs.\n\n```cmake\nvcpkg_copy_pdbs(\n    [BUILD_PATHS <glob>...])\n```\n\nThe `<glob>`s are patterns which will be passed to `file(GLOB_RECURSE)`,\nfor locating DLLs. It defaults to using:\n\n- `${CURRENT_PACKAGES_DIR}/bin/*.dll`\n- `${CURRENT_PACKAGES_DIR}/debug/bin/*.dll`\n\nsince that is generally where DLLs are located.\n\n## Notes\nThis command should always be called by portfiles after they have finished rearranging the binary output.\n\n## Examples\n\n* [zlib](https://github.com/Microsoft/vcpkg/blob/master/ports/zlib/portfile.cmake)\n* [cpprestsdk](https://github.com/Microsoft/vcpkg/blob/master/ports/cpprestsdk/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_copy\\_pdbs.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_copy_pdbs.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_copy_tool_dependencies.html","Name":"vcpkg_copy_tool_dependencies","Source":"# vcpkg_copy_tool_dependencies\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_copy_tool_dependencies.md).\n\nCopy all DLL dependencies of built tools into the tool folder.\n\n## Usage\n```cmake\nvcpkg_copy_tool_dependencies(<${CURRENT_PACKAGES_DIR}/tools/${PORT}>)\n```\n## Parameters\nThe path to the directory containing the tools.\n\n## Notes\nThis command should always be called by portfiles after they have finished rearranging the binary output, if they have any tools.\n\n## Examples\n\n* [glib](https://github.com/Microsoft/vcpkg/blob/master/ports/glib/portfile.cmake)\n* [fltk](https://github.com/Microsoft/vcpkg/blob/master/ports/fltk/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_copy\\_tool\\_dependencies.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_copy_tool_dependencies.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_copy_tools.html","Name":"vcpkg_copy_tools","Source":"# vcpkg_copy_tools\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_copy_tools.md).\n\nCopy tools and all their DLL dependencies into the `tools` folder.\n\n## Usage\n```cmake\nvcpkg_copy_tools(\n    TOOL_NAMES <tool1>...\n    [SEARCH_DIR <${CURRENT_PACKAGES_DIR}/bin>]\n    [DESTINATION <${CURRENT_PACKAGES_DIR}/tools/${PORT}>]\n    [AUTO_CLEAN]\n)\n```\n## Parameters\n### TOOL_NAMES\nA list of tool filenames without extension.\n\n### SEARCH_DIR\nThe path to the directory containing the tools. This will be set to `${CURRENT_PACKAGES_DIR}/bin` if omitted.\n\n### DESTINATION\nDestination to copy the tools to. This will be set to `${CURRENT_PACKAGES_DIR}/tools/${PORT}` if omitted.\n\n### AUTO_CLEAN\nAuto clean the copied executables from `${CURRENT_PACKAGES_DIR}/bin` and `${CURRENT_PACKAGES_DIR}/debug/bin`.\n\n## Examples\n\n* [cpuinfo](https://github.com/microsoft/vcpkg/blob/master/ports/cpuinfo/portfile.cmake)\n* [nanomsg](https://github.com/microsoft/vcpkg/blob/master/ports/nanomsg/portfile.cmake)\n* [uriparser](https://github.com/microsoft/vcpkg/blob/master/ports/uriparser/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_copy\\_tools.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_copy_tools.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_download_distfile.html","Name":"vcpkg_download_distfile","Source":"# vcpkg_download_distfile\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_download_distfile.md).\n\nDownload and cache a file needed for this port.\n\nThis helper should always be used instead of CMake's built-in `file(DOWNLOAD)` command.\n\n## Usage\n```cmake\nvcpkg_download_distfile(\n    <OUT_VARIABLE>\n    URLS <http://mainUrl> <http://mirror1>...\n    FILENAME <output.zip>\n    SHA512 <5981de...>\n    [ALWAYS_REDOWNLOAD]\n)\n```\n## Parameters\n### OUT_VARIABLE\nThis variable will be set to the full path to the downloaded file. This can then immediately be passed in to [`vcpkg_extract_source_archive`](vcpkg_extract_source_archive.md) for sources.\n\n### URLS\nA list of URLs to be consulted. They will be tried in order until one of the downloaded files successfully matches the SHA512 given.\n\n### FILENAME\nThe local name for the file. Files are shared between ports, so the file may need to be renamed to make it clearly attributed to this port and avoid conflicts.\n\n### SHA512\nThe expected hash for the file.\n\nIf this doesn't match the downloaded version, the build will be terminated with a message describing the mismatch.\n\n### QUIET\nSuppress output on cache hit\n\n### SKIP_SHA512\nSkip SHA512 hash check for file.\n\nThis switch is only valid when building with the `--head` command line flag.\n\n### ALWAYS_REDOWNLOAD\nAvoid caching; this is a REST call or otherwise unstable.\n\nRequires `SKIP_SHA512`.\n\n### HEADERS\nA list of headers to append to the download request. This can be used for authentication during a download.\n\nHeaders should be specified as \"<header-name>: <header-value>\".\n\n## Notes\nThe helper [`vcpkg_from_github`](vcpkg_from_github.md) should be used for downloading from GitHub projects.\n\n## Examples\n\n* [apr](https://github.com/Microsoft/vcpkg/blob/master/ports/apr/portfile.cmake)\n* [fontconfig](https://github.com/Microsoft/vcpkg/blob/master/ports/fontconfig/portfile.cmake)\n* [freetype](https://github.com/Microsoft/vcpkg/blob/master/ports/freetype/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_download\\_distfile.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_download_distfile.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_execute_build_process.html","Name":"vcpkg_execute_build_process","Source":"# vcpkg_execute_build_process\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_execute_build_process.md).\n\nExecute a required build process\n\n## Usage\n```cmake\nvcpkg_execute_build_process(\n    COMMAND <cmd> [<args>...]\n    [NO_PARALLEL_COMMAND <cmd> [<args>...]]\n    WORKING_DIRECTORY </path/to/dir>\n    LOGNAME <log_name>\n)\n```\n## Parameters\n### COMMAND\nThe command to be executed, along with its arguments.\n\n### NO_PARALLEL_COMMAND\nOptional parameter which specifies a non-parallel command to attempt if a\nfailure potentially due to parallelism is detected.\n\n### WORKING_DIRECTORY\nThe directory to execute the command in.\n\n### LOGNAME\nThe prefix to use for the log files.\n\nThis should be a unique name for different triplets so that the logs don't\nconflict when building multiple at once.\n\n## Examples\n\n* [icu](https://github.com/Microsoft/vcpkg/blob/master/ports/icu/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_execute\\_build\\_process.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_execute_build_process.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_execute_in_download_mode.html","Name":"vcpkg_execute_in_download_mode","Source":"# vcpkg_execute_in_download_mode\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_execute_in_download_mode.md).\n\nExecute a process even in download mode.\n\n## Usage\n```cmake\nvcpkg_execute_in_download_mode(\n    ...\n)\n```\n\nThe signature of this function is identical to `execute_process()`.\n\nSee [`execute_process()`] for more details.\n\n[`execute_process()`]: https://cmake.org/cmake/help/latest/command/execute_process.html\n\n## Source\n[scripts/cmake/vcpkg\\_execute\\_in\\_download\\_mode.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_execute_in_download_mode.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_execute_required_process.html","Name":"vcpkg_execute_required_process","Source":"# vcpkg_execute_required_process\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_execute_required_process.md).\n\nExecute a process with logging and fail the build if the command fails.\n\n## Usage\n```cmake\nvcpkg_execute_required_process(\n    COMMAND <${PERL}> [<arguments>...]\n    WORKING_DIRECTORY <${CURRENT_BUILDTREES_DIR}/${TARGET_TRIPLET}-dbg>\n    LOGNAME <build-${TARGET_TRIPLET}-dbg>\n    [TIMEOUT <seconds>]\n    [OUTPUT_VARIABLE <var>]\n    [ERROR_VARIABLE <var>]\n)\n```\n## Parameters\n### ALLOW_IN_DOWNLOAD_MODE\nAllows the command to execute in Download Mode.\n[See execute_process() override](../../scripts/cmake/execute_process.cmake).\n\n### COMMAND\nThe command to be executed, along with its arguments.\n\n### WORKING_DIRECTORY\nThe directory to execute the command in.\n\n### LOGNAME\nThe prefix to use for the log files.\n\n### TIMEOUT\nOptional timeout after which to terminate the command.\n\n### OUTPUT_VARIABLE\nOptional variable to receive stdout of the command.\n\n### ERROR_VARIABLE\nOptional variable to receive stderr of the command.\n\nThis should be a unique name for different triplets so that the logs don't conflict when building multiple at once.\n\n## Examples\n\n* [ffmpeg](https://github.com/Microsoft/vcpkg/blob/master/ports/ffmpeg/portfile.cmake)\n* [openssl](https://github.com/Microsoft/vcpkg/blob/master/ports/openssl/portfile.cmake)\n* [boost](https://github.com/Microsoft/vcpkg/blob/master/ports/boost/portfile.cmake)\n* [qt5](https://github.com/Microsoft/vcpkg/blob/master/ports/qt5/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_execute\\_required\\_process.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_execute_required_process.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_execute_required_process_repeat.html","Name":"vcpkg_execute_required_process_repeat","Source":"# vcpkg_execute_required_process_repeat\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_execute_required_process_repeat.md).\n\nExecute a process until the command succeeds, or until the COUNT is reached.\n\n## Usage\n```cmake\nvcpkg_execute_required_process_repeat(\n    COMMAND <cmd> [<arguments>]\n    COUNT <num>\n    WORKING_DIRECTORY <directory>\n    LOGNAME <name>\n    [ALLOW_IN_DOWNLOAD_MODE]\n)\n```\n\n## Source\n[scripts/cmake/vcpkg\\_execute\\_required\\_process\\_repeat.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_execute_required_process_repeat.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_extract_source_archive.html","Name":"vcpkg_extract_source_archive","Source":"# vcpkg_extract_source_archive\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_extract_source_archive.md).\n\nExtract an archive into the source directory.\n\n## Usage\nThere are two \"overloads\" of this function. The first is deprecated:\n\n```cmake\nvcpkg_extract_source_archive(<${ARCHIVE}> [<${TARGET_DIRECTORY}>])\n```\n\nThis overload should not be used.\n\nThe latter is suggested to use for all future `vcpkg_extract_source_archive`s.\n\n```cmake\nvcpkg_extract_source_archive(<out-var>\n    ARCHIVE <path>\n    [NO_REMOVE_ONE_LEVEL]\n    [SKIP_PATCH_CHECK]\n    [PATCHES <patch>...]\n    [SOURCE_BASE <base>]\n    [BASE_DIRECTORY <relative-path> | WORKING_DIRECTORY <absolute-path>]\n)\n```\n\n`vcpkg_extract_source_archive` takes an archive and extracts it.\nIt replaces existing uses of `vcpkg_extract_source_archive_ex`.\nThe simplest use of it is:\n\n```cmake\nvcpkg_download_distfile(archive ...)\nvcpkg_extract_source_archive(source_path ARCHIVE \"${archive}\")\n```\n\nThe general expectation is that an archives are laid out with a base directory,\nand all the actual files underneath that directory; in other words, if you\nextract the archive, you'll get something that looks like:\n\n```\nzlib-1.2.11/\n    doc/\n        ...\n    examples/\n        ...\n    ChangeLog\n    CMakeLists.txt\n    README\n    zlib.h\n    ...\n```\n\n`vcpkg_extract_source_archive` automatically removes this directory,\nand gives you the items under it directly. However, this only works\nwhen there is exactly one item in the top level of an archive.\nOtherwise, you'll have to pass the `NO_REMOVE_ONE_LEVEL` argument to\nprevent `vcpkg_extract_source_archive` from performing this transformation.\n\nIf the source needs to be patched in some way, the `PATCHES` argument\nallows one to do this, just like other `vcpkg_from_*` functions.\nAdditionally, the `SKIP_PATCH_CHECK` is provided for `--head` mode -\nthis allows patches to fail to apply silently.\nThis argument should _only_ be used when installing a `--head` library,\nsince otherwise we want a patch failing to appply to be a hard error.\n\n`vcpkg_extract_source_archive` extracts the files to\n`${CURRENT_BUILDTREES_DIR}/<base-directory>/<source-base>-<hash>.clean`.\nWhen in editable mode, no `.clean` is appended,\nto allow for a user to modify the sources.\n`base-directory` defaults to `src`,\nand `source-base` defaults to the stem of `<archive>`.\nYou can change these via the `BASE_DIRECTORY` and `SOURCE_BASE` arguments\nrespectively.\nIf you need to extract to a location that is not based in `CURRENT_BUILDTREES_DIR`,\nyou can use the `WORKING_DIRECTORY` argument to do the same.\n\n## Examples\n\n* [libraw](https://github.com/Microsoft/vcpkg/blob/master/ports/libraw/portfile.cmake)\n* [protobuf](https://github.com/Microsoft/vcpkg/blob/master/ports/protobuf/portfile.cmake)\n* [msgpack](https://github.com/Microsoft/vcpkg/blob/master/ports/msgpack/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_extract\\_source\\_archive.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_extract_source_archive.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_extract_source_archive_ex.html","Name":"vcpkg_extract_source_archive_ex","Source":"# vcpkg_extract_source_archive_ex\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_extract_source_archive_ex.md).\n\nExtract an archive into the source directory.\nOriginally replaced [`vcpkg_extract_source_archive()`],\nbut new ports should instead use the second overload of\n[`vcpkg_extract_source_archive()`].\n\n## Usage\n```cmake\nvcpkg_extract_source_archive_ex(\n    [OUT_SOURCE_PATH <source_path>]\n    ...\n)\n```\n\nSee the documentation for [`vcpkg_extract_source_archive()`] for other parameters.\nAdditionally, `vcpkg_extract_source_archive_ex()` adds the `REF` and `WORKING_DIRECTORY`\nparameters, which are wrappers around `SOURCE_BASE` and `BASE_DIRECTORY`\nrespectively.\n\n[`vcpkg_extract_source_archive()`]: vcpkg_extract_source_archive.md\n\n## Source\n[scripts/cmake/vcpkg\\_extract\\_source\\_archive\\_ex.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_extract_source_archive_ex.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_fail_port_install.html","Name":"vcpkg_fail_port_install","Source":"# vcpkg_fail_port_install\n\n**This function has been deprecated in favor of the `supports` field in [`manifest file`](manifest-files.md#supports) et al.**\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_fail_port_install.md).\n\nChecks common requirements and fails the current portfile with a (default) error message\n\n## Usage\n```cmake\nvcpkg_fail_port_install(\n    [ALWAYS]\n    [MESSAGE <\"Reason for failure\">]\n    [ON_TARGET <Windows> [<OSX> ...]]\n    [ON_ARCH <x64> [<arm> ...]]\n    [ON_CRT_LINKAGE <static> [<dynamic> ...]])\n    [ON_LIBRARY_LINKAGE <static> [<dynamic> ...]]\n)\n```\n\n## Parameters\n### MESSAGE\nAdditional failure message. If none is given, a default message will be displayed depending on the failure condition.\n\n### ALWAYS\nWill always fail early\n\n### ON_TARGET\nTargets for which the build should fail early. Valid targets are `<target>` from `VCPKG_IS_TARGET_<target>` (see `vcpkg_common_definitions.cmake`).\n\n### ON_ARCH\nArchitecture for which the build should fail early.\n\n### ON_CRT_LINKAGE\nCRT linkage for which the build should fail early.\n\n### ON_LIBRARY_LINKAGE\nLibrary linkage for which the build should fail early.\n\n## Examples\n\n* [aws-lambda-cpp](https://github.com/Microsoft/vcpkg/blob/master/ports/aws-lambda-cpp/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_fail\\_port\\_install.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_fail_port_install.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_find_acquire_program.html","Name":"vcpkg_find_acquire_program","Source":"# vcpkg_find_acquire_program\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_find_acquire_program.md).\n\nDownload or find a well-known tool.\n\n## Usage\n```cmake\nvcpkg_find_acquire_program(<program>)\n```\n## Parameters\n### program\nThis variable specifies both the program to be acquired as well as the out parameter that will be set to the path of the program executable.\n\n## Notes\nThe current list of programs includes:\n\n* 7Z\n* ARIA2 (Downloader)\n* BISON\n* CLANG\n* DARK\n* DOXYGEN\n* FLEX\n* GASPREPROCESSOR\n* GPERF\n* PERL\n* PYTHON2\n* PYTHON3\n* GIT\n* GN\n* GO\n* JOM\n* MESON\n* NASM\n* NINJA\n* NUGET\n* SCONS\n* SWIG\n* YASM\n\nNote that msys2 has a dedicated helper function: [`vcpkg_acquire_msys`](vcpkg_acquire_msys.md).\n\n## Examples\n\n* [ffmpeg](https://github.com/Microsoft/vcpkg/blob/master/ports/ffmpeg/portfile.cmake)\n* [openssl](https://github.com/Microsoft/vcpkg/blob/master/ports/openssl/portfile.cmake)\n* [qt5](https://github.com/Microsoft/vcpkg/blob/master/ports/qt5/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_find\\_acquire\\_program.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_find_acquire_program.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_find_fortran.html","Name":"vcpkg_find_fortran","Source":"# vcpkg_find_fortran\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_find_fortran.md).\n\nChecks if a Fortran compiler can be found.\nWindows(x86/x64) Only: If not it will switch/enable MinGW gfortran \n                       and return required cmake args for building. \n\n## Usage\n```cmake\nvcpkg_find_fortran(<out_var>)\n```\n\n## Example\n```cmake\nvcpkg_find_fortran(fortran_args)\n# ...\nvcpkg_cmake_configure(...\n    OPTIONS\n        ${fortran_args}\n)\n```\n\n## Source\n[scripts/cmake/vcpkg\\_find\\_fortran.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_find_fortran.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_fixup_cmake_targets.html","Name":"vcpkg_fixup_cmake_targets","Source":"# vcpkg_fixup_cmake_targets\n\n**This function has been deprecated in favor of [`vcpkg_cmake_config_fixup`](ports/vcpkg-cmake-config/vcpkg_cmake_config_fixup.md) from the vcpkg-cmake-config port.**\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_fixup_cmake_targets.md).\n\nMerge release and debug CMake targets and configs to support multiconfig generators.\n\nAdditionally corrects common issues with targets, such as absolute paths and incorrectly placed binaries.\n\n## Usage\n```cmake\nvcpkg_fixup_cmake_targets([CONFIG_PATH <share/${PORT}>] \n                          [TARGET_PATH <share/${PORT}>] \n                          [TOOLS_PATH <tools/${PORT}>]\n                          [DO_NOT_DELETE_PARENT_CONFIG_PATH])\n```\n\n## Parameters\n\n### CONFIG_PATH\nSubpath currently containing `*.cmake` files subdirectory (like `lib/cmake/${PORT}`). Should be relative to `${CURRENT_PACKAGES_DIR}`.\n\nDefaults to `share/${PORT}`.\n\n### TARGET_PATH\nSubpath to which the above `*.cmake` files should be moved. Should be relative to `${CURRENT_PACKAGES_DIR}`.\nThis needs to be specified if the port name differs from the `find_package()` name.\n\nDefaults to `share/${PORT}`.\n\n### DO_NOT_DELETE_PARENT_CONFIG_PATH\nBy default the parent directory of CONFIG_PATH is removed if it is named \"cmake\".\nPassing this option disable such behavior, as it is convenient for ports that install\nmore than one CMake package configuration file.\n\n### NO_PREFIX_CORRECTION\nDisables the correction of_IMPORT_PREFIX done by vcpkg due to moving the targets.\nCurrently the correction does not take into account how the files are moved and applies\nI rather simply correction which in some cases will yield the wrong results.\n\n### TOOLS_PATH\nDefine the base path to tools. Default: `tools/<PORT>`\n\n## Notes\nTransform all `/debug/<CONFIG_PATH>/*targets-debug.cmake` files and move them to `/<TARGET_PATH>`.\nRemoves all `/debug/<CONFIG_PATH>/*targets.cmake` and `/debug/<CONFIG_PATH>/*config.cmake`.\n\nTransform all references matching `/bin/*.exe` to `/${TOOLS_PATH}/*.exe` on Windows.\nTransform all references matching `/bin/*` to `/${TOOLS_PATH}/*`  on other platforms.\n\nFix `${_IMPORT_PREFIX}` in auto generated targets to be one folder deeper.\nReplace `${CURRENT_INSTALLED_DIR}` with `${_IMPORT_PREFIX}` in configs and targets.\n\n## Examples\n\n* [concurrentqueue](https://github.com/Microsoft/vcpkg/blob/master/ports/concurrentqueue/portfile.cmake)\n* [curl](https://github.com/Microsoft/vcpkg/blob/master/ports/curl/portfile.cmake)\n* [nlohmann-json](https://github.com/Microsoft/vcpkg/blob/master/ports/nlohmann-json/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_fixup\\_cmake\\_targets.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_fixup_cmake_targets.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_fixup_pkgconfig.html","Name":"vcpkg_fixup_pkgconfig","Source":"# vcpkg_fixup_pkgconfig\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_fixup_pkgconfig.md).\n\nFix common paths in *.pc files and make everything relative to $(prefix).\nAdditionally, on static triplets, private entries are merged with their non-private counterparts,\nallowing pkg-config to be called without the ``--static`` flag.\nNote that vcpkg is designed to never have to call pkg-config with the ``--static`` flag,\nsince a consumer cannot know if a dependent library has been built statically or not.\n\n## Usage\n```cmake\nvcpkg_fixup_pkgconfig(\n    [RELEASE_FILES <PATHS>...]\n    [DEBUG_FILES <PATHS>...]\n    [SKIP_CHECK]\n)\n```\n\n## Parameters\n### RELEASE_FILES\nSpecifies a list of files to apply the fixes for release paths.\nDefaults to every *.pc file in the folder ${CURRENT_PACKAGES_DIR} without ${CURRENT_PACKAGES_DIR}/debug/\n\n### DEBUG_FILES\nSpecifies a list of files to apply the fixes for debug paths.\nDefaults to every *.pc file in the folder ${CURRENT_PACKAGES_DIR}/debug/\n\n### SKIP_CHECK\nSkips the library checks in vcpkg_fixup_pkgconfig. Only use if the script itself has unhandled cases.\n\n### SYSTEM_PACKAGES (deprecated)\nThis argument has been deprecated and has no effect.\n\n### SYSTEM_LIBRARIES (deprecated)\nThis argument has been deprecated and has no effect.\n\n### IGNORE_FLAGS (deprecated)\nThis argument has been deprecated and has no effect.\n\n## Notes\nStill work in progress. If there are more cases which can be handled here feel free to add them\n\n## Examples\n\n* [brotli](https://github.com/Microsoft/vcpkg/blob/master/ports/brotli/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_fixup\\_pkgconfig.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_fixup_pkgconfig.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_from_bitbucket.html","Name":"vcpkg_from_bitbucket","Source":"# vcpkg_from_bitbucket\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_from_bitbucket.md).\n\nDownload and extract a project from Bitbucket.\n\n## Usage:\n```cmake\nvcpkg_from_bitbucket(\n    OUT_SOURCE_PATH <SOURCE_PATH>\n    REPO <Microsoft/cpprestsdk>\n    [REF <v2.0.0>]\n    [SHA512 <45d0d7f8cc350...>]\n    [HEAD_REF <master>]\n    [PATCHES <patch1.patch> <patch2.patch>...]\n)\n```\n\n## Parameters:\n### OUT_SOURCE_PATH\nSpecifies the out-variable that will contain the extracted location.\n\nThis should be set to `SOURCE_PATH` by convention.\n\n### REPO\nThe organization or user and repository on GitHub.\n\n### REF\nA stable git commit-ish (ideally a tag) that will not change contents. **This should not be a branch.**\n\nFor repositories without official releases, this can be set to the full commit id of the current latest master.\n\nIf `REF` is specified, `SHA512` must also be specified.\n\n### SHA512\nThe SHA512 hash that should match the archive (https://bitbucket.com/${REPO}/get/${REF}.tar.gz).\n\nThis is most easily determined by first setting it to `0`, then trying to build the port. The error message will contain the full hash, which can be copied back into the portfile.\n\n### HEAD_REF\nThe unstable git commit-ish (ideally a branch) to pull for `--head` builds.\n\nFor most projects, this should be `master`. The chosen branch should be one that is expected to be always buildable on all supported platforms.\n\n### PATCHES\nA list of patches to be applied to the extracted sources.\n\nRelative paths are based on the port directory.\n\n## Notes:\nAt least one of `REF` and `HEAD_REF` must be specified, however it is preferable for both to be present.\n\nThis exports the `VCPKG_HEAD_VERSION` variable during head builds.\n\n## Examples:\n\n* [blaze](https://github.com/Microsoft/vcpkg/blob/master/ports/blaze/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_from\\_bitbucket.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_from_bitbucket.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_from_git.html","Name":"vcpkg_from_git","Source":"# vcpkg_from_git\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_from_git.md).\n\nDownload and extract a project from git\n\n## Usage:\n```cmake\nvcpkg_from_git(\n    OUT_SOURCE_PATH <SOURCE_PATH>\n    URL <https://android.googlesource.com/platform/external/fdlibm>\n    REF <59f7335e4d...>\n    [HEAD_REF <ref>]\n    [PATCHES <patch1.patch> <patch2.patch>...]\n)\n```\n\n## Parameters:\n### OUT_SOURCE_PATH\nSpecifies the out-variable that will contain the extracted location.\n\nThis should be set to `SOURCE_PATH` by convention.\n\n### URL\nThe url of the git repository.\n\n### REF\nThe git sha of the commit to download.\n\n### FETCH_REF\nThe git branch to fetch in non-HEAD mode. After this is fetched,\nthen `REF` is checked out. This is useful in cases where the git server\ndoes not allow checking out non-advertised objects.\n\n### HEAD_REF\nThe git branch to use when the package is requested to be built from the latest sources.\n\nExample: `main`, `develop`, `HEAD`\n\n### PATCHES\nA list of patches to be applied to the extracted sources.\n\nRelative paths are based on the port directory.\n\n## Notes:\n`OUT_SOURCE_PATH`, `REF`, and `URL` must be specified.\n\n## Examples:\n\n* [fdlibm](https://github.com/Microsoft/vcpkg/blob/master/ports/fdlibm/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_from\\_git.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_from_git.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_from_github.html","Name":"vcpkg_from_github","Source":"# vcpkg_from_github\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_from_github.md).\n\nDownload and extract a project from GitHub. Enables support for `install --head`.\n\nThis also works with Gitea by specifying the Gitea server with the `GITHUB_HOST` option.\n\n## Usage:\n```cmake\nvcpkg_from_github(\n    OUT_SOURCE_PATH <SOURCE_PATH>\n    REPO <Microsoft/cpprestsdk>\n    [REF <v2.0.0>]\n    [SHA512 <45d0d7f8cc350...>]\n    [HEAD_REF <master>]\n    [PATCHES <patch1.patch> <patch2.patch>...]\n    [GITHUB_HOST <https://github.com>]\n    [AUTHORIZATION_TOKEN <${SECRET_FROM_FILE}>]\n    [FILE_DISAMBIGUATOR <N>]\n)\n```\n\n## Parameters:\n### OUT_SOURCE_PATH\nSpecifies the out-variable that will contain the extracted location.\n\nThis should be set to `SOURCE_PATH` by convention.\n\n### REPO\nThe organization or user and repository on GitHub.\n\n### REF\nA stable git commit-ish (ideally a tag or commit) that will not change contents. **This should not be a branch.**\n\nFor repositories without official releases, this can be set to the full commit id of the current latest master.\n\nIf `REF` is specified, `SHA512` must also be specified.\n\n### SHA512\nThe SHA512 hash that should match the archive (https://github.com/${REPO}/archive/${REF}.tar.gz).\n\nThis is most easily determined by first setting it to `0`, then trying to build the port. The error message will contain the full hash, which can be copied back into the portfile.\n\n### HEAD_REF\nThe unstable git commit-ish (ideally a branch) to pull for `--head` builds.\n\nFor most projects, this should be `master`. The chosen branch should be one that is expected to be always buildable on all supported platforms.\n\n### PATCHES\nA list of patches to be applied to the extracted sources.\n\nRelative paths are based on the port directory.\n\n### GITHUB_HOST\nA replacement host for enterprise GitHub instances.\n\nThis field should contain the scheme, host, and port of the desired URL without a trailing slash.\n\n### AUTHORIZATION_TOKEN\nA token to be passed via the Authorization HTTP header as \"token ${AUTHORIZATION_TOKEN}\".\n\n### FILE_DISAMBIGUATOR\nA token to uniquely identify the resulting filename if the SHA512 changes even though a git ref does not, to avoid stepping on the same file name.\n\n## Notes:\nAt least one of `REF` and `HEAD_REF` must be specified, however it is preferable for both to be present.\n\nThis exports the `VCPKG_HEAD_VERSION` variable during head builds.\n\n## Examples:\n\n* [cpprestsdk](https://github.com/Microsoft/vcpkg/blob/master/ports/cpprestsdk/portfile.cmake)\n* [ms-gsl](https://github.com/Microsoft/vcpkg/blob/master/ports/ms-gsl/portfile.cmake)\n* [boost-beast](https://github.com/Microsoft/vcpkg/blob/master/ports/boost-beast/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_from\\_github.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_from_github.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_from_gitlab.html","Name":"vcpkg_from_gitlab","Source":"# vcpkg_from_gitlab\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_from_gitlab.md).\n\nDownload and extract a project from Gitlab instances. Enables support for `install --head`.\n\n## Usage:\n```cmake\nvcpkg_from_gitlab(\n    GITLAB_URL <https://gitlab.com>\n    OUT_SOURCE_PATH <SOURCE_PATH>\n    REPO <gitlab-org/gitlab-ce>\n    [REF <v10.7.3>]\n    [SHA512 <45d0d7f8cc350...>]\n    [HEAD_REF <master>]\n    [PATCHES <patch1.patch> <patch2.patch>...]\n    [FILE_DISAMBIGUATOR <N>]\n)\n```\n\n## Parameters:\n\n### GITLAB_URL\nThe URL of the Gitlab instance to use.\n\n### OUT_SOURCE_PATH\nSpecifies the out-variable that will contain the extracted location.\n\nThis should be set to `SOURCE_PATH` by convention.\n\n### REPO\nThe organization or user plus the repository name on the Gitlab instance.\n\n### REF\nA stable git commit-ish (ideally a tag) that will not change contents. **This should not be a branch.**\n\nFor repositories without official releases, this can be set to the full commit id of the current latest master.\n\nIf `REF` is specified, `SHA512` must also be specified.\n\n### SHA512\nThe SHA512 hash that should match the archive (${GITLAB_URL}/${REPO}/-/archive/${REF}/${REPO_NAME}-${REF}.tar.gz).\nThe REPO_NAME variable is parsed from the value of REPO.\n\nThis is most easily determined by first setting it to `0`, then trying to build the port. The error message will contain the full hash, which can be copied back into the portfile.\n\n### HEAD_REF\nThe unstable git commit-ish (ideally a branch) to pull for `--head` builds.\n\nFor most projects, this should be `master`. The chosen branch should be one that is expected to be always buildable on all supported platforms.\n\n### PATCHES\nA list of patches to be applied to the extracted sources.\n\nRelative paths are based on the port directory.\n\n### FILE_DISAMBIGUATOR\nA token to uniquely identify the resulting filename if the SHA512 changes even though a git ref does not, to avoid stepping on the same file name.\n\n## Notes:\nAt least one of `REF` and `HEAD_REF` must be specified, however it is preferable for both to be present.\n\nThis exports the `VCPKG_HEAD_VERSION` variable during head builds.\n\n## Examples:\n* [curl][https://github.com/Microsoft/vcpkg/blob/master/ports/curl/portfile.cmake#L75]\n* [folly](https://github.com/Microsoft/vcpkg/blob/master/ports/folly/portfile.cmake#L15)\n* [z3](https://github.com/Microsoft/vcpkg/blob/master/ports/z3/portfile.cmake#L13)\n\n## Source\n[scripts/cmake/vcpkg\\_from\\_gitlab.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_from_gitlab.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_from_sourceforge.html","Name":"vcpkg_from_sourceforge","Source":"# vcpkg_from_sourceforge\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_from_sourceforge.md).\n\nDownload and extract a project from sourceforge.\n\nThis function automatically checks a set of sourceforge mirrors.\nAdditional mirrors can be injected through the `VCPKG_SOURCEFORGE_EXTRA_MIRRORS`\nlist variable in the triplet.\n\n## Usage:\n```cmake\nvcpkg_from_sourceforge(\n    OUT_SOURCE_PATH SOURCE_PATH\n    REPO <cunit/CUnit>\n    [REF <2.1-3>]\n    SHA512 <547b417109332...>\n    FILENAME <CUnit-2.1-3.tar.bz2>\n    [DISABLE_SSL]\n    [NO_REMOVE_ONE_LEVEL]\n    [PATCHES <patch1.patch> <patch2.patch>...]\n)\n```\n\n## Parameters:\n### OUT_SOURCE_PATH\nSpecifies the out-variable that will contain the extracted location.\n\nThis should be set to `SOURCE_PATH` by convention.\n\n### REPO\nThe organization or user and repository (optional) on sourceforge.\n\n### REF\nA stable version number that will not change contents.\n\n### FILENAME\nThe local name for the file. Files are shared between ports, so the file may need to be renamed to make it clearly attributed to this port and avoid conflicts.\n\nFor example, we can get the download link:\nhttps://sourceforge.net/settings/mirror_choices?projectname=mad&filename=libmad/0.15.1b/libmad-0.15.1b.tar.gz&selected=nchc\nSo the REPO is `mad/libmad`, the REF is `0.15.1b`, and the FILENAME is `libmad-0.15.1b.tar.gz`\n\nFor some special links:\nhttps://sourceforge.net/settings/mirror_choices?projectname=soxr&filename=soxr-0.1.3-Source.tar.xz&selected=nchc\nThe REPO is `soxr`, REF is not exist, and the FILENAME is `soxr-0.1.3-Source.tar.xz`\n\n### SHA512\nThe SHA512 hash that should match the archive.\n\nThis is most easily determined by first setting it to `0`, then trying to build the port. The error message will contain the full hash, which can be copied back into the portfile.\n\n### WORKING_DIRECTORY\nIf specified, the archive will be extracted into the working directory instead of `${CURRENT_BUILDTREES_DIR}/src/`.\n\nNote that the archive will still be extracted into a subfolder underneath that directory (`${WORKING_DIRECTORY}/${REF}-${HASH}/`).\n\n### PATCHES\nA list of patches to be applied to the extracted sources.\n\nRelative paths are based on the port directory.\n\n### NO_REMOVE_ONE_LEVEL\nSpecifies that the default removal of the top level folder should not occur.\n\n## Examples:\n\n* [cunit](https://github.com/Microsoft/vcpkg/blob/master/ports/cunit/portfile.cmake)\n* [polyclipping](https://github.com/Microsoft/vcpkg/blob/master/ports/polyclipping/portfile.cmake)\n* [tinyfiledialogs](https://github.com/Microsoft/vcpkg/blob/master/ports/tinyfiledialogs/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_from\\_sourceforge.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_from_sourceforge.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_get_program_files_platform_bitness.html","Name":"vcpkg_get_program_files_platform_bitness","Source":"# vcpkg_get_program_files_platform_bitness\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_get_program_files_platform_bitness.md).\n\nGet the Program Files directory of the current platform's bitness:\neither `$ENV{ProgramW6432}` on 64-bit windows,\nor `$ENV{PROGRAMFILES}` on 32-bit windows.\n\n## Usage:\n```cmake\nvcpkg_get_program_files_platform_bitness(<variable>)\n```\n\n## Source\n[scripts/cmake/vcpkg\\_get\\_program\\_files\\_platform\\_bitness.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_get_program_files_platform_bitness.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_get_windows_sdk.html","Name":"vcpkg_get_windows_sdk","Source":"# vcpkg_get_windows_sdk\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_get_windows_sdk.md).\n\nGet the Windows SDK number.\n\n## Usage:\n```cmake\nvcpkg_get_windows_sdk(<variable>)\n```\n\n## Source\n[scripts/cmake/vcpkg\\_get\\_windows\\_sdk.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_get_windows_sdk.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_host_path_list.html","Name":"vcpkg_host_path_list","Source":"# vcpkg_host_path_list\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_host_path_list.md).\n\nModify a host path list variable (PATH, INCLUDE, LIBPATH, etc.)\n\n```cmake\nvcpkg_host_path_list(PREPEND <list-var> [<path>...])\nvcpkg_host_path_list(APPEND <list-var> [<path>...])\nvcpkg_host_path_list(SET <list-var> [<path>...])\n```\n\n`<list-var>` may be either a regular variable name, or `ENV{variable-name}`,\nin which case `vcpkg_host_path_list` will modify the environment.\n\n`vcpkg_host_path_list` adds all of the paths passed to it to `<list-var>`;\n`PREPEND` puts them before the existing list, so that they are searched first;\n`APPEND` places them after the existing list,\nso they would be searched after the paths which are already in the variable,\nand `SET` replaces the value of the existing list.\n\nFor all of `APPEND`, `PREPEND`, and `SET`,\nthe paths are added (and thus searched) in the order received.\n\nIf no paths are passed to `APPEND` or `PREPEND`, nothing will be done;\nfor `SET`, the variable will be set to the empty string.\n\n## Source\n[scripts/cmake/vcpkg\\_host\\_path\\_list.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_host_path_list.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_install_cmake.html","Name":"vcpkg_install_cmake","Source":"# vcpkg_install_cmake\n\n**This function has been deprecated in favor of [`vcpkg_cmake_install`](ports/vcpkg-cmake/vcpkg_cmake_install.md) from the vcpkg-cmake port.**\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_install_cmake.md).\n\nBuild and install a cmake project.\n\n## Usage:\n```cmake\nvcpkg_install_cmake(...)\n```\n\n## Parameters:\nSee [`vcpkg_build_cmake()`](vcpkg_build_cmake.md).\n\n## Notes:\nThis command transparently forwards to [`vcpkg_build_cmake()`](vcpkg_build_cmake.md), adding a `TARGET install`\nparameter.\n\n## Examples:\n\n* [zlib](https://github.com/Microsoft/vcpkg/blob/master/ports/zlib/portfile.cmake)\n* [cpprestsdk](https://github.com/Microsoft/vcpkg/blob/master/ports/cpprestsdk/portfile.cmake)\n* [poco](https://github.com/Microsoft/vcpkg/blob/master/ports/poco/portfile.cmake)\n* [opencv](https://github.com/Microsoft/vcpkg/blob/master/ports/opencv/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_install\\_cmake.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_install_cmake.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_install_gn.html","Name":"vcpkg_install_gn","Source":"# vcpkg_install_gn\n\n**This function has been deprecated in favor of [`vcpkg_gn_install`](ports/vcpkg-gn/vcpkg_gn_install.md) from the vcpkg-gn port.**\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_install_gn.md).\n\nInstalls a GN project.\n\nIn order to build a GN project without installing, use [`vcpkg_build_ninja()`].\n\n## Usage:\n```cmake\nvcpkg_install_gn(\n     SOURCE_PATH <SOURCE_PATH>\n     [TARGETS <target>...]\n)\n```\n\n## Parameters:\n### SOURCE_PATH\nThe path to the source directory\n\n### TARGETS\nOnly install the specified targets.\n\nNote: includes must be handled separately\n\n[`vcpkg_build_ninja()`]: vcpkg_build_ninja.md\n\n## Source\n[scripts/cmake/vcpkg\\_install\\_gn.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_install_gn.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_install_make.html","Name":"vcpkg_install_make","Source":"# vcpkg_install_make\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_install_make.md).\n\nBuild and install a make project.\n\n## Usage:\n```cmake\nvcpkg_install_make(...)\n```\n\n## Parameters:\nSee [`vcpkg_build_make()`](vcpkg_build_make.md).\n\n## Notes:\nThis command transparently forwards to [`vcpkg_build_make()`](vcpkg_build_make.md), adding `ENABLE_INSTALL`\n\n## Examples\n\n* [x264](https://github.com/Microsoft/vcpkg/blob/master/ports/x264/portfile.cmake)\n* [tcl](https://github.com/Microsoft/vcpkg/blob/master/ports/tcl/portfile.cmake)\n* [freexl](https://github.com/Microsoft/vcpkg/blob/master/ports/freexl/portfile.cmake)\n* [libosip2](https://github.com/Microsoft/vcpkg/blob/master/ports/libosip2/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_install\\_make.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_install_make.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_install_meson.html","Name":"vcpkg_install_meson","Source":"# vcpkg_install_meson\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_install_meson.md).\n\nBuilds a meson project previously configured with `vcpkg_configure_meson()`.\n\n## Usage\n```cmake\nvcpkg_install_meson([ADD_BIN_TO_PATH])\n```\n\n## Parameters:\n### ADD_BIN_TO_PATH\nAdds the appropriate Release and Debug `bin\\` directories to the path during the build such that executables can run against the in-tree DLLs.\n\n## Examples\n\n* [fribidi](https://github.com/Microsoft/vcpkg/blob/master/ports/fribidi/portfile.cmake)\n* [libepoxy](https://github.com/Microsoft/vcpkg/blob/master/ports/libepoxy/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_install\\_meson.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_install_meson.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_install_msbuild.html","Name":"vcpkg_install_msbuild","Source":"# vcpkg_install_msbuild\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_install_msbuild.md).\n\nBuild and install a msbuild-based project. This replaces `vcpkg_build_msbuild()`.\n\n## Usage\n```cmake\nvcpkg_install_msbuild(\n    SOURCE_PATH <${SOURCE_PATH}>\n    PROJECT_SUBPATH <port.sln>\n    [INCLUDES_SUBPATH <include>]\n    [LICENSE_SUBPATH <LICENSE>]\n    [RELEASE_CONFIGURATION <Release>]\n    [DEBUG_CONFIGURATION <Debug>]\n    [TARGET <Build>]\n    [TARGET_PLATFORM_VERSION <10.0.15063.0>]\n    [PLATFORM <${TRIPLET_SYSTEM_ARCH}>]\n    [PLATFORM_TOOLSET <${VCPKG_PLATFORM_TOOLSET}>]\n    [OPTIONS </p:ZLIB_INCLUDE_PATH=X>...]\n    [OPTIONS_RELEASE </p:ZLIB_LIB=X>...]\n    [OPTIONS_DEBUG </p:ZLIB_LIB=X>...]\n    [USE_VCPKG_INTEGRATION]\n    [ALLOW_ROOT_INCLUDES | REMOVE_ROOT_INCLUDES]\n)\n```\n\n## Parameters\n### SOURCE_PATH\nThe path to the root of the source tree.\n\nBecause MSBuild uses in-source builds, the source tree will be copied into a temporary location for the build. This\nparameter is the base for that copy and forms the base for all XYZ_SUBPATH options.\n\n### USE_VCPKG_INTEGRATION\nApply the normal `integrate install` integration for building the project.\n\nBy default, projects built with this command will not automatically link libraries or have header paths set.\n\n### PROJECT_SUBPATH\nThe subpath to the solution (`.sln`) or project (`.vcxproj`) file relative to `SOURCE_PATH`.\n\n### LICENSE_SUBPATH\nThe subpath to the license file relative to `SOURCE_PATH`.\n\n### INCLUDES_SUBPATH\nThe subpath to the includes directory relative to `SOURCE_PATH`.\n\nThis parameter should be a directory and should not end in a trailing slash.\n\n### ALLOW_ROOT_INCLUDES\nIndicates that top-level include files (e.g. `include/zlib.h`) should be allowed.\n\n### REMOVE_ROOT_INCLUDES\nIndicates that top-level include files (e.g. `include/Makefile.am`) should be removed.\n\n### SKIP_CLEAN\nIndicates that the intermediate files should not be removed.\n\nPorts using this option should later call [`vcpkg_clean_msbuild()`](vcpkg_clean_msbuild.md) to manually clean up.\n\n### RELEASE_CONFIGURATION\nThe configuration (``/p:Configuration`` msbuild parameter) used for Release builds.\n\n### DEBUG_CONFIGURATION\nThe configuration (``/p:Configuration`` msbuild parameter) used for Debug builds.\n\n### TARGET_PLATFORM_VERSION\nThe WindowsTargetPlatformVersion (``/p:WindowsTargetPlatformVersion`` msbuild parameter)\n\n### TARGET\nThe MSBuild target to build. (``/t:<TARGET>``)\n\n### PLATFORM\nThe platform (``/p:Platform`` msbuild parameter) used for the build.\n\n### PLATFORM_TOOLSET\nThe platform toolset (``/p:PlatformToolset`` msbuild parameter) used for the build.\n\n### OPTIONS\nAdditional options passed to msbuild for all builds.\n\n### OPTIONS_RELEASE\nAdditional options passed to msbuild for Release builds. These are in addition to `OPTIONS`.\n\n### OPTIONS_DEBUG\nAdditional options passed to msbuild for Debug builds. These are in addition to `OPTIONS`.\n\n## Examples\n\n* [libirecovery](https://github.com/Microsoft/vcpkg/blob/master/ports/libirecovery/portfile.cmake)\n* [libfabric](https://github.com/Microsoft/vcpkg/blob/master/ports/libfabric/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_install\\_msbuild.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_install_msbuild.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_install_nmake.html","Name":"vcpkg_install_nmake","Source":"# vcpkg_install_nmake\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_install_nmake.md).\n\nBuild and install a msvc makefile project.\n\n## Usage:\n```cmake\nvcpkg_install_nmake(\n    SOURCE_PATH <${SOURCE_PATH}>\n    [NO_DEBUG]\n    [TARGET <all>]\n    PROJECT_SUBPATH <${SUBPATH}>\n    PROJECT_NAME <${MAKEFILE_NAME}>\n    [PRERUN_SHELL <${SHELL_PATH}>]\n    [PRERUN_SHELL_DEBUG <${SHELL_PATH}>]\n    [PRERUN_SHELL_RELEASE <${SHELL_PATH}>]\n    [OPTIONS <-DUSE_THIS_IN_ALL_BUILDS=1>...]\n    [OPTIONS_RELEASE <-DOPTIMIZE=1>...]\n    [OPTIONS_DEBUG <-DDEBUGGABLE=1>...]\n```\n\n## Parameters\n### SOURCE_PATH\nSpecifies the directory containing the source files.\nBy convention, this is usually set in the portfile as the variable `SOURCE_PATH`.\n\n### PROJECT_SUBPATH\nSpecifies the sub directory containing the `makefile.vc`/`makefile.mak`/`makefile.msvc` or other msvc makefile.\n\n### PROJECT_NAME\nSpecifies the name of msvc makefile name.\nDefault is makefile.vc\n\n### NO_DEBUG\nThis port doesn't support debug mode.\n\n### PRERUN_SHELL\nScript that needs to be called before build\n\n### PRERUN_SHELL_DEBUG\nScript that needs to be called before debug build\n\n### PRERUN_SHELL_RELEASE\nScript that needs to be called before release build\n\n### OPTIONS\nAdditional options passed to generate during the generation.\n\n### OPTIONS_RELEASE\nAdditional options passed to generate during the Release generation. These are in addition to `OPTIONS`.\n\n### OPTIONS_DEBUG\nAdditional options passed to generate during the Debug generation. These are in addition to `OPTIONS`.\n\n## Parameters:\nSee [`vcpkg_build_nmake()`](vcpkg_build_nmake.md).\n\n## Notes:\nThis command transparently forwards to [`vcpkg_build_nmake()`](vcpkg_build_nmake.md), adding `ENABLE_INSTALL`\n\n## Examples\n\n* [tcl](https://github.com/Microsoft/vcpkg/blob/master/ports/tcl/portfile.cmake)\n* [freexl](https://github.com/Microsoft/vcpkg/blob/master/ports/freexl/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_install\\_nmake.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_install_nmake.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_install_qmake.html","Name":"vcpkg_install_qmake","Source":"# vcpkg_install_qmake\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_install_qmake.md).\n\nBuild and install a qmake project.\n\n## Usage:\n```cmake\nvcpkg_install_qmake(...)\n```\n\n## Parameters:\nSee [`vcpkg_build_qmake()`](vcpkg_build_qmake.md).\n\n## Notes:\nThis command transparently forwards to [`vcpkg_build_qmake()`](vcpkg_build_qmake.md).\n\nAdditionally, this command will copy produced .libs/.dlls/.as/.dylibs/.sos to the appropriate\nstaging directories.\n\n## Examples\n\n* [libqglviewer](https://github.com/Microsoft/vcpkg/blob/master/ports/libqglviewer/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_install\\_qmake.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_install_qmake.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_list.html","Name":"vcpkg_list","Source":"# vcpkg_list\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_list.md).\n\nA replacement for CMake's `list()` function, which correctly handles elements\nwith internal semicolons (in other words, escaped semicolons).\nUse `vcpkg_list()` instead of `list()` whenever possible.\n\n```cmake\nvcpkg_list(SET <out-var> [<element>...])\nvcpkg_list(<COMMAND> <list-var> [<other-arguments>...])\n```\n\nIn addition to all of the commands from `list()`, `vcpkg_list` adds\na `vcpkg_list(SET)` command.\nThis command takes its arguments, escapes them, and then concatenates\nthem into a list; this should be used instead of `set()` for setting any\nlist variable.\n\nOtherwise, the `vcpkg_list()` function is the same as the built-in\n`list()` function, with the following restrictions:\n\n- `GET`, `REMOVE_ITEM`, and `REMOVE_AT` support only one index/value\n- `POP_BACK` and `POP_FRONT` do not support getting the value into\n  another out variable. Use C++ style `GET` then `POP_(BACK|FRONT)`.\n- `FILTER` and `TRANSFORM` are unsupported.\n\nSee the [CMake documentation for `list()`](https://cmake.org/cmake/help/latest/command/list.html)\nfor more information.\n\n## Notes: Some Weirdnesses\n\nThe most major weirdness is due to `\"\"` pulling double-duty as \"list of zero elements\",\nand \"list of one element, which is empty\". `vcpkg_list` always uses the former understanding.\nThis can cause weird behavior, for example:\n\n```cmake\nset(lst \"\")\nvcpkg_list(APPEND lst \"\" \"\")\n# lst = \";\"\n```\n\nThis is because you're appending two elements to the empty list.\nOne very weird behavior that comes out of this would be:\n\n```cmake\nset(lst \"\")\nvcpkg_list(APPEND lst \"\")\n# lst = \"\"\n```\n\nsince `\"\"` is the empty list, we append the empty element and end up with a list\nof one element, which is empty. This does not happen for non-empty lists;\nfor example:\n\n```cmake\nset(lst \"a\")\nvcpkg_list(APPEND lst \"\")\n# lst = \"a;\"\n```\n\nonly the empty list has this odd behavior.\n\n## Examples\n\n### Creating a list\n\n```cmake\nvcpkg_list(SET foo_param)\nif(DEFINED arg_FOO)\n    vcpkg_list(SET foo_param FOO \"${arg_FOO}\")\nendif()\n```\n\n### Appending to a list\n\n```cmake\nset(OPTIONS -DFOO=BAR)\nif(VCPKG_TARGET_IS_WINDOWS)\n    vcpkg_list(APPEND OPTIONS \"-DOS=WINDOWS;FOO\")\nendif()\n```\n\n### Popping the end off a list\n\n```cmake\nif(NOT list STREQUAL \"\")\n    vcpkg_list(GET list end -1)\n    vcpkg_list(POP_BACK list)\nendif()\n```\n\n## Source\n[scripts/cmake/vcpkg\\_list.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_list.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_minimum_required.html","Name":"vcpkg_minimum_required","Source":"# vcpkg_minimum_required\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_minimum_required.md).\n\nAsserts that the version of the vcpkg program being used to build a port is later than the supplied date, inclusive.\n\n## Usage\n```cmake\nvcpkg_minimum_required(VERSION 2021-01-13)\n```\n\n## Parameters\n### VERSION\nThe date-version to check against.\n\n## Source\n[scripts/cmake/vcpkg\\_minimum\\_required.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_minimum_required.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_replace_string.html","Name":"vcpkg_replace_string","Source":"# vcpkg_replace_string\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_replace_string.md).\n\nReplace a string in a file.\n\n```cmake\nvcpkg_replace_string(<filename> <match> <replace>)\n```\n\n## Source\n[scripts/cmake/vcpkg\\_replace\\_string.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_replace_string.cmake)\n","Nav":"#"},{"Path":"/en/docs/users/android.html","Name":"Android","Source":"# Vcpkg and Android\n\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/users/android.md).**\n\n*Android is not tested as part of vcpkg repository's CI process, so regressions can occur as part of library updates. PRs improving support are welcome!*\n\n## Android build requirements\n\n1. Download the [android ndk](https://developer.android.com/ndk/downloads/)\n\n2. Set environment variable `ANDROID_NDK_HOME` to your android ndk installation. \n   For example:\n\n````bash\nexport ANDROID_NDK_HOME=/home/your-account/Android/Sdk/ndk-bundle\n````\n\nOr:\n````bash\nexport ANDROID_NDK_HOME=/home/your-account/Android/android-ndk-r21b\n````\n\n3. Install [vcpkg](https://github.com/microsoft/vcpkg)\n\n4. Set environment variable `VCPKG_ROOT` to your vcpkg installation.\n````bash\nexport VCPKG_ROOT=/path/to/vcpkg\n````\n\n## vcpkg triplets and their corresponding android ABI\n\nThere are four different Android ABI, each of which maps to \na vcpkg triplet. The following table outlines the mapping from vcpkg architectures to android architectures\n\n|VCPKG_TARGET_TRIPLET       | ANDROID_ABI          |\n|---------------------------|----------------------|\n|arm64-android              | arm64-v8a            |\n|arm-android                | armeabi-v7a          |\n|x64-android                | x86_64               |\n|x86-android                | x86                  |\n\n## Install libraries for Android using vcpkg\n\nExample for jsoncpp:\n\n````bash\ncd $VCPKG_ROOT\n\n# specify the triplet like this\n./vcpkg install jsoncpp --triplet arm-android   \n# or like this\n./vcpkg install jsoncpp:arm64-android           \n./vcpkg install jsoncpp:x86-android\n./vcpkg install jsoncpp:x64-android\n````\n\n### Using Vulkan SDK\n\nVcpkg has a [`vulkan` package](https://github.com/microsoft/vcpkg/blob/master/ports/vulkan/portfile.cmake) which allows you to `find_package(Vulkan)`. To use it you have to provide `VULKAN_SDK` environment variable.\n\n```bash\nexport VULKAN_SDK=/usr/local\n./vcpkg install vulkan\n```\n\nNDK already contains [Vulkan](https://developer.android.com/ndk/guides/graphics/getting-started) headers and `libvulkan.so` binaries for each of its architecture.  \nTo expose them to VcPkg, you can consider `export VULKAN_SDK=...` for each installation.  \nBut by placing `set(ENV{VULKAN_SDK} ...)` in the triplet files, you can skip the tedious work.\n\nIf you are using NDK 21.3.6528147 or earlier version, it will be like the following.\n\n```cmake\n# In android triplets... (e.g. arm64-android.cmake)\nset(VCPKG_CMAKE_SYSTEM_NAME Android)\n# ...\n# If your API level is 30, libvulkan.so is at $ENV{ANDROID_NDK_HOME}/platforms/android-30/arch-arm64/usr/lib\nset(ENV{VULKAN_SDK} $ENV{ANDROID_NDK_HOME}/sysroot/usr)\n```\n\nNotice that **the location of the sysroot has changed since NDK 22**. (see https://github.com/android/ndk/issues/1407)  \nIf you prefer using [the latest version](https://developer.android.com/studio/projects/install-ndk#default-ndk-per-agp), check the [BuildSystemMaintainers.md of the NDK document](https://android.googlesource.com/platform/ndk/+/master/docs/BuildSystemMaintainers.md#sysroot) and then put appropriate path for your system.\n\nFor example, Mac OS users will use the path like this.\n\n```cmake\n# In android triplets... (e.g. arm64-android.cmake)\nset(VCPKG_CMAKE_SYSTEM_NAME Android)\n# ...\n# If your API level is 30, libvulkan.so is at $ENV{ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/lib/aarch64-linux-android/30\nset(ENV{VULKAN_SDK} $ENV{ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr)\n```\n\nBy doing this for all android triplets, you can install `vulkan` and the packages that require it. (e.g. `vulkan-hpp`)\n\n<details>\n  <summary markdown=\"span\">`vcpkg install vulkan-hpp:arm64-android`</summary>\n\n```console\nuser@host$ ./vcpkg install vulkan-hpp:arm64-android\nComputing installation plan...\nThe following packages will be built and installed:\n  * vulkan[core]:arm64-android -> 1.1.82.1-1\n    vulkan-hpp[core]:arm64-android -> 2019-05-11-1\nAdditional packages (*) will be modified to complete this operation.\nDetecting compiler hash for triplet arm64-android...\n...\nStarting package 1/2: vulkan:arm64-android\nBuilding package vulkan[core]:arm64-android...\n-- Using community triplet arm64-android. This triplet configuration is not guaranteed to succeed.\n-- [COMMUNITY] Loading triplet configuration from: /.../vcpkg/triplets/community/arm64-android.cmake\n-- Querying VULKAN_SDK Environment variable\n-- Searching /.../Library/Android/sdk/ndk/22.1.7171670/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/vulkan/ for vulkan.h\n-- Found vulkan.h\n-- Performing post-build validation\n-- Performing post-build validation done\n...\nBuilding package vulkan[core]:arm64-android... done\nInstalling package vulkan[core]:arm64-android...\nInstalling package vulkan[core]:arm64-android... done\nElapsed time for package vulkan:arm64-android: 35.9 ms\nStarting package 2/2: vulkan-hpp:arm64-android\nBuilding package vulkan-hpp[core]:arm64-android...\n-- Using community triplet arm64-android. This triplet configuration is not guaranteed to succeed.\n-- [COMMUNITY] Loading triplet configuration from: /.../vcpkg/triplets/community/arm64-android.cmake\n-- Using cached /.../vcpkg/downloads/KhronosGroup-Vulkan-Hpp-5ce8ae7fd0d9c0543d02f33cfa8a66e6a43e2150.tar.gz\n-- Cleaning sources at /.../vcpkg/buildtrees/vulkan-hpp/src/e6a43e2150-4f344cd911.clean. Use --editable to skip cleaning for the packages you specify.\n-- Extracting source /.../vcpkg/downloads/KhronosGroup-Vulkan-Hpp-5ce8ae7fd0d9c0543d02f33cfa8a66e6a43e2150.tar.gz\n-- Using source at /.../vcpkg/buildtrees/vulkan-hpp/src/e6a43e2150-4f344cd911.clean\n-- Performing post-build validation\n-- Performing post-build validation done\n...\nBuilding package vulkan-hpp[core]:arm64-android... done\nInstalling package vulkan-hpp[core]:arm64-android...\nInstalling package vulkan-hpp[core]:arm64-android... done\nElapsed time for package vulkan-hpp:arm64-android: 144.5 ms\n\nTotal elapsed time: 1.013 s\n\nThe package vulkan-hpp:arm64-android is header only and can be used from CMake via:\n\n    find_path(VULKAN_HPP_INCLUDE_DIRS \"vulkan/vulkan.hpp\")\n    target_include_directories(main PRIVATE ${VULKAN_HPP_INCLUDE_DIRS})\n\n```\n\n</details>\n\n\n## Consume libraries using vpckg, cmake and the android toolchain\n\n1. Combine vcpkg and Android toolchains\n\nvcpkg and android both provide dedicated toolchains:\n````bash\nvcpkg_toolchain_file=$VCPKG_ROOT/scripts/buildsystems/vcpkg.cmake\nandroid_toolchain_file=$ANDROID_NDK_HOME/build/cmake/android.toolchain.cmake\n````\n\nWhen using vcpkg, the vcpkg toolchain shall be specified first. \n\nHowever, vcpkg provides a way to preload and additional toolchain, with the VCPKG_CHAINLOAD_TOOLCHAIN_FILE option. \n\n````bash\ncmake \\\n  -DCMAKE_TOOLCHAIN_FILE=$vcpkg_toolchain_file \\\n  -DVCPKG_CHAINLOAD_TOOLCHAIN_FILE=$android_toolchain_file \\\n  ...\n````\n\n2. Specify the android abi and vcpkg triplet\n\nWhen compiling for android, you need to select a matching \"android abi\" / \"vcpkg triplet\" pair.\n\nFor example:\n\n````bash\nandroid_abi=armeabi-v7a\nvcpkg_target_triplet=arm-android\n\ncmake \n  ...\n  -DVCPKG_TARGET_TRIPLET=$vcpkg_target_triplet \\\n  -DANDROID_ABI=$android_abi\n````\n\n### Test on an example\n\nThe folder [docs/examples/vcpkg_android_example_cmake](../examples/vcpkg_android_example_cmake) provides a working example, with an android library that consumes the jsoncpp library:\n\n*Details*\n\n* The [CMakeLists](../examples/vcpkg_android_example_cmake/CMakeLists.txt) simply uses `find_package` and `target_link_library`\n\n* The [compile.sh](../examples/vcpkg_android_example_cmake/compile.sh) script enables you to select any matching pair of \"android abi\" /  \"vcpkg triplet\" and to test the compilation\n\n* The dummy [my_lib.cpp](../examples/vcpkg_android_example_cmake/my_lib.cpp) file uses the jsoncpp library\n\n*Note*: this example only compiles an Android library, as the compilation of a full fledged Android App is beyond the scope of this document.\n\n### Test on an example, using [vcpkg_android.cmake](../examples/vcpkg_android_example_cmake_script/cmake/vcpkg_android.cmake)\n\nThe folder [docs/examples/vcpkg_android_example_cmake_script](../examples/vcpkg_android_example_cmake_script) provides the same example, and uses a cmake script in order to simplify the usage.\n\n*Details*\n\n* The main [CMakeLists](../examples/vcpkg_android_example_cmake_script/CMakeLists.txt) loads [vcpkg_android.cmake](../examples/vcpkg_android_example_cmake_script/cmake/vcpkg_android.cmake) if the flag `VCPKG_TARGET_ANDROID` is set:\n````cmake\nif (VCPKG_TARGET_ANDROID)\n    include(\"cmake/vcpkg_android.cmake\")\nendif()\n````\n*Important: place these lines before calling project() !*\n\n* The [compile.sh](../examples/vcpkg_android_example_cmake_script/compile.sh) script shows that it is then possible to compile for android using a simple cmake invocation, for example:\n````bash\ncmake .. -DVCPKG_TARGET_ANDROID=ON -DANDROID_ABI=armeabi-v7a\n````\n\n## Consume libraries using vpckg, and Android prefab Archives (AAR files)\n\nSee [prefab.md](../specifications/prefab.md)\n","Nav":"#"},{"Path":"/en/docs/users/assetcaching.html","Name":"Assetcaching","Source":"# Asset Caching\n\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/users/assetcaching.md).**\n\n**Experimental feature: this may change or be removed at any time**\n\nVcpkg can utilize mirrors to cache downloaded assets, ensuring continued operation even if the original source changes\nor disappears.\n\nIn-tool help is available via `vcpkg help assetcaching`.\n\n## Configuration\n\nAsset caching can be configured by setting the environment variable `X_VCPKG_ASSET_SOURCES` to a semicolon-delimited\nlist of source strings. Characters can be escaped using backtick (\\`).\n\n### Valid source strings\n\nThe `<rw>` optional parameter for certain strings controls how they will be accessed. It can be specified as `read`,\n`write`, or `readwrite` and defaults to `read`.\n\n#### `clear`\n\nSyntax: `clear`\n\nRemoves all previous sources\n\n#### `x-azurl`\n\nSyntax: `x-azurl,<url>[,<sas>[,<rw>]]`\n\nAdds an Azure Blob Storage source, optionally using Shared Access Signature validation. URL should include the container\npath and be terminated with a trailing `/`. SAS, if defined, should be prefixed with a `?`. Non-Azure servers will also\nwork if they respond to GET and PUT requests of the form: `<url><sha512><sas>`. As an example, if you set\n`X_VCPKG_ASSET_SOURCES` to `x-azurl,https://mydomain.com/vcpkg/,token=abc123,readwrite` your server should respond to\n`GET` and `PUT` requests of the form `https://mydomain.com/vcpkg/<sha512>?token=abc123`.\n\nYou can also use the filesystem (e.g. a network drive) via `file://` as asset cache. For example you then set\n`X_VCPKG_ASSET_SOURCES` to `x-azurl,file:///Z:/vcpkg/assetcache/,,readwrite` when you have a network folder mounted at\n`Z:/`.\n\nThe workflow of this asset source is:\n\n1. Attemp to read from the mirror\n2. (If step 1 failed) Read from the original url\n3. (If step 2 succeeded) Write back to the mirror\n\nYou can enable/disable steps 1 and 3 via the [`<rw>`](#valid-source-strings) specifier and you can disable step 2 via\n`x-block-origin` below.\n\nSee also the [binary caching documentation for Azure Blob Storage](binarycaching.md#azure-blob-storage-experimental) for\nmore information on how to set up an `x-azurl` source.\n\n#### `x-block-origin`\n\nSyntax: `x-block-origin`\n\nDisables use of the original URLs in case the mirror does not have the file available.\n","Nav":"#"},{"Path":"/en/docs/users/authentication.html","Name":"Authentication","Source":"# Authentication for Source Code\r\n\r\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/users/authentication.md).**\r\n\r\nRegistries and `vcpkg_from_git()` directly use the git command line tools to fetch remote resources. Some of these resources may be protected from anonymous access and need authentication or credentials.\r\n\r\nThe strategies below all seek to achieve the same fundamental goal: `git clone https://....` should succeed without interaction. This enables vcpkg to be separated from the specifics of your authentication scheme, ensuring forwards compatibility with any additional security improvements in the future.\r\n\r\n## Pre-seed git credentials\r\n\r\nYou can pre-seed git credentials via `git credential approve`:\r\n\r\nPowershell:\r\n```powershell\r\n\"url=https://github.com`npath=Microsoft/vcpkg`nusername=unused`npassword=$MY_PAT`n\" | git credential approve\r\n```\r\nBash:\r\n```sh\r\necho \"url=https://github.com\"$'\\n'\"path=Microsoft/vcpkg\"$'\\n'\"username=unused\"$'\\n'\"password=$MY_PAT\"$'\\n' | git credential approve\r\n```\r\n\r\n## Bearer auth\r\n\r\nFor systems which need bearer auth, you can use `git config`:\r\n\r\n**Note: you must make these config changes with `--global`**\r\n```\r\ngit config --global --unset-all http.<uri>.extraheader\r\ngit config --global http.<uri>.extraheader \"AUTHORIZATION: bearer <System_AccessToken>\"\r\n```\r\nThe `<uri>` can be filled in with a variety of options, documented in https://git-scm.com/docs/git-config#Documentation/git-config.txt-httplturlgt. For example, `https://dev.azure.com/MYORG/`.\r\n\r\n(Original Source: https://github.com/Microsoft/azure-pipelines-agent/issues/1601#issuecomment-394511048).\r\n\r\n**Note for Azure DevOps users:** You may need to enable access via Job authorization scope https://docs.microsoft.com/en-us/azure/devops/pipelines/process/access-tokens?view=azure-devops&tabs=yaml#job-authorization-scope. You may also need to \"reference\" the repo in your yaml via:\r\n\r\n```yaml\r\nresources: \r\n  repositories:\r\n    - repository: <FRIENDLYNAME>\r\n      type: git\r\n      name: <ORG>/<REPO>\r\n      tag: tags/<TAG>\r\n\r\n...\r\n\r\njobs:\r\n - job: Build\r\n   uses:\r\n     repositories: [<FRIENDLYNAME>]\r\n```\r\n\r\n## Pass credentials in an environment variable (not recommended)\r\n\r\nUsing `VCPKG_KEEP_ENV_VARS` or `VCPKG_ENV_PASSTHROUGH_UNTRACKED`, we can smuggle credential info via another var like `MY_TOKEN_VAR`.\r\n```sh\r\nexport VCPKG_KEEP_ENV_VARS=MY_TOKEN_VAR\r\nexport MY_TOKEN_VAR=abc123\r\n```\r\nThis can then be used in your private ports:\r\n```cmake\r\n# some/private/portfile.cmake\r\nset(MY_TOKEN_VAR \"\")\r\nif(DEFINED ENV{MY_TOKEN_VAR})\r\n    set(MY_TOKEN_VAR \"$ENV{MY_TOKEN_VAR}@\")\r\nendif()\r\nvcpkg_from_git(\r\n    URLS \"https://${MY_TOKEN_VAR}host.com/normal/url/path\"\r\n    ...\r\n)\r\n```\r\n```cmake\r\n# some/other/private/portfile.cmake\r\nvcpkg_from_github(\r\n    AUTHORIZATION_TOKEN \"$ENV{MY_TOKEN_VAR}\"\r\n)\r\n```\r\n\r\nFor private ports, we recommend using `vcpkg_from_git()` instead of `vcpkg_from_github()` and the pre-seeding method above.\r\n\r\n## Pass Jenkins gitUsernamePassword credentials\r\n\r\nThe simplest and most secure option to Git authentication to GitHub from Jenkins is using [GitHub App](https://github.com/jenkinsci/github-branch-source-plugin/blob/master/docs/github-app.adoc) and the following:\r\n```groovy\r\nwithCredentials([gitUsernamePassword(credentialsId: 'jenkins-github-app')]) {\r\n  withEnv(['VCPKG_KEEP_ENV_VARS=GIT_ASKPASS']) {\r\n    bat 'cmake'\r\n  }\r\n}\r\n```\r\nThis sets the GIT_ASKPASS with a path to helper script which responds with git credentials query and instructs `vcpkg` to keep this environment variable. The password is a [GitHub App token](https://github.blog/2021-04-05-behind-githubs-new-authentication-token-formats/) with 1 hour lifetime.\r\n","Nav":"#"},{"Path":"/en/docs/users/binarycaching.html","Name":"Binarycaching","Source":"# Binary Caching\n\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/users/binarycaching.md).**\n\nLibraries installed with vcpkg can always be built from source. However, that can duplicate work and waste time when working across multiple projects.\n\nBinary caching is a vcpkg feature that saves copies of library binaries in a shared location that can be accessed by vcpkg for future installs. This means that, as a user, you should only need to build dependencies from source once. If vcpkg is asked to install the same library with the same build configuration in the future, it will just copy the built binaries from the cache and finish the operation in seconds.\n\nBinary caching is especially effective when using Continuous Integration, since local developers can reuse the binaries produced during a CI run. It also greatly enhances the performance of \"ephemeral\" or \"hosted\" build agents, since all local changes are otherwise lost between runs. By using binary caching backed by a cloud service, such as GitHub, Azure, or many others, you can ensure your CI runs at maximum speed and only rebuilds your dependencies when they've changed.\n\nCaches can be hosted in a variety of environments. The most basic examples are a folder on the local machine or a network file share. Caches can also be stored in any NuGet feed (such as GitHub or Azure DevOps Artifacts), Azure Blob Storage*, or Google Cloud Storage*.\n\n\\* (experimental)\n\nIf your CI provider offers a native \"caching\" function, we recommend using both vcpkg binary caching and the native method for the most performant results.\n\nIn-tool help is available via `vcpkg help binarycaching`.\n\nTable of Contents\n - [Configuration](#configuration)\n - [CI Examples](#ci-examples)\n   - [GitHub Packages](#github-packages)\n   - [Azure DevOps Artifacts](#azure-devops-artifacts)\n   - [Azure Blob Storage](#azure-blob-storage-experimental)\n   - [Google Cloud Storage](#google-cloud-storage-experimental)\n - [NuGet Provider Configuration](#nuget-provider-configuration)\n - [Implementation Notes](#implementation-notes-internal-details-subject-to-change-without-notice)\n\n\n## Configuration\n\nBinary caching is configured via a combination of defaults, the environment variable `VCPKG_BINARY_SOURCES` (set to `<source>;<source>;...`), and the command line option `--binarysource=<source>`. Source options are evaluated in order of defaults, then environment, then command line. Binary caching can be completely disabled by passing `--binarysource=clear` as the last command line option.\n\nBy default, zip-based archives will be cached at the first valid location of:\n\n**Windows**\n1. `%VCPKG_DEFAULT_BINARY_CACHE%`\n2. `%LOCALAPPDATA%\\vcpkg\\archives`\n3. `%APPDATA%\\vcpkg\\archives`\n\n**Non-Windows**\n1. `$VCPKG_DEFAULT_BINARY_CACHE`\n2. `$XDG_CACHE_HOME/vcpkg/archives`\n3. `$HOME/.cache/vcpkg/archives`\n\n### Valid source strings (`<source>`)\n\n| form                        | description\n|-----------------------------|---------------\n| `clear`                     | Removes all previous sources (including the default)\n| `default[,<rw>]`            | Adds the default file-based location\n| `files,<absolute path>[,<rw>]`       | Adds a custom file-based location\n| `nuget,<uri>[,<rw>]`        | Adds a NuGet-based source; equivalent to the `-Source` parameter of the NuGet CLI\n| `nugetconfig,<path>[,<rw>]` | Adds a NuGet-config-file-based source; equivalent to the `-Config` parameter of the NuGet CLI. This config should specify `defaultPushSource` for uploads.\n| `nugettimeout,<seconds>`    | Specifies a timeout for NuGet network operations; equivalent to the `-Timeout` parameter of the NuGet CLI.\n| `x-azblob,<baseuri>,<sas>[,<rw>]`    | **Experimental: will change or be removed without warning**<br> Adds an Azure Blob Storage source. Uses Shared Access Signature validation. URL should include the container path.\n| `interactive`               | Enables interactive credential management for NuGet (for debugging; requires `--debug` on the command line)\n\nThe `<rw>` optional parameter for certain sources controls whether they will be consulted for\ndownloading binaries (`read`)(default), whether on-demand builds will be uploaded to that remote (`write`), or both (`readwrite`).\n\nAdditional configuration details for NuGet-based providers can be found below in [NuGet Provider Configuration](#nuget-provider-configuration).\n\n## CI Examples\n\nIf your CI system of choice is not listed, we welcome PRs to add them!\n\n### GitHub Packages\n\nTo use vcpkg with GitHub Packages, we recommend using the `NuGet` backend.\n\n>**NOTE 2020-09-21**: GitHub's hosted agents come with an older, pre-installed copy of vcpkg on the path that does not support the latest binary caching. This means that direct calls to `bootstrap-vcpkg` or `vcpkg` without a path prefix may call an unintended vcpkg instance. We recommend taking the following two steps to avoid issues if you want to use your own copy of vcpkg:\n> 1. Run the equivalent of `rm -rf \"$VCPKG_INSTALLATION_ROOT\"` using `shell: 'bash'`\n> 2. Always call `vcpkg` and `bootstrap-vcpkg` with a path prefix, such as `./vcpkg`, `vcpkg/vcpkg`, `.\\bootstrap-vcpkg.bat`, etc\n\n```yaml\n# actions.yaml\n#\n# In this example, vcpkg has been added as a submodule (`git submodule add https://github.com/Microsoft/vcpkg`).\nenv:\n  VCPKG_BINARY_SOURCES: 'clear;nuget,GitHub,readwrite'\n\nmatrix:\n  os: ['windows-2019', 'ubuntu-20.04']\n  include:\n    - os: 'windows-2019'\n      triplet: 'x86-windows'\n      mono: ''\n    - os: 'ubuntu-20.04'\n      triplet: 'x64-linux'\n      # To run `nuget.exe` on non-Windows platforms, we must use `mono`.\n      mono: 'mono'\n\nsteps:\n  # This step assumes `vcpkg` has been bootstrapped (run `./vcpkg/bootstrap-vcpkg`)\n  - name: 'Setup NuGet Credentials'\n    shell: 'bash'\n    # Replace <OWNER> with your organization name\n    run: >\n      ${{ matrix.mono }} `./vcpkg/vcpkg fetch nuget | tail -n 1`\n      sources add\n      -source \"https://nuget.pkg.github.com/<OWNER>/index.json\"\n      -storepasswordincleartext\n      -name \"GitHub\"\n      -username \"<OWNER>\"\n      -password \"${{ secrets.GITHUB_TOKEN }}\"\n\n  # Omit this step if you're using manifests\n  - name: 'vcpkg package restore'\n    shell: 'bash'\n    run: >\n      ./vcpkg/vcpkg install sqlite3 cpprestsdk --triplet ${{ matrix.triplet }}\n```\n\nIf you're using [manifests](../specifications/manifests.md), you can omit the `vcpkg package restore` step: it will be run automatically as part of your build.\n\nMore information about GitHub Packages' NuGet support is available on [GitHub Docs][github-nuget].\n\n[github-nuget]: https://docs.github.com/en/packages/using-github-packages-with-your-projects-ecosystem/configuring-dotnet-cli-for-use-with-github-packages\n\n### Azure DevOps Artifacts\n\nTo use vcpkg with Azure DevOps Artifacts, we recommend using the `NuGet` backend.\n\nFirst, you need to ensure Artifacts has been enabled on your DevOps instance; this can be done by an Administrator through `Project Settings > General > Overview > Azure DevOps Services > Artifacts`.\n\nNext, you will need to create a feed for your project; see the [Azure DevOps Artifacts Documentation][devops-nuget] for more information. Your feed URL will be an `https://` link ending with `/nuget/v3/index.json`.\n\n```yaml\n# azure-pipelines.yaml\nvariables:\n- name: VCPKG_BINARY_SOURCES\n  value: 'clear;nuget,<FEED_URL>,readwrite'\n\nsteps:\n# Remember to add this task to allow vcpkg to upload archives via NuGet\n- task: NuGetAuthenticate@0\n```\n\nIf you are using custom agents with a non-Windows OS, you will need to install Mono to run `nuget.exe` (`apt install mono-complete`, `brew install mono`, etc).\n\nMore information about Azure DevOps Artifacts' NuGet support is available in the [Azure DevOps Artifacts Documentation][devops-nuget].\n\n[devops-nuget]: https://docs.microsoft.com/en-us/azure/devops/artifacts/get-started-nuget?view=azure-devops\n\n### Azure Blob Storage (experimental)\n\n> Note: This is an experimental feature and may change or be removed at any time\n\nVcpkg supports interfacing with Azure Blob Storage via the `x-azblob` source type.\n\n```\nx-azblob,<baseuri>,<sas>[,<rw>]\n```\n\nFirst, you need to create an Azure Storage Account as well as a container ([Quick Start Documentation](https://docs.microsoft.com/en-us/azure/storage/blobs/storage-quickstart-blobs-portal)].\n\nNext, you will need to create a Shared Access Signature, which can be done from the storage account under Settings -> Shared access signature. This SAS will need:\n- Allowed services: Blob\n- Allowed resource types: Object\n- Allowed permissions: Read, Create (if using `write` or `readwrite`)\n\nThe blob endpoint plus the container must be passed as the `<baseuri>` and the generated SAS without the `?` prefix must be passed as the `<sas>`.\n\nExample:\n```\nx-azblob,https://<storagename>.blob.core.windows.net/<containername>,sv=2019-12-12&ss=b&srt=o&sp=rcx&se=2020-12-31T06:20:36Z&st=2020-12-30T22:20:36Z&spr=https&sig=abcd,readwrite\n```\n\nVcpkg will attempt to avoid revealing the SAS during normal operations, however:\n1. It will be printed in full if `--debug` is passed\n2. It will be passed as a command line parameter to subprocesses, such as `curl.exe`\n\nAzure Blob Storage includes a feature to remove cache entries that haven't been accessed in a given number of days which can be used to reduce the size of your cache. See [Data Lifecycle Management on Microsoft Docs](https://docs.microsoft.com/en-us/azure/storage/blobs/lifecycle-management-overview) for more information, or look for \"Data management > Lifecycle management\" in the Azure Portal for your storage account. If you wish to be able to be resilient to upstream libraries' servers but still want to remove entries from the binary cache, consider using [asset caching](assetcaching.md#x-azurl) in a different storage account without a lifecycle management policy.\n\n### Google Cloud Storage (experimental)\n\n> Note: This is an experimental feature and may change or be removed at any time\n\nVcpkg supports interfacing with Google Cloud Storage (GCS) via the `x-gcs` source type.\n\n```\nx-gcs,<prefix>[,<rw>]\n```\n\nFirst, you need to create an Google Cloud Platform Account as well as a storage bucket ([GCS Quick Start](https://cloud.google.com/storage/docs/quickstart-gsutil)].\n\nAs part of this quickstart you would have configured the `gsutil` command-line tool to authenticate with Google Cloud.\nVcpkg will use this command-line tool, make sure it is in your search path for executables.\n\nExample 1 (using a bucket without a common prefix for the objects):\n\n```\nx-gcs,gs://<bucket-name>/,readwrite\n```\n\nExample 2 (using a bucket and a prefix for the objects):\n\n```\nx-gcs,gs://<bucket-name>/my-vcpkg-cache/maybe/with/many/slashes/,readwrite\nx-gcs,gs://<bucket-name>/my-vcpkg-cache/maybe/with`,commas/too!/,readwrite\n```\n\nCommas (`,`) are valid as part of a object prefix in GCS, just remember to escape them in the vcpkg configuration, as\nshown in the previous example. Note that GCS does not have folders (some of the GCS tools simulate folders), it is not\nnecessary to create or otherwise manipulate the prefix used by your vcpkg cache.\n\n## NuGet Provider Configuration\n\n### Credentials\n\nMany NuGet servers require additional credentials to access. The most flexible way to supply credentials is via the `nugetconfig` provider with a custom `nuget.config` file. See https://docs.microsoft.com/en-us/nuget/consume-packages/consuming-packages-authenticated-feeds for more information on authenticating via `nuget.config`.\n\nHowever, it is still possible to authenticate against many servers using NuGet's built-in credential providers or via customizing your environment's default `nuget.config`. The default config can be extended via nuget client calls such as\n```\nnuget sources add -Name MyRemote -Source https://... -Username $user -Password $pass\n```\nand then passed to vcpkg via `--binarysource=nuget,MyRemote,readwrite`. You can get a path to the precise copy of NuGet used by vcpkg by running `vcpkg fetch nuget`, which will report something like:\n```\n$ vcpkg fetch nuget\n/vcpkg/downloads/tools/nuget-5.5.1-linux/nuget.exe\n```\nNon-Windows users will need to call this through mono via `mono /path/to/nuget.exe sources add ...`.\n\n##### Credential Example for Azure Dev Ops\n```bash\n# On Linux or OSX\n$ mono `vcpkg fetch nuget | tail -n1` sources add \\\n  -name ADO \\\n  -Source https://pkgs.dev.azure.com/$ORG/_packaging/$FEEDNAME/nuget/v3/index.json \\\n  -Username $USERNAME \\\n  -Password $PAT\n$ export VCPKG_BINARY_SOURCES=\"nuget,ADO,readwrite\"\n```\n```powershell\n# On Windows Powershell\nPS> & $(vcpkg fetch nuget | select -last 1) sources add `\n  -name ADO `\n  -Source https://pkgs.dev.azure.com/$ORG/_packaging/$FEEDNAME/nuget/v3/index.json `\n  -Username $USERNAME `\n  -Password $PAT\nPS> $env:VCPKG_BINARY_SOURCES=\"nuget,ADO,readwrite\"\n```\n\nWe recommend using a Personal Access Token (PAT) as the password for maximum security. You can generate a PAT in User Settings -> Personal Access Tokens or `https://dev.azure.com/$ORG/_usersSettings/tokens`.\n\n#### `metadata.repository`\n\nThe `nuget` and `nugetconfig` source providers additionally respect certain environment variables while generating nuget packages. The `metadata.repository` field of any packages will be generated as:\n```\n    <repository type=\"git\" url=\"${VCPKG_NUGET_REPOSITORY}\"/>\n```\nor\n```\n    <repository type=\"git\"\n                url=\"${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}.git\"\n                branch=\"${GITHUB_REF}\"\n                commit=\"${GITHUB_SHA}\"/>\n```\nif the appropriate environment variables are defined and non-empty. This is specifically used to associate packages in GitHub Packages with the _building_ project and not intended to associate with the original package sources.\n\n#### NuGet's cache\n\nNuGet's cache is not used by default. To use it for every nuget-based source, set the [environment variable](config-environment.md) `VCPKG_USE_NUGET_CACHE` to `true` (case-insensitive) or `1`.\n\n## Implementation Notes (internal details subject to change without notice)\n\nBinary caching relies on hashing everything that contributes to a particular package build. This includes:\n\n- Every file in the port directory\n- The triplet file and name\n- The C++ compiler executable\n- The C compiler executable\n- The set of features selected\n- Every dependency's package hash (note: this is that package's input hash, not contents)\n- All helper scripts referenced by `portfile.cmake` (heuristic)\n- The version of CMake used\n- The contents of any environment variables listed in `VCPKG_ENV_PASSTHROUGH`\n- The hash of the toolchain file (builtin or `VCPKG_CHAINLOAD_TOOLCHAIN_FILE`)\n\nDespite this extensive list, it is possible to defeat the cache and introduce nondeterminism. If you have additional details that you'd like to be tracked, the easiest resolution is to generate a triplet file with your additional information in a comment. That additional information will be included in the package's input set and ensure a unique universe of binaries.\n\nThe hashes used are stored in the package and in the current installed directory at `/share/<port>/vcpkg_abi_info.txt`.\n\nThe original specification for binary caching is available [here](../specifications/binarycaching.md).\n","Nav":"#"},{"Path":"/en/docs/users/buildsystems/cmake-integration.html","Name":"CMake-integration","Source":"# CMake Integration\n\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/users/buildsystems/cmake-integration.md).**\n\nSee [Installing and Using Packages Example: sqlite](../../examples/installing-and-using-packages.md) for a fully worked example using CMake.\n\n## Table of Contents\n\n- [`CMAKE_TOOLCHAIN_FILE`](#cmake_toolchain_file)\n- [IDE Integration](#ide-integration)\n  - [Visual Studio Code (CMake Tools extension)](#visual-studio-code-cmake-tools-extension)\n  - [Visual Studio](#visual-studio)\n  - [CLion](#clion)\n- [Using Multiple Toolchain Files](#using-multiple-toolchain-files)\n- [Settings Reference](#settings-reference)\n\n## `CMAKE_TOOLCHAIN_FILE`\n\nProjects configured to use the vcpkg toolchain file (via the CMake setting `CMAKE_TOOLCHAIN_FILE`) can find libraries from vcpkg using the standard CMake functions: `find_package()`, `find_path()`, and `find_library()`.\n\n```no-highlight\ncmake ../my/project -DCMAKE_TOOLCHAIN_FILE=[vcpkg-root]/scripts/buildsystems/vcpkg.cmake\n```\n\nSince version 3.21, CMake will use the environment variable `CMAKE_TOOLCHAIN_FILE`[1] as the default value for `CMAKE_TOOLCHAIN_FILE`.\n\n**cmd**\n```cmd\nset CMAKE_TOOLCHAIN_FILE=[vcpkg root]/scripts/buildsystems/vcpkg.cmake\n```\n**Powershell**\n```powershell\n$env:CMAKE_TOOLCHAIN_FILE=\"[vcpkg root]/scripts/buildsystems/vcpkg.cmake\"\n```\n**bash**\n```sh\nexport CMAKE_TOOLCHAIN_FILE=[vcpkg root]/scripts/buildsystems/vcpkg.cmake\n```\n\nvcpkg does not automatically add any include or links paths into your project. To use a header-only library you can use `find_path()` which will correctly work on all platforms:\n\n```cmake\n# To find and use catch2\nfind_path(CATCH_INCLUDE_DIR NAMES catch.hpp PATH_SUFFIXES catch2)\ninclude_directories(${CATCH_INCLUDE_DIR})\n```\n\n[1]: https://cmake.org/cmake/help/latest/envvar/CMAKE_TOOLCHAIN_FILE.html\n\n## IDE Integration\n\n### Visual Studio Code (CMake Tools Extension)\n\nAdding the following to your workspace `settings.json` will make CMake Tools automatically use vcpkg for libraries:\n\n```json\n{\n  \"cmake.configureSettings\": {\n    \"CMAKE_TOOLCHAIN_FILE\": \"[vcpkg root]/scripts/buildsystems/vcpkg.cmake\"\n  }\n}\n```\n\n### Visual Studio\n\nIn the CMake Settings Editor, add the path to the vcpkg toolchain file under `CMake toolchain file`:\n\n```\n[vcpkg root]/scripts/buildsystems/vcpkg.cmake\n```\n\n### CLion\n\nOpen the Toolchains settings (`File > Settings` on Windows and Linux, `CLion > Preferences` on macOS), and go to the CMake settings (`Build, Execution, Deployment > CMake`). In `CMake options`, add the following line:\n\n```\n-DCMAKE_TOOLCHAIN_FILE=[vcpkg root]/scripts/buildsystems/vcpkg.cmake\n```\n\nYou must add this line to each profile separately.\n\n## Using Multiple Toolchain Files\n\nTo combine vcpkg's toolchain file with another toolchain file, you can set the cmake variable `VCPKG_CHAINLOAD_TOOLCHAIN_FILE`:\n\n```no-highlight\ncmake ../my/project \\\n   -DCMAKE_TOOLCHAIN_FILE=C:/vcpkg/scripts/buildsystems/vcpkg.cmake \\\n   -DVCPKG_CHAINLOAD_TOOLCHAIN_FILE=../my/project/toolchain.cmake\n```\n\nAlternatively, you can include the vcpkg toolchain at the end of the primary toolchain file:\n\n```cmake\n# MyToolchain.cmake\nset(CMAKE_CXX_COMPILER ...)\nset(VCPKG_TARGET_TRIPLET x64-my-custom-windows-triplet)\ninclude(/path/to/vcpkg/scripts/buildsystems/vcpkg.cmake)\n```\n\n**Note: vcpkg does not automatically apply your toolchain's settings, such as your compiler or compilation flags, while building libraries. To change vcpkg's library settings, you must make a [custom triplet file](../triplets.md) (which can [share your toolchain](../triplets.md#VCPKG_CHAINLOAD_TOOLCHAIN_FILE))**\n\n## Settings Reference\n\nAll vcpkg-affecting variables must be defined before the first `project()` directive, such as via the command line or `set()` statements.\n\n### `VCPKG_TARGET_TRIPLET`\n\nThis setting controls the [triplet](../triplets.md) vcpkg will install and consume libraries from.\n\nIf unset, vcpkg will automatically detect an appropriate default triplet given the current compiler settings. If you change this CMake variable, you must delete your cache and reconfigure.\n\n### `VCPKG_HOST_TRIPLET`\n\nThis variable controls which [triplet](../triplets.md) host dependencies will be installed for.\n\nIf unset, vcpkg will automatically detect an appropriate native triplet (x64-windows, x64-osx, x64-linux).\n\nSee also [Host Dependencies](../host-dependencies.md).\n\n### `VCPKG_INSTALLED_DIR`\n\nThis variable sets the location where libraries will be installed and consumed from.\n\nIn manifest mode, the default is `${CMAKE_BINARY_DIR}/vcpkg_installed`.\n\nIn classic mode, the default is `${VCPKG_ROOT}/installed`.\n\n### `VCPKG_MANIFEST_MODE`\n\nThis variable forces vcpkg to operate in either manifest mode or classic mode.\n\nDefaults to `ON` when `VCPKG_MANIFEST_DIR` is non-empty or `${CMAKE_SOURCE_DIR}/vcpkg.json` exists.\n\nTo disable manifest mode while a `vcpkg.json` is detected, set this to `OFF`.\n\n### `VCPKG_MANIFEST_DIR`\n\nThis variable specifies an alternate folder containing a `vcpkg.json` manifest.\n\nDefaults to `${CMAKE_SOURCE_DIR}` if `${CMAKE_SOURCE_DIR}/vcpkg.json` exists.\n\n### `VCPKG_MANIFEST_INSTALL`\n\nThis variable controls whether vcpkg will be automatically run to install your dependencies during your configure step.\n\nDefaults to `ON` if `VCPKG_MANIFEST_MODE` is `ON`.\n\n### `VCPKG_BOOTSTRAP_OPTIONS`\n\nThis variable can be set to additional command parameters to pass to `./bootstrap-vcpkg`.\n\nIn manifest mode, vcpkg will be automatically bootstrapped if the executable does not exist.\n\n### `VCPKG_OVERLAY_TRIPLETS`\n\nThis variable can be set to a list of paths to be passed on the command line as `--overlay-triplets=...`\n\n### `VCPKG_OVERLAY_PORTS`\n\nThis variable can be set to a list of paths to be passed on the command line as `--overlay-ports=...`\n\n### `VCPKG_MANIFEST_FEATURES`\n\nThis variable can be set to a list of features to activate when installing from your manifest.\n\nFor example, features can be used by projects to control building with additional dependencies to enable tests or samples:\n\n```json\n{\n  \"name\": \"mylibrary\",\n  \"version\": \"1.0\",\n  \"dependencies\": [ \"curl\" ],\n  \"features\": {\n    \"samples\": {\n      \"description\": \"Build Samples\",\n      \"dependencies\": [ \"fltk\" ]\n    },\n    \"tests\": {\n      \"description\": \"Build Tests\",\n      \"dependencies\": [ \"gtest\" ]\n    }\n  }\n}\n```\n```cmake\n# CMakeLists.txt\n\noption(BUILD_TESTING \"Build tests\" OFF)\nif(BUILD_TESTING)\n  list(APPEND VCPKG_MANIFEST_FEATURES \"tests\")\nendif()\n\noption(BUILD_SAMPLES \"Build samples\" OFF)\nif(BUILD_SAMPLES)\n  list(APPEND VCPKG_MANIFEST_FEATURES \"samples\")\nendif()\n\nproject(myapp)\n\n# ...\n```\n\n### `VCPKG_MANIFEST_NO_DEFAULT_FEATURES`\n\nThis variable controls activation of default features in addition to those listed in `VCPKG_MANIFEST_FEATURES`. If set to `ON`, default features will not be automatically activated.\n\nDefaults to `OFF`.\n\n### `VCPKG_INSTALL_OPTIONS`\n\nThis variable can be set to a list of additional command line parameters to pass to the vcpkg tool during automatic installation.\n\n### `VCPKG_PREFER_SYSTEM_LIBS`\n\nThis variable controls whether vcpkg will append instead of prepend its paths to `CMAKE_PREFIX_PATH`, `CMAKE_LIBRARY_PATH` and `CMAKE_FIND_ROOT_PATH` so that vcpkg libraries/packages are found after toolchain/system libraries/packages.\n\nDefaults to `OFF`.\n\n### `VCPKG_FEATURE_FLAGS`\n\nThis variable can be set to a list of feature flags to pass to the vcpkg tool during automatic installation to opt-in to experimental behavior.\n\nSee the `--feature-flags=` command line option for more information.\n","Nav":"#"},{"Path":"/en/docs/users/buildsystems/export-command.html","Name":"Export-command","Source":"# `export` Command\n\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/users/buildsystems/export-command.md).**\n\nThe `export` command creates a shrinkwrapped archive containing a specific set of libraries (and their dependencies) that can be quickly and reliably shared with build servers or other users in your organization. `export` only supports classic mode at this time.\n\n- `--nuget`: NuGet package\n- `--zip`: Zip archive\n- `--7zip`: 7Zip archive\n- `--raw`: Raw, uncompressed folder\n\nEach of these have the same internal layout which mimics the layout of a full vcpkg instance:\n\n- `installed/` contains the library files\n- `scripts/buildsystems/vcpkg.cmake` is the [CMake toolchain file](cmake-integration.md)\n- `scripts/buildsystems/msbuild/vcpkg.props` and `scripts/buildsystems/msbuild/vcpkg.targets` are the [MSBuild integration files](msbuild-integration.md)\n\nNuGet package exports will also contain a `build\\native\\vcpkg.targets` that integrates with MSBuild projects using the NuGet package manager.\n\nPlease also see our [blog post](https://blogs.msdn.microsoft.com/vcblog/2017/05/03/vcpkg-introducing-export-command/) for additional examples.\n","Nav":"#"},{"Path":"/en/docs/users/buildsystems/integration.html","Name":"Integration","Source":"# Buildsystem Integration\n\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/users/buildsystems/integration.md).**\n\nvcpkg supports use from any buildsystem and has specific native integration into MSBuild and CMake.\n\n- [MSBuild Integration (Visual Studio)](msbuild-integration.md)\n- [CMake Integration](cmake-integration.md)\n- [Manual Integration](manual-integration.md)\n- [`export` Command](export-command.md)\n","Nav":"#"},{"Path":"/en/docs/users/buildsystems/manual-integration.html","Name":"Manual-integration","Source":"# Manual Integration\n\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/users/buildsystems/manual-integration.md).**\n\nWhen installing libraries, vcpkg creates a single common layout partitioned by triplet. \n\nThe root of the tree in classic mode is `[vcpkg root]/installed`. The root of the tree in manifest mode is `[vcpkg.json directory]/vcpkg_installed`.\n\nUnderneath this root, in a subfolder named after the triplet:\n\n* Header files: `include/`\n* Release `.lib`, `.a`, and `.so` files: `lib/` or `lib/manual-link/`\n* Release `.dll` files: `bin/`\n* Release `.pc` files: `lib/pkgconfig/`\n* Debug `.lib`, `.a`, and `.so` files: `debug/lib/` or `debug/lib/manual-link/`\n* Debug `.dll` files: `debug/bin/`\n* Debug `.pc` files: `debug/lib/pkgconfig/`\n* Tools: `tools/[portname]/`\n\nFor example, `zlib.h` for `zlib:x64-windows` in classic mode is located at `[vcpkg root]/installed/x64-windows/include/zlib.h`.\n\nSee your build system specific documentation for how to use prebuilt binaries. For example, `Makefile` projects often accept environment variables:\n\n```sh\nexport CXXFLAGS=-I$(pwd)/installed/x64-linux/include\nexport CFLAGS=-I$(pwd)/installed/x64-linux/include\nexport LDFLAGS=-L$(pwd)/installed/x64-linux/lib\nexport PKG_CONFIG_PATH=$(pwd)/installed/x64-linux/lib/pkgconfig:$PKG_CONFIG_PATH\n```\n\n_On Windows dynamic triplets, such as x64-windows:_ To run any produced executables you will also need to either copy the needed DLL files to the same folder as your executable or *prepend* the correct `bin\\` directory to your path.\n","Nav":"#"},{"Path":"/en/docs/users/buildsystems/msbuild-integration.html","Name":"Msbuild-integration","Source":"# MSBuild Integration (Visual Studio)\n\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/users/buildsystems/msbuild-integration.md).**\n\n## Table of Contents\n\n- [Integration Methods](#integration-methods)\n  - [User-wide integration](#user-wide-integration)\n  - [Import `.props` and `.targets`](#import-props-and-targets)\n  - [Linked NuGet Package](#linked-nuget-package)\n- [Common Configuration](#common-configuration)\n- [Manifest Mode Configuration](#manifest-mode-configuration)\n\n## Integration Methods\n\n### User-wide integration\n\n```no-highlight\nvcpkg integrate install\n```\nThis will implicitly add Include Directories, Link Directories, and Link Libraries for all packages installed with Vcpkg to all VS2015, VS2017 and VS2019 MSBuild projects. We also add a post-build action for executable projects that will analyze and copy any DLLs you need to the output folder, enabling a seamless F5 experience.\n\nFor the vast majority of libraries, this is all you need to do -- just File -> New Project and write code! However, some libraries perform conflicting behaviors such as redefining `main()`. Since you need to choose per-project which of these conflicting options you want, you will need to add those libraries to your linker inputs manually.\n\nHere are some examples, though this is not an exhaustive list:\n\n- Gtest provides `gtest`, `gmock`, `gtest_main`, and `gmock_main`\n- SDL2 provides `SDL2main`\n- SFML provides `sfml-main`\n- Boost.Test provides `boost_test_exec_monitor`\n\nTo get a full list for all your installed packages, run `vcpkg owns manual-link`.\n\n### Import `.props` and `.targets`\n\nvcpkg can also be integrated into MSBuild projects by explicitly importing the `scripts/buildsystems/vcpkg.props` and `scripts/buildsystems/vcpkg.targets` files into each `.vcxproj`. By using relative paths, this enables vcpkg to be consumed by a submodule and automatically acquired by users when they run `git clone`.\n\nThe easiest way to add these to every project in your solution is to create `Directory.Build.props` and `Directory.Build.targets` files at the root of your repository.\n\nThe following examples assume they are at the root of your repository with a submodule of `microsoft/vcpkg` at `vcpkg`.\n\n**Example `Directory.Build.props`**:\n```xml\n<Project>\n <Import Project=\"$(MSBuildThisFileDirectory)vcpkg\\scripts\\buildsystems\\vcpkg.props\" />\n</Project>\n```\n\n**Example `Directory.Build.targets`**:\n```xml\n<Project>\n <Import Project=\"$(MSBuildThisFileDirectory)vcpkg\\scripts\\buildsystems\\vcpkg.targets\" />\n</Project>\n```\n\nMore information about `Directory.Build.targets` and `Directory.Build.props` can be found in the [Customize your build][1] section of the official MSBuild documentation.\n\n[1]: https://docs.microsoft.com/visualstudio/msbuild/customize-your-build#directorybuildprops-and-directorybuildtargets\n\n### Linked NuGet Package\n\n**Note: This approach is not recommended for new projects, since it makes them difficult to share with others. For a portable, self-contained NuGet package, see the [`export command`](export-command.md)**\n\nVS projects can also be integrated through a NuGet package. This will modify the project file, so we do not recommend this approach for open source projects.\n\n```no-highlight\nPS D:\\src\\vcpkg> .\\vcpkg integrate project\nCreated nupkg: D:\\src\\vcpkg\\scripts\\buildsystems\\vcpkg.D.src.vcpkg.1.0.0.nupkg\n\nWith a project open, go to Tools->NuGet Package Manager->Package Manager Console and paste:\n    Install-Package vcpkg.D.src.vcpkg -Source \"D:/src/vcpkg/scripts/buildsystems\"\n```\n\n*Note: The generated NuGet package does not contain the actual libraries. It instead acts like a shortcut (or symlink) to the vcpkg install and will \"automatically\" update with any changes (install/remove) to the libraries. You do not need to regenerate or update the NuGet package.*\n\n## Common Configuration\n\n### `VcpkgEnabled` (Use Vcpkg)\n\nThis can be set to \"false\" to explicitly disable vcpkg integration for the project\n\n### `VcpkgConfiguration` (Vcpkg Configuration)\n\nIf your configuration names are too complex for vcpkg to guess correctly, you can assign this property to `Release` or `Debug` to explicitly tell vcpkg what variant of libraries you want to consume.\n\n### `VcpkgEnableManifest` (Use Vcpkg Manifest)\n\nThis property must be set to `true` in order to consume from a local `vcpkg.json` file. If set to `false`, any local `vcpkg.json` files will be ignored.\n\nThis currently defaults to `false`, but will default to `true` in the future.\n\n### `VcpkgTriplet` (Triplet)\n\nThis property controls the triplet to consume libraries from, such as `x64-windows-static` or `arm64-windows`.\n\nIf this is not explicitly set, vcpkg will deduce the correct triplet based on your Visual Studio settings. vcpkg will only deduce triplets that use dynamic library linkage and dynamic CRT linkage; if you want static dependencies or to use the static CRT (`/MT`), you will need to set the triplet manually.\n\nYou can see the automatically deduced triplet by setting your MSBuild verbosity to Normal or higher:\n\n> *Shortcut: Ctrl+Q \"build and run\"*\n>\n> Tools -> Options -> Projects and Solutions -> Build and Run -> MSBuild project build output verbosity\n\nSee also [Triplets](../triplets.md)\n\n### `VcpkgHostTriplet` (Host Triplet)\n\nThis can be set to a custom triplet to use for resolving host dependencies.\n\nIf unset, this will default to the \"native\" triplet (x64-windows).\n\nSee also [Host Dependencies](../host-dependencies.md).\n\n### `VcpkgInstalledDir` (Installed Directory)\n\nThis property defines the location vcpkg will install and consume libraries from.\n\nIn manifest mode, this defaults to `$(VcpkgManifestRoot)\\vcpkg_installed\\$(VcpkgTriplet)\\`. In classic mode, this defaults to `$(VcpkgRoot)\\installed\\`.\n\n## Manifest Mode Configuration\n\nTo use manifests (`vcpkg.json`) with MSBuild, first you need to use one of the integration methods above. Then, add a vcpkg.json above your project file (such as in the root of your source repository) and set the property `VcpkgEnableManifest` to `true`. You can set this property via the IDE in `Project Properties -> Vcpkg -> Use Vcpkg Manifest` (note: you may need to reload the IDE to see the vcpkg Property Page).\n\nvcpkg will automatically run during your project's build and install any listed dependencies to `vcpkg_installed/$(VcpkgTriplet)/` adjacent to the `vcpkg.json` file; these libraries will then automatically be included in and linked to your MSBuild projects.\n\n**Known issues**\n\n* Visual Studio 2015 does not correctly track edits to the `vcpkg.json` and `vcpkg-configuration.json` files, and will not respond to changes unless a `.cpp` is edited.\n\n<a id=\"vcpkg-additional-install-options\"></a>\n\n### `VcpkgAdditionalInstallOptions` (Additional Options)\n\nWhen using a manifest, this option specifies additional command line flags to pass to the underlying vcpkg tool invocation. This can be used to access features that have not yet been exposed through another option.\n\n### `VcpkgManifestInstall` (Install Vcpkg Dependencies)\n\nThis property can be set to `false` to disable automatic dependency restoration during project build. Dependencies must be manually restored via the vcpkg command line separately.\n","Nav":"#"},{"Path":"/en/docs/users/config-environment.html","Name":"Config-environment","Source":"## Environment and Configuration\r\n\r\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/users/config-environment.md).**\r\n\r\n### Environment Variables\r\n\r\n#### VCPKG_DOWNLOADS\r\n\r\nThis environment variable can be set to an existing directory to use for storing downloads instead of the internal\r\n`downloads/` directory. It should always be set to an absolute path.\r\n\r\n#### VCPKG_FEATURE_FLAGS\r\n\r\nThis environment variable can be set to a comma-separated list of off-by-default features in vcpkg. These features are\r\nsubject to change without notice and should be considered highly unstable.\r\n\r\nThere are no off-by-default feature flags at this time.\r\n\r\n#### EDITOR\r\n\r\nThis environment variable can be set to the full path of an executable to be used for `vcpkg edit`. Please see\r\n`vcpkg help edit` for command-specific help.\r\n\r\n#### VCPKG_ROOT\r\n\r\nThis environment variable can be set to a directory to use as the root of the vcpkg instance. Note that mixing vcpkg\r\nrepo versions and executable versions can cause issues.\r\n\r\n#### VCPKG_VISUAL_STUDIO_PATH\r\n\r\nThis environment variable can be set to the full path to a Visual Studio instance on the machine. This Visual Studio instance\r\nwill be used if the triplet does not override it via the [`VCPKG_VISUAL_STUDIO_PATH`](triplets.md#VCPKG_VISUAL_STUDIO_PATH) triplet setting.\r\n\r\nExample: `D:\\2017`\r\n\r\n#### VCPKG_DEFAULT_TRIPLET\r\n\r\nThis environment variable can be set to a triplet name which will be used for unqualified triplet references in command lines.\r\n\r\n#### VCPKG_DEFAULT_HOST_TRIPLET\r\n\r\nThis environment variable can be set to a triplet name which will be used for unqualified host port references in command lines and all host port references in dependency lists. See [the host-dependencies documentation](host-dependencies.md) for more information.\r\n\r\n#### VCPKG_OVERLAY_PORTS\r\n\r\nThis environment variable allows users to override ports with alternate versions according to the\r\n[ports overlay](../specifications/ports-overlay.md) specification. List paths to overlays using\r\nthe platform dependent PATH separator (Windows `;` | others `:`)\r\n\r\nExample (Windows): `C:\\custom-ports\\boost;C:\\custom-ports\\sqlite3`\r\n\r\n#### VCPKG_OVERLAY_TRIPLETS\r\n\r\nThis environment variable allows users to add directories to search for triplets.\r\n[Example: overlay triplets](../examples/overlay-triplets-linux-dynamic.md).\r\nList paths to overlays using the platform dependent PATH separator (Windows `;`, others `:`)\r\n\r\n#### VCPKG_FORCE_SYSTEM_BINARIES\r\n\r\nThis environment variable, if set, suppresses the downloading of CMake and Ninja and forces the use of the system binaries.\r\n\r\n#### VCPKG_KEEP_ENV_VARS\r\n\r\nThis environment variable can be set to a list of environment variables, separated by `;`, which will be propagated to\r\nthe build environment.\r\n\r\nThe values of the kept variables will not be tracked in package ABIs and will not cause rebuilds when they change. To\r\npass in environment variables that should cause rebuilds on change, see [`VCPKG_ENV_PASSTHROUGH`](triplets.md#VCPKG_ENV_PASSTHROUGH).\r\n\r\nExample: `FOO_SDK_DIR;BAR_SDK_DIR`\r\n\r\n#### VCPKG_MAX_CONCURRENCY\r\n\r\nThis environment variables limits the amount of concurrency requested by underlying buildsystems. If unspecified, this defaults to logical cores + 1.\r\n\r\n#### VCPKG_DEFAULT_BINARY_CACHE\r\n\r\nThis environment variable redirects the default location to store binary packages. See [Binary Caching](binarycaching.md#configuration) for more details.\r\n\r\n#### VCPKG_BINARY_SOURCES\r\n\r\nThis environment variable adds or removes binary sources. See [Binary Caching](binarycaching.md#configuration) for more details.\r\n\r\n#### VCPKG_NUGET_REPOSITORY\r\n\r\nThis environment variable changes the metadata of produced NuGet packages. See [Binary Caching](binarycaching.md#configuration) for more details.\r\n\r\n#### VCPKG_USE_NUGET_CACHE\r\n\r\nThis environment variable allows using NuGet's cache for every nuget-based binary source. See [Binary Caching](binarycaching.md#nuget-provider-configuration) for more details.\r\n\r\n#### X_VCPKG_ASSET_SOURCES\r\n\r\n> Note: This is an experimental feature and may change or be removed at any time\r\n\r\nThis environment variable allows using a private mirror for all SHA512-tagged assets. See [Asset Caching](assetcaching.md) for more details.\r\n","Nav":"#"},{"Path":"/en/docs/users/host-dependencies.html","Name":"Host-dependencies","Source":"# Host Dependencies\n\nTools used at build time by other ports to generate code or implement a custom build system can be packaged inside vcpkg.\n\n## Consuming\n\nWhen consuming a port as a tool, you must set the dependency's `\"host\"` field to true. For example:\n```json\n{\n    \"name\": \"contoso-http-library\",\n    \"version-string\": \"1.0.0\",\n    \"description\": \"Contoso's http runtime library\",\n    \"dependencies\": [\n        \"contoso-core-library\",\n        {\n            \"name\": \"contoso-code-generator\",\n            \"host\": true\n        },\n        {\n            \"name\": \"contoso-build-system\",\n            \"host\": true\n        }\n    ]\n}\n```\nIn this case, the `contoso-code-generator` and `contoso-build-system` (including any transitive dependencies) will be built and installed for the host triplet before `contoso-http-library` is built.\n\n>Note: Consumers must use `vcpkg.json` instead of `CONTROL` as their metadata format. You can easily convert an existing `CONTROL` file using `vcpkg format-manifest /path/to/CONTROL`.\n\nThen, within the portfile of the consumer (`contoso-http-library` in the example), the CMake variable `CURRENT_HOST_INSTALLED_DIR` will be defined to `installed/<host-triplet>` and should be used to locate any required assets. In the example, `contoso-code-generator` might have installed `tools/contoso-code-generator/ccg.exe` which the consumer would add to its local path via\n```cmake\n# ports/contoso-http-library/portfile.cmake\nvcpkg_add_to_path(${CURRENT_HOST_INSTALLED_DIR}/tools/contoso-code-generator)\n```\n\n## Specifying the Host Triplet\n\nThe default host triplets are chosen based on the host architecture and operating system, for example `x64-windows`, `x64-linux`, or `x64-osx`. They can be overridden via:\n\n1. In CMake-based manifest mode, calling `set(VCPKG_HOST_TRIPLET \"<triplet>\" CACHE STRING \"\")` before the first `project()` directive\n2. In MSBuild-based manifest mode, setting the `VcpkgHostTriplet` property\n3. On the command line, via the flag `--host-triplet=...`\n4. The `VCPKG_DEFAULT_HOST_TRIPLET` environment variable\n\n## Producing\n\nProducing a tool has no special requirements; tools should be authored as a standard port, following all the normal policies and practices. Notably, they should build against `TARGET_TRIPLET`, not `HOST_TRIPLET` within the context of their portfile.\n\nIf the current context is cross-compiling (`TARGET_TRIPLET` is not `HOST_TRIPLET`), then `VCPKG_CROSSCOMPILING` will be set to a truthy value.\n\n```cmake\nif(VCPKG_CROSSCOMPILING)\n    # This is a native build\nelse()\n    # This is a cross build\nendif()\n```\n\n## Host-only ports\n\nSome ports should only be depended upon via a host dependency; script ports and\ntool ports are common examples. In this case, you can use the `\"native\"`\nsupports expression to describe this. This supports expression is true when\n`VCPKG_CROSSCOMPILING` is false (implying that `TARGET_TRIPLET ==\nHOST_TRIPLET`).\n","Nav":"#"},{"Path":"/en/docs/users/manifests.html","Name":"Manifests","Source":"# Manifest Mode\n\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/users/manifests.md).**\n\nvcpkg has two modes of consuming dependencies - classic mode and manifest mode.\n\nIn classic mode, vcpkg produces an \"installed\" tree, whose contents are changed by explicit calls to `vcpkg install` or\n`vcpkg remove`. The installed tree is intended for consumption by any number of projects: for example, installing a\nbunch of libraries and then using those libraries from Visual Studio, without additional configuration. Because the\ninstalled tree is not associated with an individual project, it's similar to tools like `brew` or `apt`, except that the\ninstalled tree is vcpkg-installation-local, rather than global to a system or user.\n\nIn manifest mode, an installed tree is associated with a particular project rather than the vcpkg installation. The set\nof installed ports is controlled by editing the project's \"manifest file\", and the installed tree is placed in the\nproject directory or build directory. This mode acts more similarly to language package managers like Cargo, or npm. We\nrecommend using this manifest mode whenever possible, because it allows one to encode a project's dependencies\nexplicitly in a project file, rather than in the documentation, making your project much easier to consume.\n\nCheck out the [manifest cmake example](../examples/manifest-mode-cmake.md) for an example project using CMake and\nmanifest mode.\n\n## Table of Contents\n\n- [Simple Example Manifest](#simple-example-manifest)\n- [Manifest Syntax Reference](#manifest-syntax-reference)\n- [Command Line Interface](#command-line-interface)\n\nSee also [the original specification](../specifications/manifests.md) for more low-level details.\n\n## Simple Example Manifest\n\n```json\n{\n  \"$schema\": \"https://raw.githubusercontent.com/microsoft/vcpkg/master/scripts/vcpkg.schema.json\",\n  \"name\": \"my-application\",\n  \"version\": \"0.15.2\",\n  \"dependencies\": [\n    \"boost-system\",\n    {\n      \"name\": \"cpprestsdk\",\n      \"default-features\": false\n    },\n    \"libxml2\",\n    \"yajl\"\n  ]\n}\n```\n\n## Manifest Syntax Reference\n\nA manifest is a JSON-formatted file named `vcpkg.json` which lies at the root of your project.\nIt contains all the information a person needs to know to get dependencies for your project,\nas well as all the metadata about your project that a person who depends on you might be interested in.\n\nManifests follow strict JSON: they can't contain C++-style comments (`//`) nor trailing commas. However\nyou can use field names that start with `$` to write your comments in any object that has a well-defined set of keys.\nThese comment fields are not allowed in any objects which permit user-defined keys (such as `\"features\"`).\n\nEach manifest contains a top level object with the fields documented below; the most important ones are\n[`\"name\"`](#name), the [version fields](#version-fields), and [`\"dependencies\"`](#dependencies):\n\n### `\"name\"`\n\nThis is the name of your project! It must be formatted in a way that vcpkg understands - in other words,\nit must be lowercase alphabetic characters, digits, and hyphens, and it must not start nor end with a hyphen.\nFor example, `Boost.Asio` might be given the name `boost-asio`.\n\nThis is a required field.\n\n### Version fields\n\nThere are four version field options, depending on how the port orders its\nreleases.\n\n* [`\"version\"`](versioning.md#version) - Generic, dot-separated numeric\n  sequence.\n* [`\"version-semver\"`](versioning.md#version-semver) - [Semantic Version\n  2.0.0](https://semver.org/#semantic-versioning-specification-semver)\n* [`\"version-date\"`](versioning.md#version-date) - Used for packages which do\n  not have numeric releases (for example, Live-at-HEAD). Matches `YYYY-MM-DD`\n  with optional trailing dot-separated numeric sequence.\n* [`\"version-string\"`](versioning.md#version-string) - Used for packages that\n  don't have orderable versions. This should be rarely used, however all ports\n  created before the other version fields were introduced use this scheme.\n\nAdditionally, the optional `\"port-version\"` field is used to indicate revisions\nto the port with the same upstream source version. For pure consumers, this\nfield should not be used.\n\nSee [versioning](versioning.md#version-schemes) for more details.\n\n### `\"description\"`\n\nThis is where you describe your project. Give it a good description to help in searching for it!\nThis can be a single string, or it can be an array of strings;\nin the latter case, the first string is treated as a summary,\nwhile the remaining strings are treated as the full description.\n\n### `\"builtin-baseline\"`\n\nThis field indicates the commit of vcpkg which provides global minimum version\ninformation for your manifest. It is required for top-level manifest files using\nversioning.\n\nThis is a convenience field that has the same semantic as replacing your default\nregistry in\n[`vcpkg-configuration.json`](registries.md#configuration-default-registry).\n\nSee [versioning](versioning.md#builtin-baseline) for more semantic details.\n\n### `\"dependencies\"`\n\nThis field lists all the dependencies you'll need to build your library (as well as any your dependents might need,\nif they were to use you). It's an array of strings and objects:\n\n* A string dependency (e.g., `\"dependencies\": [ \"zlib\" ]`) is the simplest way one can depend on a library;\n  it means you don't depend on a single version, and don't need to write down any more information.\n* On the other hand, an object dependency (e.g., `\"dependencies\": [ { \"name\": \"zlib\" } ]`)\n  allows you to add that extra information.\n\n#### Example:\n\n```json\n\"dependencies\": [\n  {\n    \"name\": \"arrow\",\n    \"default-features\": false,\n    \"features\": [ \"json\" ]\n  },\n  \"boost-asio\",\n  \"openssl\",\n  {\n    \"name\": \"picosha2\",\n    \"platform\": \"!windows\"\n  }\n]\n```\n\n#### `\"name\"` Field\n\nThe name of the dependency. This follows the same restrictions as the [`\"name\"`](#name) property for a project.\n\n#### `\"features\"` and `\"default-features\"` Fields\n\n`\"features\"` is an array of feature names which tell you the set of features that the\ndependencies need to have at a minimum,\nwhile `\"default-features\"` is a boolean that tells vcpkg whether or not to\ninstall the features the package author thinks should be \"most common for most people to use\".\n\nFor example, `ffmpeg` is a library which supports many, many audio and video codecs;\nhowever, for your specific project, you may only need mp3 encoding.\nThen, you might just ask for:\n\n```json\n{\n  \"name\": \"ffmpeg\",\n  \"default-features\": false,\n  \"features\": [ \"mp3lame\" ]\n}\n```\n\n<a id=\"platform\"></a>\n#### `\"platform\"` Field\n\nThe `\"platform\"` field defines the platforms where the dependency should be installed - for example,\nyou might need to use sha256, and so you use platform primitives on Windows, but `picosha2` on non-Windows platforms.\n\n```json\n{\n  \"name\": \"picosha2\",\n  \"platform\": \"!windows\"\n}\n```\n\nThis is a string field which takes boolean expressions of the form `<identifier>`,\n`!expression`, `expression { & expression & expression...}`, and `expression { | expression | expression...}`,\nalong with parentheses to denote precedence.\nFor example, a dependency that's only installed on the Windows OS, for the ARM64 architecture,\nand on Linux on x64, would be written `(windows & arm64) | (linux & x64)`.\n\nThe common identifiers are:\n\n- The operating system: `windows`, `uwp`, `linux`, `osx` (includes macOS), `android`, `emscripten`\n- The architecture: `x86`, `x64`, `wasm32`, `arm64`, `arm` (includes both arm32 and arm64 due to backwards compatibility)\n\nalthough one can define their own.\n\n#### `\"version>=\"` Field\n\nA minimum version constraint on the dependency.\n\nThis field specifies the minimum version of the dependency, optionally using a\n`#N` suffix to denote port-version if non-zero.\n\nSee also [versioning](versioning.md#version-1) for more semantic details.\n\n### `\"overrides\"`\n\nThis field pins exact versions for individual dependencies.\n\n`\"overrides\"` from transitive manifests (i.e. from dependencies) are ignored.\n\nSee also [versioning](versioning.md#overrides) for more semantic details.\n\n#### Example:\n\n```json\n  \"overrides\": [\n    {\n      \"name\": \"arrow\", \"version\": \"1.2.3\", \"port-version\": 7\n    }\n  ]\n```\n\n### `\"supports\"`\n\nIf your project doesn't support common platforms, you can tell your users this with the `\"supports\"` field.\nIt uses the same platform expressions as [`\"platform\"`](#platform), from dependencies, as well as the\n`\"supports\"` field of features.\nFor example, if your library doesn't support linux, you might write `{ \"supports\": \"!linux\" }`.\n\n\n### `\"features\"` and `\"default-features\"`\n\nThe `\"features\"` field defines _your_ project's optional features, that others may either depend on or not.\nIt's an object, where the keys are the names of the features, and the values are objects describing the feature.\n`\"description\"` is required,\nand acts exactly like the [`\"description\"`](#description) field on the global package,\nand `\"dependencies\"` are optional,\nand again act exactly like the [`\"dependencies\"`](#dependencies) field on the global package.\nThere's also the `\"supports\"` field,\nwhich again acts exactly like the [`\"supports\"`](#supports) field on the global package.\n\nYou also have control over which features are default, if a person doesn't ask for anything specific,\nand that's the `\"default-features\"` field, which is an array of feature names.\n\n#### Example:\n\n```json\n{\n  \"name\": \"libdb\",\n  \"version\": \"1.0.0\",\n  \"description\": [\n    \"An example database library.\",\n    \"Optionally can build with CBOR, JSON, or CSV as backends.\"\n  ],\n  \"$default-features-explanation\": \"Users using this library transitively will get all backends automatically\",\n  \"default-features\": [ \"cbor\", \"csv\", \"json\" ],\n  \"features\": {\n    \"cbor\": {\n      \"description\": \"The CBOR backend\",\n      \"dependencies\": [\n        {\n          \"$explanation\": [\n            \"This is how you tell vcpkg that the cbor feature depends on the json feature of this package\"\n          ],\n          \"name\": \"libdb\",\n          \"default-features\": false,\n          \"features\": [ \"json\" ]\n        }\n      ]\n    },\n    \"csv\": {\n      \"description\": \"The CSV backend\",\n      \"dependencies\": [\n        \"fast-cpp-csv-parser\"\n      ]\n    },\n    \"json\": {\n      \"description\": \"The JSON backend\",\n      \"dependencies\": [\n        \"jsoncons\"\n      ]\n    }\n  }\n}\n```\n\n## Command Line Interface\n\nWhen invoked from any subdirectory of the directory containing `vcpkg.json`, `vcpkg install` with no package arguments\nwill install all manifest dependencies into `<directory containing vcpkg.json>/vcpkg_installed/`. Most of `vcpkg\ninstall`'s classic mode parameters function the same in manifest mode.\n\n### `--x-install-root=<path>`\n\n**Experimental and may change or be removed at any time**\n\nSpecifies an alternate install location than `<directory containing vcpkg.json>/vcpkg_installed/`.\n\n### `--triplet=<triplet>`\n\nSpecify the triplet to be used for installation.\n\nDefaults to the same default triplet as in classic mode.\n\n### `--x-feature=<feature>`\n\n**Experimental and may change or be removed at any time**\n\nSpecify an additional feature from the `vcpkg.json` to install dependencies from.\n\n### `--x-no-default-features`\n\n**Experimental and may change or be removed at any time**\n\nDisables automatic activation of all default features listed in the `vcpkg.json`.\n\n### `--x-manifest-root=<path>`\n\n**Experimental and may change or be removed at any time**\n\nSpecifies the directory containing `vcpkg.json`.\n\nDefaults to searching upwards from the current working directory.\n","Nav":"#"},{"Path":"/en/docs/users/mingw.html","Name":"Mingw","Source":"# Vcpkg and Mingw-w64\n\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/users/mingw.md).**\n\n*MinGW is not tested as part of vcpkg repository's CI process, so regressions can occur as part of library updates. PRs improving support are welcome!*\n\n## Table of Contents\n\n - [Mingw-w64 community triplets](#mingw-w64-community-triplets)\n - [Using Mingw-w64 natively on Windows](#mingw-native)\n   - [How to avoid mixing different installations](#how-to-avoid-mixing-different-installations)\n - [Using Mingw-w64 to build Windows programs on other systems](#mingw-cross)\n\n## Mingw-w64 community triplets\n\nVcpkg includes\n[x64, x86, arm64 and arm community triplets](https://github.com/microsoft/vcpkg/tree/master/triplets/community)\nfor [Mingw-w64](http://mingw-w64.org/). They don't depend on Visual Studio and\ncan be used natively on Windows as well as for cross-compiling on\nother operating systems. There are two variants of each triplet,\nselecting between static and dynamic linking. The actual tools\n(g++ etc.) are expected to be named with particular prefixes.\n\n| architecture | vcpkg community triplets                | tool name prefix     |\n|--------------|-----------------------------------------|----------------------|\n| x64          | x64-mingw-dynamic, x64-mingw-static     | x86_64-w64-mingw32-  |\n| x86          | x86-mingw-dynamic, x86-mingw-static     | i686-w64-mingw32-    |\n| arm64        | arm64-mingw-dynamic, arm64-mingw-static | aarch64-w64-mingw32- |\n| arm          | arm-mingw-dynamic, arm-mingw-static     | armv7-w64-mingw32-   |\n\nThese triplets are not tested by continuous integration, so many ports\ndo not build, and even existing ports may break on port updates.\nBecause of this, community involvement is paramount!\n\n- [Discussions](https://github.com/microsoft/vcpkg/discussions?discussions_q=mingw)\n- [Open issues](https://github.com/microsoft/vcpkg/issues?q=is%3Aissue+is%3Aopen+mingw)\n- [Open pull requests](https://github.com/microsoft/vcpkg/pulls?q=is%3Apr+is%3Aopen+mingw)\n\n<a id=\"mingw-native\"></a>\n## Using Mingw-w64 natively on Windows\n\nWith [MSYS2](https://www.msys2.org/), it is possible to easily create\na full environment for building ports with Mingw-w64 on a Windows PC.\n\nNote that for building software for native windows environments, you\nmust use a mingw subsystem of MSYS2, and install some packages \n(with a specific prefix) for this subsystem.\n\n| architecture | vcpkg triplets                      | subsystem | package prefix    |\n|--------------|-------------------------------------|-----------|-------------------|\n| x64          | x64-mingw-dynamic, x64-mingw-static | mingw64   | mingw-w64-x86_64- |\n| x86          | x86-mingw-dynamic, x86-mingw-static | mingw32   | mingw-w64-i686-   |\n\nAfter the basic installation of MSYS2, you will need to install a few\nadditional packages for software development, e.g. for x64:\n\n```bash\npacman -S --needed git base-devel mingw-w64-x86_64-toolchain\n```\n\nThe active subsystem is selected by running the MSYS2 MinGW app, or\nchanged in a running terminal by\n\n```bash\nsource shell mingw64   # for x64, or \"mingw32\" for x86\n```\n\nThe bootstrapping of vcpkg shall be done by running bootstrap-vcpkg.bat.\nThis will download the official vcpkg.exe.\n\n```bash\ngit clone https://github.com/microsoft/vcpkg.git\ncd vcpkg\n./bootstrap-vcpkg.bat\n```\n\nFor building packages, you need to tell vcpkg that you want to use the\nmingw triplet. This can be done in different ways. When Visual Studio\nis not installed, you must also set the host triplet to mingw. This is\nneeded to resolve host dependencies. For convenience, you can use\nenvironment variables to set both triplets:\n\n```bash\nexport VCPKG_DEFAULT_TRIPLET=x64-mingw-dynamic\nexport VCPKG_DEFAULT_HOST_TRIPLET=x64-mingw-dynamic\n```\n\nNow you can test your setup:\n\n```bash\n./vcpkg install zlib\n```\n\n### How to avoid mixing different installations\n\n[The MSYS2 project explicitly warns](https://www.msys2.org/wiki/MSYS2-introduction/#path)\nthat \"mixing in programs from other MSYS2 installations, Cygwin installations,\ncompiler toolchains or even various other programs is not supported and will\nprobably break things in unexpected ways.\" For example, the proper passing of\ncommand line arguments with quoting and escaping may fail.\n\nBut Vcpkg ports implicitly create MSYS2 installations, e.g. for `pkg-config`\nand for various other build tools needed to deal with packages based on\nautoconf. In particular, when ports prepend the directory of tools to the\n`PATH` environment variable, this may change which tool with a particular\nname is actually invoked, and how arguments are passed between tools.\n\nTo mitigate such issues when working with a full MSYS2 installation,\ntry to keep the directories of the msys subsystem (`/usr/bin`, `bin`)\nout of the `PATH` environment variable as found by vcpkg. In bash, you\nmay modify the `PATH` just for a single call of vcpkg:\n\n```bash\nPATH=\"${PATH/:\\/usr\\/bin:\\/bin:/:}\" ./vcpkg install libpq\n```\n\nAlternatively, you may run vcpkg from a regular Command Prompt, after\nadding *only* the desired mingw directory (e.g. `C:\\msys64\\mingw64\\bin`)\nto the `PATH`.\n\nWhen using vcpkg for CI with standard images on Azure Pipelines, Github Actions\nor similar, note that the default `PATH` might contain more directories\nwhich create a mix of MSYS2 programs from different installations. You may\nwant to set the desired `PATH` manually, or remove directories which contain\n`sh.exe`, `bash.exe`, `msys-2.0.dll` or `cygwin1.dll`.\n\n<a id=\"mingw-cross\"></a>\n## Using Mingw-w64 to build Windows programs on other systems\n\nYou can use the vcpkg mingw community triplets with toolchains on\nnon-Windows computers to cross-compile software to be run on Windows.\nMany Linux distributions offer such toolchains in optional packages\nwith a mingw-w64 [suffix](https://repology.org/projects/?search=-mingw-w64)\nor [prefix](https://repology.org/projects/?search=mingw-w64-).\nAs an example, for Debian-based distributions, you would start with\nthis installation command for the x64 toolchain:\n\n```\nsudo apt-get install gcc-mingw-w64-x86-64 g++-mingw-w64-x86-64\n```\n\nNote that the packaged versions of Mingw-w64 toolchains on Linux distributions\nmight be older releases which lack some useful features or bug fixes.\nAn alternative independent toolchain is offered by [MXE](https://mxe.cc/).\n\nFor vcpkg bootstrapping, clone the github repository and run the\n`bootstrap-vcpkg.sh` script:\n\n```bash\ngit clone https://github.com/microsoft/vcpkg.git\ncd vcpkg\n./bootstrap-vcpkg.sh\n./vcpkg install zlib:x64-mingw-dynamic\n```\n\n","Nav":"#"},{"Path":"/en/docs/users/registries.html","Name":"Registries","Source":"# Using Registries\n\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/users/registries.md).**\n\nThere are two parts to using registries; this documents the use side of the\nrelationship. In order to learn more about creating registries for others to\nuse, please read [this documentation](../maintainers/registries.md).\n\n## Table of Contents\n\n- [Using Registries](#using-registries)\n  - [Table of Contents](#table-of-contents)\n  - [`vcpkg-configuration.json`](#vcpkg-configurationjson)\n    - [Registry Objects](#registry-objects)\n      - [Registry Objects: `\"kind\"`](#registry-objects-kind)\n      - [Registry Objects: `\"baseline\"`](#registry-objects-baseline)\n      - [Registry Objects: `\"repository\"`](#registry-objects-repository)\n      - [Registry Objects: `\"path\"`](#registry-objects-path)\n    - [Configuration: `\"default-registry\"`](#configuration-default-registry)\n    - [Configuration: `\"registries\"`](#configuration-registries)\n    - [Example Configuration File](#example-configuration-file)\n  - [Package Name Resolution](#package-name-resolution)\n    - [Versioning Support](#versioning-support)\n\n## `vcpkg-configuration.json`\n\nFrom a high level perspective, everything that a project needs to define\nabout registries is contained in the vcpkg configuration file. In classic\nmode, the configuration file lies in the vcpkg root; for manifest mode,\nthe file must exist next to the project's `vcpkg.json` file.\nThis file is named `vcpkg-configuration.json`, and it's a simple top-level\nobject file.\n\n### Registry Objects\n\nRegistries are defined in JSON as objects. They must contain at least the\n`\"kind\"` and `\"baseline\"` fields, and additionally the different kinds of\nregistry will have their own way of defining where the registry can be found:\n\n- git registries require the `\"repository\"` field\n- filesystem registries require the `\"path\"` field\n- built-in registries do not require a field, since there is only one\n  built-in registry.\n\n#### Registry Objects: `\"kind\"`\n\nThe `\"kind\"` field must be a string:\n\n- For git registries: `\"git\"`\n- For filesystem registries: `\"filesystem\"`\n- For the builtin registry: `\"builtin\"`\n\n#### Registry Objects: `\"baseline\"`\n\nThe `\"baseline\"` field must be a string. For git registries and for the \nbuilt-in registry, it should be a 40-character commit ID.\nFor filesystem registries, it can be any string that the registry defines.\n\n#### Registry Objects: `\"repository\"`\n\nThis should be a string, of any repository format that git understands:\n\n- `\"https://github.com/microsoft/vcpkg\"`\n- `\"git@github.com:microsoft/vcpkg\"`\n- `\"/dev/vcpkg-registry\"`\n\n#### Registry Objects: `\"path\"`\n\nThis should be a path; it can be either absolute or relative; relative paths\nwill be based at the directory the `vcpkg-configuration.json` lives in.\n\n### Configuration: `\"default-registry\"`\n\nThe `\"default-registry\"` field should be a registry object. It defines\nthe registry that is used for all packages that are not claimed by any\npackage registries. It may also be `null`, in which case no packages that\nare not claimed by package registries may be installed.\n\n### Configuration: `\"registries\"`\n\nThe `\"registries\"` field should be an array of registry objects, each of\nwhich additionally contain a `\"packages\"` field, which should be an array of\npackage names. These define the package registries, which are used for \nthe specific packages named by the `\"packages\"` field.\n\nThe `\"packages\"` fields of all the package registries must be disjoint.\n\n### Example Configuration File\n\nLet's assume that you have mirrored <https://github.com/microsoft/vcpkg> at\n<https://git.example.com/vcpkg>: this will be your default registry.\nAdditionally, you want to use North Wind Trader's registry for their\nbeison and beicode libraries. The following `vcpkg-configuration.json`\nwill work:\n\n```json\n{\n  \"default-registry\": {\n    \"kind\": \"git\",\n    \"repository\": \"https://internal/mirror/of/github.com/Microsoft/vcpkg\",\n    \"baseline\": \"eefee7408133f3a0fef711ef9c6a3677b7e06fd7\"\n  },\n  \"registries\": [\n    {\n      \"kind\": \"git\",\n      \"repository\": \"https://github.com/northwindtraders/vcpkg-registry\",\n      \"baseline\": \"dacf4de488094a384ca2c202b923ccc097956e0c\",\n      \"packages\": [ \"beicode\", \"beison\" ]\n    }\n  ]\n}\n```\n\n## Package Name Resolution\n\nThe way package name resolution works in vcpkg is fairly distinct from many\npackage managers. It is very carefully designed to _never_ implicitly choose\nthe registry that a package is fetched from. Just from\n`vcpkg-configuration.json`, one can tell exactly from which registry a\npackage definition will be fetched from.\n\nThe name resolution algorithm is as follows:\n\n- If there is a package registry that claims the package name,\n  use that registry; otherwise\n- If there is a default registry defined, use that registry; otherwise\n- If the default registry is set to `null`, error out; otherwise\n- use the built-in registry.\n\n### Versioning Support\n\nVersioning with custom registries works exactly as it does in the built-in\nregistry. You can read more about that in the [versioning documentation].\n\n[versioning documentation]: versioning.md","Nav":"#"},{"Path":"/en/docs/users/selecting-library-features.html","Name":"Selecting-library-features","Source":"# Selecting Library Features\n\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/users/selecting-library-features.md).**\n\n## Installing a library\n\nWe will look at [llvm](https://llvm.org/) as an example. You could install it using:\n\n```powershell\n> vcpkg install llvm\n```\nor via a manifest with\n```json\n{\n  \"dependencies\": [\"llvm\"]\n}\n```\n\nWith llvm now installed, we can execute:\n\n```powershell\n> installed\\x86-windows\\bin\\llc.exe --version\n```\n\nwe see:\n\n```powershell\n  Registered Targets:\n    x86    - 32-bit X86: Pentium-Pro and above\n    x86-64 - 64-bit X86: EM64T and AMD64\n```\n\n## Installing additional features\n\nBut [llvm supports many more targets](https://llvm.org/docs/GettingStarted.html#local-llvm-configuration), from ARM to SPARC to SystemZ.\nHowever, clearly our current installation doesn't include ARM as a target;\nthus, we need to learn how vcpkg allows us to install other LLVM targets.\nThe llvm port allows this via the \"target-*\" features.\n\nIf we do:\n\n```powershell\n> vcpkg search llvm\n```\n\nWe can see:\n\n```\nllvm                 10.0.0#6         The LLVM Compiler Infrastructure\nllvm[clang]                           Build C Language Family Front-end.\nllvm[clang-tools-extra]               Build Clang tools.\n...\nllvm[target-all]                      Build with all backends.\nllvm[target-amdgpu]                   Build with AMDGPU backend.\nllvm[target-arm]                      Build with ARM backend.\n...\n```\n\nWe can install any of these targets by using the install-feature syntax:\n\n```powershell\n> vcpkg install llvm[target-arm] # Installs LLVM with the ARM target\n```\n```json\n{\n  \"dependencies\": [{ \"name\": \"llvm\", \"features\": [\"target-arm\"] }]\n}\n```\n\n## Opting out of default features\n\nThe llvm port includes a few default features that you as a user may not want: for example,\nthe `clang` feature is default, which means that `vcpkg install llvm` will also build and install clang.\nIf you are writing a compiler that uses LLVM as a backend,\nyou're likely not interested in installing clang as well,\nand we can do that by disabling default features with the special `core` \"feature\":\n```powershell\n> vcpkg install llvm[core,target-arm] # removing the default-feature with \"core\" also removes all of the default targets you get\n```\nor in manifest files:\n```json\n{\n  \"dependencies\": [{\n    \"name\": \"llvm\",\n    \"default-features\": false,\n    \"features\": [\"target-arm\"]\n  }]\n}\n```\n\n# Further reading\n- The [Feature Packages](../specifications/feature-packages.md) specification was the initial design for features.\n","Nav":"#"},{"Path":"/en/docs/users/triplets.html","Name":"Triplets","Source":"# Triplet Files\n\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/users/triplets.md).**\n\nTriplet is a standard term used in cross compiling as a way to completely capture the target environment (cpu, os, compiler, runtime, etc) in a single convenient name.\n\nIn Vcpkg, we use triplets to describe an imaginary \"target configuration set\" for every library. Within a triplet, libraries are generally built with the same configuration, but it is not a requirement. For example, you could have one triplet that builds `openssl` statically and `zlib` dynamically, one that builds them both statically, and one that builds them both dynamically (all for the same target OS and architecture). A single build will consume files from a single triplet.\n\nWe currently provide many triplets by default (run `vcpkg help triplet`). However, you can easily customize or add your own by copying a built-in triplet from the `triplets\\` directory into a project local location. Then, use `--overlay-triplets=` (or equivalent such as [`$VCPKG_OVERLAY_TRIPLETS`](config-environment.md#vcpkg_overlay_triplets), [CMake `VCPKG_OVERLAY_TRIPLETS`](buildsystems/cmake-integration.md#vcpkg_overlay_triplets), or [MSBuild Additional Options](buildsystems/msbuild-integration.md#vcpkg-additional-install-options)) to add that directory to vcpkg. See our [overlay triplets example](../examples/overlay-triplets-linux-dynamic.md) for a more detailed walkthrough.\n\nTo change the triplet used by your project, you can pass `--triplet=<triplet>` on the command line or see our [Buildsystem-Specific Documentation](buildsystems/integration.md).\n\n## Community triplets\n\nTriplets contained in the `triplets\\community` folder are not tested by continuous integration, but are commonly requested by the community.\n\nBecause we do not have continuous coverage, port updates may break compatibility with community triplets. Because of this, community involvement is paramount!\n\nWe will gladly accept and review contributions that aim to solve issues with these triplets.\n\n### Usage\n\nCommunity Triplets are enabled by default, when using a community triplet a message like the following one will be printed during a package install:\n\n```no-highlight\n-- Using community triplet x86-uwp. This triplet configuration is not guaranteed to succeed.\n-- [COMMUNITY] Loading triplet configuration from: D:\\src\\viromer\\vcpkg\\triplets\\community\\x86-uwp.cmake\n```\n\n## Variables\n### VCPKG_TARGET_ARCHITECTURE\nSpecifies the target machine architecture.\n\nValid options are `x86`, `x64`, `arm`, `arm64` and `wasm32`.\n\n### VCPKG_CRT_LINKAGE\nSpecifies the desired CRT linkage (for MSVC).\n\nValid options are `dynamic` and `static`.\n\n### VCPKG_LIBRARY_LINKAGE\nSpecifies the preferred library linkage.\n\nValid options are `dynamic` and `static`. Note that libraries can ignore this setting if they do not support the preferred linkage type.\n\n### VCPKG_BUILD_TYPE\nYou can set this value to `release` to only build release versions of the ports. By default this value is empty and release and debug versions of a port are built.\n\n### VCPKG_CMAKE_SYSTEM_NAME\nSpecifies the target platform.\n\nValid options include any CMake system name, such as:\n- Empty (Windows Desktop for legacy reasons)\n- `WindowsStore` (Universal Windows Platform)\n- `MinGW` (Minimalist GNU for Windows)\n- `Darwin` (Mac OSX)\n- `iOS` (iOS)\n- `Linux` (Linux)\n- `Emscripten` (WebAssembly)\n\n### VCPKG_CMAKE_SYSTEM_VERSION\nSpecifies the target platform system version.\n\nThis field is optional and, if present, will be passed into the build as `CMAKE_SYSTEM_VERSION`.\n\nSee also the CMake documentation for `CMAKE_SYSTEM_VERSION`: https://cmake.org/cmake/help/latest/variable/CMAKE_SYSTEM_VERSION.html.\n\n<a name=\"VCPKG_CHAINLOAD_TOOLCHAIN_FILE\"></a>\n### VCPKG_CHAINLOAD_TOOLCHAIN_FILE\nSpecifies an alternate CMake Toolchain file to use.\n\nThis (if set) will override all other compiler detection logic. By default, a toolchain file is selected from `scripts/toolchains/` appropriate to the platform.\n\nSee also the CMake documentation for toolchain files: https://cmake.org/cmake/help/v3.11/manual/cmake-toolchains.7.html.\n\n### VCPKG_CXX_FLAGS\nSets additional compiler flags to be used when not using `VCPKG_CHAINLOAD_TOOLCHAIN_FILE`.\n\nThis option also has forms for configuration-specific and C flags:\n- `VCPKG_CXX_FLAGS`\n- `VCPKG_CXX_FLAGS_DEBUG`\n- `VCPKG_CXX_FLAGS_RELEASE`\n- `VCPKG_C_FLAGS`\n- `VCPKG_C_FLAGS_DEBUG`\n- `VCPKG_C_FLAGS_RELEASE`\n\n### VCPKG_LINKER_FLAGS\nSets additional linker flags to be used while building dynamic libraries and\nexecutables in the absence of `VCPKG_CHAINLOAD_TOOLCHAIN_FILE`.\n\nThis option also has forms for configuration-specific flags:\n- `VCPKG_LINKER_FLAGS`\n- `VCPKG_LINKER_FLAGS_DEBUG`\n- `VCPKG_LINKER_FLAGS_RELEASE`\n\n### VCPKG_CMAKE_CONFIGURE_OPTIONS\nSet additional CMake configure options that are appended to the configure command (in [`vcpkg_cmake_configure`](../maintainers/ports/vcpkg-cmake/vcpkg_cmake_configure.md)).\n\nThis field is optional.\n\nAlso available as build-type specific `VCPKG_CMAKE_CONFIGURE_OPTIONS_DEBUG` and `VCPKG_CMAKE_CONFIGURE_OPTIONS_RELEASE` variables.\n\n### VCPKG_MAKE_CONFIGURE_OPTIONS\nSet additional automake / autoconf configure options that are appended to the configure command (in [`vcpkg_configure_make`](../maintainers/vcpkg_configure_make.md)).\n\nThis field is optional.\n\nFor example, to skip certain libtool checks that may errantly fail:\n```cmake\nset(VCPKG_MAKE_CONFIGURE_OPTIONS \"lt_cv_deplibs_check_method=pass_all\")\n```\n\nAlso available as build-type specific `VCPKG_MAKE_CONFIGURE_OPTIONS_DEBUG` and `VCPKG_MAKE_CONFIGURE_OPTIONS_RELEASE` variables.\n\n<a name=\"VCPKG_DEP_INFO_OVERRIDE_VARS\"></a>\n### VCPKG_DEP_INFO_OVERRIDE_VARS\nReplaces the default computed list of triplet \"Supports\" terms.\n\nThis option (if set) will override the default set of terms used for qualified dependency resolution and \"Supports\" field evaluation.\n\nSee the [`\"supports\"`](../maintainers/manifest-files.md#supports) manifest file field documentation for more details.\n\n> Implementers' Note: this list is extracted via the `vcpkg_get_dep_info` mechanism.\n\n### VCPKG_DISABLE_COMPILER_TRACKING\n\nWhen this option is set to (true|1|on), the compiler is ignored in the abi tracking.\n\n## Windows Variables\n\n<a name=\"VCPKG_ENV_PASSTHROUGH\"></a>\n### VCPKG_ENV_PASSTHROUGH\nInstructs vcpkg to allow additional environment variables into the build process.\n\nOn Windows, vcpkg builds packages in a special clean environment that is isolated from the current command prompt to\nensure build reliability and consistency. This triplet option can be set to a list of additional environment variables\nthat will be added to the clean environment. The values of these environment variables will be hashed into the package\nabi -- to pass through environment variables without abi tracking, see `VCPKG_ENV_PASSTHROUGH_UNTRACKED`.\n\nSee also the `vcpkg env` command for how you can inspect the precise environment that will be used.\n\n> Implementers' Note: this list is extracted via the `vcpkg_get_tags` mechanism.\n\n### VCPKG_ENV_PASSTHROUGH_UNTRACKED\nInstructs vcpkg to allow additional environment variables into the build process without abi tracking.\n\nSee `VCPKG_ENV_PASSTHROUGH`.\n\n<a name=\"VCPKG_VISUAL_STUDIO_PATH\"></a>\n### VCPKG_VISUAL_STUDIO_PATH\nSpecifies the Visual Studio installation to use.\n\nTo select the precise combination of Visual Studio instance and toolset version, we walk through the following algorithm:\n1. Determine the setting for `VCPKG_VISUAL_STUDIO_PATH` from the triplet, or the environment variable `VCPKG_VISUAL_STUDIO_PATH`, or consider it unset\n2. Determine the setting for `VCPKG_PLATFORM_TOOLSET` from the triplet or consider it unset\n3. Gather a list of all pairs of Visual Studio Instances with all toolsets available in those instances\n    1. This is ordered first by instance type (Stable, Prerelease, Legacy) and then by toolset version (v142, v141, v140)\n4. Filter the list based on the settings for `VCPKG_VISUAL_STUDIO_PATH` and `VCPKG_PLATFORM_TOOLSET`.\n5. Select the best remaining option\n\nThe path should be absolute, formatted with backslashes, and have no trailing slash:\n```cmake\nset(VCPKG_VISUAL_STUDIO_PATH \"C:\\\\Program Files (x86)\\\\Microsoft Visual Studio\\\\Preview\\\\Community\")\n```\n\n### VCPKG_PLATFORM_TOOLSET\nSpecifies the VS-based C/C++ compiler toolchain to use.\n\nSee [`VCPKG_VISUAL_STUDIO_PATH`](#VCPKG_VISUAL_STUDIO_PATH) for the full selection algorithm.\n\nValid settings:\n* The Visual Studio 2019 platform toolset is `v142`.\n* The Visual Studio 2017 platform toolset is `v141`.\n* The Visual Studio 2015 platform toolset is `v140`.\n\n### VCPKG_PLATFORM_TOOLSET_VERSION\nSpecifies the detailed MSVC C/C++ compiler toolchain to use.\n\nBy default, [`VCPKG_PLATFORM_TOOLSET`] always chooses the latest installed minor version of the selected toolset.\nIf you need more granularity, you can use this variable.\nValid values are, for example, `14.25` or `14.27.29110`.\n\n### VCPKG_LOAD_VCVARS_ENV\nIf `VCPKG_CHAINLOAD_TOOLCHAIN_FILE` is used, VCPKG will not setup the Visual Studio environment.\nSetting `VCPKG_LOAD_VCVARS_ENV` to (true|1|on) changes this behavior so that the Visual Studio environment is setup following the same rules as if `VCPKG_CHAINLOAD_TOOLCHAIN_FILE` was not set.\n\n## MacOS Variables\n\n### VCPKG_INSTALL_NAME_DIR\nSets the install name used when building macOS dynamic libraries. Default value is `@rpath`. See the CMake documentation for [CMAKE_INSTALL_NAME_DIR](https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_NAME_DIR.html) for more information.\n\n### VCPKG_OSX_DEPLOYMENT_TARGET\nSets the minimum macOS version for compiled binaries. This also changes what versions of the macOS platform SDK that CMake will search for. See the CMake documentation for [CMAKE_OSX_DEPLOYMENT_TARGET](https://cmake.org/cmake/help/latest/variable/CMAKE_OSX_DEPLOYMENT_TARGET.html) for more information.\n\n### VCPKG_OSX_SYSROOT\nSet the name or path of the macOS platform SDK that will be used by CMake. See the CMake documentation for [CMAKE_OSX_SYSROOT](https://cmake.org/cmake/help/latest/variable/CMAKE_OSX_SYSROOT.html) for more information.\n\n\n### VCPKG_OSX_ARCHITECTURES\nSet the macOS / iOS target architecture which will be used by CMake. See the CMake documentation for [CMAKE_OSX_ARCHITECTURES](https://cmake.org/cmake/help/latest/variable/CMAKE_OSX_ARCHITECTURES.html) for more information.\n\n## Per-port customization\nThe CMake Macro `PORT` will be set when interpreting the triplet file and can be used to change settings (such as `VCPKG_LIBRARY_LINKAGE`) on a per-port basis.\n\nExample:\n```cmake\nset(VCPKG_LIBRARY_LINKAGE static)\nif(PORT MATCHES \"qt5-\")\n    set(VCPKG_LIBRARY_LINKAGE dynamic)\nendif()\n```\nThis will build all the `qt5-*` libraries as DLLs, but every other library as a static library.\n\nFor an example in a real project, see https://github.com/Intelight/vcpkg/blob/master/triplets/x86-windows-mixed.cmake.\n\n## Additional Remarks\nThe default triplet when running any vcpkg command is `%VCPKG_DEFAULT_TRIPLET%` or a platform-specific choice if that environment variable is undefined.\n\n- Windows: `x86-windows`\n- Linux: `x64-linux`\n- OSX: `x64-osx`\n\nWe recommend using a systematic naming scheme when creating new triplets. The Android toolchain naming scheme is a good source of inspiration: https://developer.android.com/ndk/guides/standalone_toolchain.html.\n\n## Android triplets\nSee [android.md](android.md)\n\n## Mingw-w64 triplets\nSee [mingw.md](mingw.md)\n","Nav":"#"},{"Path":"/en/docs/users/versioning.implementation-details.html","Name":"Versioning.implementation-details","Source":"# Versioning: Implementation details\r\n\r\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/users/versioning.implementation-details.md).**\r\n\r\n## Contents\r\n\r\n* [Minimum versioning](#minimum-versioning)\r\n* [Constraint resolution](#constraint-resolution)\r\n* [Acquiring port versions](#acquiring-port-versions)\r\n\r\n\r\n### Minimum versioning\r\nVcpkg uses a minimal selection approach to versioning, inspired by the one [used by Go](https://research.swtch.com/vgo-mvs). But modified in some ways:\r\n\r\n* Always starts from a fresh install, eliminates the need for upgrade/downgrade operations.\r\n* Allow unconstrained dependencies by introducing baselines.\r\n\r\nThe minimal selection principle, however, stays the same. Given a set of constraints, vcpkg will use the \"oldest\" possible versions of packages that can satisfy all the constraints.\r\n \r\nUsing a minimum version approach has the following advantages:\r\n* Is predictable and easy to understand.\r\n* User controls when upgrades happen, as in, no upgrades are performed automatically when a new version is released.\r\n* Avoids using a SAT solver.\r\n\r\nTo give an example, consider the following package graph:\r\n```\r\n    (A 1.0) -> (B 1.0)\r\n    \r\n    (A 1.1) -> (B 1.0) \r\n            -> (C 3.0) \r\n    \r\n    (A 1.2) -> (B 2.0)\r\n            -> (C 3.0)\r\n\r\n    (C 2.0)\r\n```\r\n\r\nAnd the following manifest:\r\n```\r\n{\r\n    \"name\": \"example\",\r\n    \"version\": \"1.0.0\",\r\n    \"dependencies\": [ \r\n        { \"name\": \"A\", \"version>=\": \"1.1\" },\r\n        { \"name\": \"C\", \"version>=\": \"2.0\" }\r\n    ], \r\n    \"builtin-baseline\": \"<some git commit with A's baseline at 1.0>\"\r\n}\r\n```\r\n\r\nAfter accounting for transitive dependencies we have the following set of constraints:\r\n* A >= 1.1\r\n    * B >= 1.0\r\n    * C >= 3.0\r\n* C >= 2.0\r\n\r\nSince vcpkg has to satisfy all the constraints, the set of installed packages becomes:\r\n\r\n* `A 1.1`, even when `A 1.2` exists, there are no constraints higher than `1.1` so vcpkg selects the minimum version possible.\r\n* `B 1.0`, transitively required by `A 1.1`.\r\n* `C 3.0`, upgraded by the transitive constraint added by `B 1.0` in order to satisfy version constraints.\r\n\r\n## Constraint resolution\r\nGiven a manifest with a set of versioned dependencies, vcpkg will attempt to calculate a package installation plan that satisfies all the constraints. \r\n\r\nVersion constraints come in the following flavors:\r\n* **Declared constraints**: Constraints declared explicitly in the top-level manifest using `version>=`.\r\n* **Baseline constraints**: Constraints added implicitly by the `builtin-baseline`.\r\n* **Transitive constraints**: Constraints added indirectly by dependencies of your dependencies.\r\n* **Overridden constraints**: Constraints overridden in the top-level manifest using `overrides` declarations.\r\n\r\nTo compute an installation plan, vcpkg follows roughly these steps:\r\n\r\n* Add all top-level constraints to the plan.\r\n* Recursively add transitive constraints to the plan.\r\n    * Each time a new package is added to the plan, also add its baseline constraint to the plan.\r\n    * Each time a constraint is added:\r\n    * If an override exists for the package\r\n        * Select the version in the override.\r\n    * Otherwise:\r\n        * If there is no previous version selected. \r\n            * Select the minimal version that satisfies the constraint.\r\n        * If there is a previous version selected:\r\n            * If the versioning scheme of the new constraint does not match that of the previously selected version:\r\n                * Add a version conflict.\r\n            * If the constraint's version is not comparable to the previously selected version. For example, comparing \"version-string: apple\" to \"version-string: orange\":\r\n                * Add a version conflict.\r\n            * If the constraints version is higher than the previously selected version:\r\n                * Select the highest version.\r\n            * Otherwise: \r\n                * Keep the previous selection.\r\n* Review the plan:\r\n  * If there are no conflicts\r\n    * Install the selected packages\r\n  * Otherwise:\r\n    * Report the conflicts to the user\r\n\r\n## Acquiring port versions\r\nAlthough the concept of package versions has always been present in vcpkg, the concept of version constraints has been not.\r\n\r\nWith the introduction of versioning constraints, it is now possible that a package depends on a port version that does not match the one available locally. This raises a problem as vcpkg needs to know how to acquire the port files for the requested version.\r\n\r\nTo solve this problem, a new set of metadata files was introduced. These files are located in the `versions/` directory at the root level of the vcpkg repository.\r\n\r\nThe `versions/` directory, will contain JSON files for each one of the ports available in the registry. Each file will list all the versions available for a package and contain a Git tree-ish object that vcpkg can check out to obtain that version's portfiles.\r\n\r\nExample: `zlib.json`\r\n\r\n```\r\n{\r\n  \"versions\": [\r\n    {\r\n      \"git-tree\": \"2dfc991c739ab9f2605c2ad91a58a7982eb15687\",\r\n      \"version-string\": \"1.2.11\",\r\n      \"port-version\": 9\r\n    },\r\n    ...\r\n    {\r\n      \"git-tree\": \"a516e5ee220c8250f21821077d0e3dd517f02631\",\r\n      \"version-string\": \"1.2.10\",\r\n      \"port-version\": 0\r\n    },\r\n    {\r\n      \"git-tree\": \"3309ec82cd96d752ff890c441cb20ef49b52bf94\",\r\n      \"version-string\": \"1.2.8\",\r\n      \"port-version\": 0\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\nFor each port, its corresponding versions file should be located in `versions/{first letter of port name}-/{port name}.json`. For example, zlib's version file will be located in `versions/z-/zlib.json`. Aside from port version files, the current baseline file is located in `versions/baseline.json`.\r\n\r\n\r\n","Nav":"#"},{"Path":"/en/docs/users/versioning.html","Name":"Versioning","Source":"# Versioning\r\n\r\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/users/versioning.md).**\r\n\r\nVersioning allows you to deterministically control the precise revisions of dependencies used by\r\nyour project from within your manifest file.\r\n\r\nSee our guide to [getting started with versioning](../examples/versioning.getting-started.md).\r\n\r\n## Contents\r\n\r\n* [Version schemes](#version-schemes)\r\n  * [`version`](#version)\r\n  * [`version-semver`](#version-semver)\r\n  * [`version-date`](#version-date)\r\n  * [`version-string`](#version-string)\r\n* [Version constraints](#version-constraints)\r\n\r\n## Version schemes\r\nPorts in vcpkg should attempt to follow the versioning conventions used by the package's authors. For that reason, when declaring a package's version the appropriate scheme should be used.\r\n\r\nEach versioning scheme defines its own rules on what is a valid version string and more importantly the rules for how to sort versions using the same scheme.\r\n\r\nThe versioning schemes understood by vcpkg are:\r\n\r\nManifest property | Versioning scheme\r\n------------------|------------------------------------\r\n`version`         | For dot-separated numeric versions\r\n`version-semver`  | For SemVer compliant versions\r\n`version-date`    | For dates in the format YYYY-MM-DD\r\n`version-string`  | For arbitrary strings\r\n\r\nA manifest must contain only one version declaration. \r\n\r\n_NOTE: By design, vcpkg does not compare versions that use different schemes. For example, a package\r\nthat has a `version-string: 7.1.3` cannot be compared with the same package using `version: 7.1.4`, even if the\r\nconversion seems obvious._\r\n\r\n#### `version`\r\nAccepts version strings that follow a relaxed, dot-separated-, semver-like scheme.\r\n\r\nThe version is logically composed of dot-separated (`.`) numeric sections. Each section must contain an integer positive number with no leading zeroes.\r\n\r\nThe regex pattern for this versioning scheme is: `(0|[1-9]\\d*)(\\.(0|[1-9]\\d*))*`\r\n\r\n_Sorting behavior_: When comparing two versions, each section is compared from left to right by their numeric value, until the first difference is found. A version with the smallest set of sections takes precedence over another with a larger set of sections, given that all their preceding sections compare equally.\r\n\r\nExample:\r\n`0` < `0.1` < `0.1.0` < `1` < `1.0.0` < `1.0.1` < `1.1`< `2.0.0`\r\n\r\n#### `version-semver`\r\nAccepts version strings that follow semantic versioning conventions as described in the [semantic versioning specification](https://semver.org/#semantic-versioning-specification-semver).\r\n\r\n_Sorting behavior_: Strings are sorted following the rules described in the semantic versioning specification.\r\n\r\nExample:\r\n`1.0.0-1` < `1.0.0-alpha` < `1.0.0-beta` < `1.0.0` < `1.0.1` < `1.1.0`\r\n\r\n#### `version-date`\r\n\r\nAccepts version strings that can be parsed to a date following the ISO-8601 format `YYYY-MM-DD`. Disambiguation identifiers are allowed in the form of dot-separated-, positive-, integer-numbers with no leading zeroes.\r\n\r\nThis is the recommended versioning scheme for \"Live at HEAD\" libraries that don't have established release versions.\r\n\r\nThe regex pattern for this versioning scheme is: `\\d{4}-\\d{2}-\\d{2}(\\.(0|[1-9]\\d*))*`\r\n\r\n_Sorting behavior_: Strings are sorted first by their date part, then by numeric comparison of their disambiguation identifiers. Disambiguation identifiers follow the rules of the relaxed (`version`) scheme.\r\n\r\nExamples:\r\n`2021-01-01` < `2021-01-01.1` < `2021-02-01.1.2` < `2021-02-01.1.3` < `2021-02-01`\r\n\r\n#### `version-string`\r\nFor packages using version strings that do not fit any of the other schemes, it accepts most arbitrary strings.  The `#` which is used to denote port versions is disallowed.\r\n\r\n_Sorting behavior_: No sorting is attempted on the version string itself. However, if the strings match exactly, their port versions can be compared and sorted.\r\n\r\nExamples:\r\n* `apple` <> `orange` <> `orange.2` <> `orange2`\r\n* `watermelon#0`< `watermelon#1`\r\n\r\n#### `port-version`\r\nA positive integer value that increases each time a vcpkg-specific change is made to the port.\r\n\r\nThe rules for port versions are:\r\n* Start at 0 for the original version of the port,\r\n* increase by 1 each time a vcpkg-specific change is made to the port that does not increase the version of the package,\r\n* and reset to 0 each time the version of the package is updated.\r\n\r\n_NOTE: Whenever vcpkg output a version it follows the format `<version>#<port version>`. For example `1.2.0#2` means version `1.2.0` port version `2`. When the port version is `0` the `#0` suffix is omitted (`1.2.0` implies version `1.2.0` port version `0`)._\r\n\r\n_Sorting behavior_: If two versions compare equally, their port versions are compared by their numeric value, lower port versions take precedence.\r\n\r\nExamples:\r\n* `1.2.0` < `1.2.0#1` < `1.2.0#2` < `1.2.0#10`\r\n* `2021-01-01#20` < `2021-01-01.1`\r\n* `windows#7` < `windows#8`\r\n\r\n## Version constraints\r\n\r\n### `builtin-baseline`\r\nAccepts a Git commit ID. vcpkg will try to find a baseline file in the given\r\ncommit ID and use that to set the baseline versions (lower bounds) of all\r\ndependencies.\r\n\r\nBaselines provide stability and ease of development for top-level manifest\r\nfiles. They are not considered from ports consumed as a dependency. If a minimum\r\nversion constraint is required during transitive version resolution, the port\r\nshould use `version>=`.\r\n\r\nExample:\r\n```json\r\n{\r\n  \"name\": \"project\",\r\n  \"version\": \"1.0.0\",\r\n  \"dependencies\": [\"zlib\", \"fmt\"],\r\n  \"builtin-baseline\":\"9fd3bd594f41afb8747e20f6ac9619f26f333cbe\"\r\n}\r\n```\r\n\r\nYou can get the current commit of your vcpkg instance either by adding an empty\r\n`\"builtin-baseline\"` field, installing, and examining the error message or by\r\nrunning `git rev-parse HEAD` in the root of the vcpkg instance.\r\n\r\nWhen resolving version constraints for a package, vcpkg will look for a baseline\r\nversion by looking at the baseline file in the given commit ID. If the given\r\ncommit ID doesn't have a `versions/baseline.json` file or if the baseline file\r\nexists but it does not declare a baseline version for the package the invocation\r\nwill fail.\r\n\r\nThis field is a convenience field that has the same semantic as replacing your\r\ndefault registry in\r\n[`vcpkg-configuration.json`](registries.md#configuration-default-registry).\r\n```json\r\n{\r\n  \"default-registry\": {\r\n    \"kind\": \"builtin\",\r\n    \"baseline\": \"<baseline>\"\r\n  }\r\n}\r\n```\r\n\r\n### `version>=`\r\nExpresses a minimum version requirement, `version>=` declarations put a lower boundary on the versions that can be used to satisfy a dependency.\r\n\r\n**Note: Vcpkg selects the lowest version that matches all constraints, so a less-than constraint is not required.**\r\n\r\nExample:\r\n```json\r\n{\r\n  \"name\": \"project\",\r\n  \"version-semver\": \"1.0.0\",\r\n  \"dependencies\": [\r\n    { \"name\": \"zlib\", \"version>=\": \"1.2.11#9\" },\r\n    { \"name\": \"fmt\", \"version>=\": \"7.1.3#1\" }\r\n  ],\r\n  \"builtin-baseline\":\"3426db05b996481ca31e95fff3734cf23e0f51bc\"\r\n}\r\n```\r\n\r\nAs part of a version constraint declaration, a port version can be specified by adding the suffix `#<port-version>`, in the previous example `1.2.11#9` refers to version `1.2.11` port version `9`.\r\n\r\n### `overrides`\r\nDeclaring an override forces vcpkg to ignore all other version constraints and use the version specified in the override. This is useful for pinning exact versions and for resolving version conflicts.\r\n\r\nOverrides are declared as an array of package version declarations.\r\n\r\nFor an override to take effect, the overridden package must form part of the dependency graph. That means that a dependency must be declared either by the top-level manifest or be part of a transitive dependency.\r\n\r\n```json\r\n{\r\n  \"name\": \"project\",\r\n  \"version-semver\": \"1.0.0\",\r\n  \"dependencies\": [\r\n    { \"name\": \"zlib\", \"version>=\": \"1.2.11#9\" },\r\n    \"fmt\"\r\n  ],\r\n  \"builtin-baseline\":\"3426db05b996481ca31e95fff3734cf23e0f51bc\",\r\n  \"overrides\": [\r\n    { \"name\": \"fmt\", \"version\": \"6.0.0\" }\r\n  ]\r\n}\r\n```\r\n\r\n## See Also\r\n\r\n* The [implementation details](versioning.implementation-details.md)\r\n* The [original specification](../specifications/versioning.md)\r\n\r\n","Nav":"#"}]