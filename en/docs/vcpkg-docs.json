[{"Path":"/en/docs/README.html","Name":"README","Source":"### Quick Start\n\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/README.md).**\n\nVcpkg helps you manage C and C++ libraries on Windows, Linux and MacOS. This tool and ecosystem are constantly evolving; your involvement is vital to its success!\n\n### Examples\n\n- [Installing and Using Packages Example: sqlite](examples/installing-and-using-packages.md)\n- [Packaging Zipfiles Example: zlib](examples/packaging-zipfiles.md)\n- [Packaging GitHub Repositories Example: libogg](examples/packaging-github-repos.md)\n- [Patching Example: Patching libpng to work for x64-uwp](examples/patching.md)\n- [Getting Started with Versioning](examples/versioning.getting-started.md)\n\n### User Help\n\n- [Integration with build systems](users/integration.md)\n- [Triplet files](users/triplets.md)\n- [Configuration and Environment](users/config-environment.md)\n- [Manifest Mode](users/manifests.md)\n- [Binary Caching](users/binarycaching.md)\n- [Versioning](users/versioning.md)\n- [Usage with Android](users/android.md)\n- [Usage with Mingw-w64](users/mingw.md)\n- [Host Dependencies](users/host-dependencies.md)\n- [Using Registries](users/registries.md)\n\n### Maintainer Help\n\n- [Manifest files - vcpkg.json](maintainers/manifest-files.md)\n- [Control files](maintainers/control-files.md)\n- [Portfile functions](maintainers/portfile-functions.md)\n- [Common CMake definitions](maintainers/vcpkg_common_definitions.md)\n- [Maintainer Guidelines](maintainers/maintainer-guide.md)\n- [Creating Registries](maintainers/registries.md)\n- [CMake Guidelines](maintainers/cmake-guidelines.md)\n\n### [Vcpkg-Tool](https://github.com/microsoft/vcpkg-tool) Maintainer Help\n\n- [Testing](https://github.com/microsoft/vcpkg-tool/tree/main/docs/testing.md)\n- [Benchmarking](https://github.com/microsoft/vcpkg-tool/tree/main/docs/benchmarking.md)\n- [Layout of the vcpkg source tree](https://github.com/microsoft/vcpkg-tool/tree/main/docs/layout.md)\n\n### Community Resources (not directly affiliated with vcpkg)\n\n- [vcpkg.info](https://vcpkg.info/) - Package index + search\n- [vcpkgx](https://vcpkgx.com/) - Package index + search\n- [vcpkg index](https://vcpkg.dev/) - Package index + search\n\n### Specifications\n\n- [Export](specifications/export-command.md)\n- [Feature Packages](specifications/feature-packages.md)\n\n### Blog posts\n\n- [Vcpkg Host Dependencies for Cross-Compilation](https://devblogs.microsoft.com/cppblog/vcpkg-host-dependencies/)\n- [Registries: Bring your own libraries to vcpkg](https://devblogs.microsoft.com/cppblog/registries-bring-your-own-libraries-to-vcpkg/)\n- [Vcpkg: Accelerate your team development environment with binary caching and manifests](https://devblogs.microsoft.com/cppblog/vcpkg-accelerate-your-team-development-environment-with-binary-caching-and-manifests/)\n- [Vcpkg: 2019.06 Update (overlay ports, overlay triplets, `vcpkg_check_features`)](https://devblogs.microsoft.com/cppblog/vcpkg-2019-06-update/)\n- [Announcing a single C++ library manager for Linux, macOS and Windows: Vcpkg](https://blogs.msdn.microsoft.com/vcblog/2018/04/24/announcing-a-single-c-library-manager-for-linux-macos-and-windows-vcpkg/)\n- [Vcpkg: Using multiple enlistments to handle multiple versions of a library](https://blogs.msdn.microsoft.com/vcblog/2017/10/23/vcpkg-using-multiple-enlistments/)\n- [Vcpkg: introducing the export command](https://blogs.msdn.microsoft.com/vcblog/2017/05/03/vcpkg-introducing-export-command/)\n- [Binary Compatibility and Pain-free Upgrade Why Moving to Visual Studio 2017 is almost \"too easy\"](https://blogs.msdn.microsoft.com/vcblog/2017/03/07/binary-compatibility-and-pain-free-upgrade-why-moving-to-visual-studio-2017-is-almost-too-easy/)\n- [Vcpkg recent enhancements](https://blogs.msdn.microsoft.com/vcblog/2017/02/14/vcpkg-recent-enhancements/)\n- [Vcpkg 3 Months Anniversary, Survey](https://blogs.msdn.microsoft.com/vcblog/2017/01/11/vcpkg-3-months-anniversary-survey/)\n- [Vcpkg updates: Static linking is now available](https://blogs.msdn.microsoft.com/vcblog/2016/11/01/vcpkg-updates-static-linking-is-now-available/)\n- [Vcpkg: a tool to acquire and build C++ open source libraries on Windows](https://blogs.msdn.microsoft.com/vcblog/2016/09/19/vcpkg-a-tool-to-acquire-and-build-c-open-source-libraries-on-windows/)\n\n### Other\n\n- [FAQ](about/faq.md)\n- [Privacy](about/privacy.md)\n","Nav":"#"},{"Path":"/en/docs/about/faq.html","Name":"Faq","Source":"# Frequently Asked Questions\n\n## Can I contribute a new library?\nYes! Start out by reading our [contribution guidelines](https://github.com/Microsoft/vcpkg/blob/master/CONTRIBUTING.md).\nIf you want to contribute but don't have a particular library in mind then take a look at the list\nof [new port requests](https://github.com/Microsoft/vcpkg/issues?q=is%3Aissue+is%3Aopen+label%3Acategory%3Anew-port).\n\n## Can Vcpkg create pre-built binary packages? What is the binary format used by Vcpkg?\nYes! See [the `export` command](../users/integration.md#export-command).\n\n## How do I update libraries?\nThe `vcpkg update` command lists all packages which are out-of-sync with your current portfiles. To update a package, follow the instructions in the command.\n\n## How do I get more libraries?\nThe list of libraries is enumerated from the [`ports\\`](https://github.com/Microsoft/vcpkg/blob/master/ports) directory. By design, you can add and remove libraries from this directory as you see fit for yourself or your company -- see our examples on packaging [zipfiles](../examples/packaging-zipfiles.md) and [GitHub repos](../examples/packaging-github-repos.md).\n\nWe recommend cloning directly from [GitHub](https://github.com/microsoft/vcpkg) and using `git pull` to update the list of portfiles. Once you've updated your portfiles, `vcpkg update` will indicate any installed libraries that are now out of date.\n\n## Can I build a private library with this tool?\nYes. Follow [our packaging zlib Example](../examples/packaging-zipfiles.md) for creating a portfile using a fake URL. Then, either pre-seed the `downloads\\` folder with a zip containing your private sources or replace the normal calls to `vcpkg_download_distfile` and `vcpkg_extract_source_archive` with functions that unpack your source code.\n\n## Can I use a prebuilt private library with this tool?\nYes. The `portfile.cmake` for a library is fundamentally a script that places the headers and binaries into the correct arrangement in the `${CURRENT_PACKAGES_DIR}`, so to pull in prebuilt binaries you can write a portfile which directly downloads and arranges the files.\n\nTo see an example of this, look at [`ports\\opengl\\portfile.cmake`](https://github.com/microsoft/vcpkg/blob/master/ports/opengl/portfile.cmake) which simply copies files out of the Windows SDK.\n\n## Which platforms I can target with Vcpkg?\nWe currently target Windows Desktop (x86 and x64) as well as the Universal Windows Platform (x86, x64, and ARM). See `vcpkg help triplet` for the current list.\n\n## Does Vcpkg run on Linux/OSX?\nYes! We continuously test on OSX and Ubuntu 16.04, however we know users have been successful with Arch, Fedora, and FreeBSD. If you have trouble with your favorite Linux distribution, let us know in an issue and we'd be happy to help!\n\n## How do I update vcpkg?\nExecute `git pull` to get the latest sources, then run `bootstrap-vcpkg.bat` (Windows) or `./bootstrap-vcpkg.sh` (Unix) to update vcpkg.\n\n## How do I use different versions of a library on one machine?\nWithin a single instance of Vcpkg (e.g. one set of `installed\\`, `packages\\`, `ports\\` and so forth), you can only have one version of a library installed (otherwise, the headers would conflict with each other!). For those with experience with system-wide package managers, packages in Vcpkg correspond to the `X-dev` or `X-devel` packages.\n\nTo use different versions of a library for different projects, we recommend making separate instances of Vcpkg and using the [per-project integration mechanisms](../users/integration.md). The versions of each library are specified by the files in `ports\\`, so they are easily manipulated using standard `git` commands. This makes it very easy to roll back the entire set of libraries to a consistent set of older versions which all work with each other. If you need to then pin a specific library forward, that is as easy as checking out the appropriate version of `ports\\<package>\\`.\n\nIf your application is very sensitive to the versions of libraries, we recommend checking in the specific set of portfiles you need into your source control along with your project sources and using the `--vcpkg-root` option to redirect the working directory of `vcpkg.exe`.\n\n## How does Vcpkg protect my privacy?\nSee the [Privacy document](privacy.md) for all information regarding privacy.\n\n## Can I use my own CMake toolchain file with Vcpkg's toolchain file?\nYes. If you already have a CMake toolchain file, you will need to include our toolchain file at the end of yours. This should be as simple as an `include(<vcpkg_root>\\scripts\\buildsystems\\vcpkg.cmake)` directive. Alternatively, you could copy the contents of our `scripts\\buildsystems\\vcpkg.cmake` into the end of your existing toolchain file.\n\n## Can I use my own/specific flags for rebuilding libs?\nYes. In the current version, there is not yet a standardized global way to change them, however you can edit individual portfiles and tweak the exact build process however you'd like.\n\nBy saving the changes to the portfile (and checking them in), you'll get the same results even if you're rebuilding from scratch in the future and forgot what exact settings you used.\n\n## Can I get Vcpkg integration for custom configurations?\n\nYes. While Vcpkg will only produce the standard \"Release\" and \"Debug\" configurations when building a library, you can get integration support for your projects' custom configurations, in addition to your project's standard configurations.\n\nFirst of all, Vcpkg will automatically assume any custom configuration starting with \"Release\" (resp. \"Debug\") as a configuration that is compatible with the standard \"Release\" (resp. \"Debug\") configuration and will act accordingly.\n\nFor other configurations, you only need to override the MSBuild `$(VcpkgConfiguration)` macro in your project file (.vcxproj) to declare the compatibility between your configuration, and the target standard configuration. Unfortunately, due to the sequential nature of MSBuild, you'll need to add those settings much higher in your vcxproj so that it is declared before the Vcpk integration is loaded. It is recommend that the `$(VcpkgConfiguration)` macro is added to the \"Globals\" PropertyGroup.\n\nFor example, you can add support for your \"MyRelease\" configuration by adding in your project file:\n```\n<PropertyGroup Label=\"Globals\">\n  ...\n  <VcpkgConfiguration Condition=\"'$(Configuration)' == 'MyRelease'\">Release</VcpkgConfiguration>\n</PropertyGroup>\n```\nOf course, this will only produce viable binaries if your custom configuration is compatible with the target configuration (e.g. they should both link with the same runtime library).\n\n## I can't use user-wide integration. Can I use a per-project integration?\n\nYes. A NuGet package suitable for per-project use can be generated via either the `vcpkg integrate project` command (lightweight linking) or the `vcpkg export --nuget` command (shrinkwrapped).\n\nA lower level mechanism to achieve the same as the `vcpkg integrate project` NuGet package is via the `<vcpkg_root>\\scripts\\buildsystems\\msbuild\\vcpkg.targets` file. All you need is to import it in your .vcxproj file, replacing `<vcpkg_root>` with the path where you installed vcpkg:\n\n```\n<Import Project=\"<vcpkg_root>\\scripts\\buildsystems\\msbuild\\vcpkg.targets\" />\n```\n\n## How can I remove temporary files?\n\nYou can save some disk space by completely removing the `packages\\`, `buildtrees\\`, and `downloads\\` folders.\n\n## How is CMake used internally by Vcpkg?\nVcpkg uses CMake internally as a build scripting language. This is because CMake is already an extremely common build system for cross-platform open source libraries and is becoming very popular for C++ projects in general. It is easy to acquire on Windows, does not require system-wide installation, and legible for unfamiliar users.\n\n## Will Vcpkg support downloading compiled binaries from a public or private server?\nWe would like to eventually support downloading precompiled binaries, similar to other system package managers.\n\nIn a corporate scenario, we currently recommend building the libraries once and distributing the entire vcpkg root directory to everyone else on the project through some raw file transport such as a network share or HTTP host. See the [`export`](../users/integration.md#export) command.\n\n## What Visual C++ toolsets are supported?\nWe support Visual Studio 2015 Update 3 and above.\n\n## Why does Visual Studio not use my libraries with user-wide integration enabled?\nEnabling user-wide integration (`vcpkg integrate install`) changes the default for some project properties. In particular, \"C/C++/General/Additional Include Directories\" and \"Linker/General/Additional Library Directories\" are normally blank *without* user-wide integration. *With* integration, a blank value means that the augmented default supplied by vcpkg is overridden, and headers/libraries will not be found. To reinstate the default, set the properties to inherit from parent.\n\n## Why not NuGet?\nNuGet is a package manager for .NET libraries with a strong dependency on MSBuild. It does not meet the specific needs of Native C++ customers in at least three ways.\n\n- **Compilation Flavors**. With so many possible combinations of compilation options, the task of providing a truly complete set of options is intrinsically impossible. Furthermore, the download size for reasonably complete binary packages becomes enormous. This makes it a requirement to split the results into multiple packages, but then searching becomes very difficult.\n\n- **Binary vs Source**. Very closely tied to the first point, NuGet is designed from the ground up to provide relatively small, prebuilt binaries. Due to the nature of native code, developers need to have access to the source code to ensure ABI compatibility, performance, integrity, and debuggability.\n\n- **Per-dll vs Per-application**. NuGet is highly project centric. This works well in managed languages with naturally stable ABIs, because base libraries can continue to evolve without breaking those higher up. However, in native languages where the ABI is much more fragile, the only robust strategy is to explicitly build each library against the exact dependencies that will be included in the final application. This is difficult to ensure in NuGet and leads to a highly disconnected and independently versioned ecosystem.\n\n## Why not Conan?\nConan.io is a publicly-federated, project-centric, cross-platform, C++ package manager written in python. Our primary differences are:\n\n- **Public federation vs private federation**. Conan relies on individuals publishing independent copies of each package. We believe this approach encourages a large number of packages that are all broken in different ways. We believe it is a waste of user's time to pick through the list of 20+ public packages for Boost 1.56 to determine the handful that will work for their particular situation. In contrast, we believe there should be a single, collaboratively maintained version which works for the vast majority of cases and allow users to hack freely on their private versions. We believe this will result in a set of high quality packages that are heavily tested with each other and form a fantastic base for any private modifications you need.\n\n- **Per-dll vs Per-application**. When dependencies are independently versioned on a library level, it encourages every build environment to be a completely unique, unable to take advantage of or contribute to a solid, well tested ecosystem. In contrast, by versioning all libraries together as a platform (similar to a system package manager), we hope to congregate testing and effort on very common sets of library versions to maximize the quality and stability of the ecosystem. This also completely designs out the ability for a library to ask for versions that conflict with the application's choices (I want openssl Z and boost X but X only claims to work with openssl Y).\n\n- **Cross-platform vs single-platform**. While being hosted on many platforms is an excellent north star, we believe the level of system integration and stability provided by apt-get, yum, and homebrew is well worth needing to exchange `apt-get install libboost-all-dev` with `brew install boost` in automated scripts. We chose to make our system as easy as possible to integrate into a world with these very successful system managers -- one more line for `vcpkg install boost` -- instead of attempting to replace them where they are already so successful and well-loved.\n\n- **C++/CMake vs python**. While Python is an excellent language loved by many, we believe that transparency and familiarity are the most important factors when choosing a tool as important to your workflow as a package manager. Consequently, we chose to make the implementation languages be as universally accepted as possible: C++ should be used in a C++ package manager for C++ programmers. You should not be required to learn another programming language just to understand your package manager.\n\n## Why not Chocolatey?\nChocolatey is an excellent system for managing applications. However, it is not currently designed to acquire redistributable developer assets and help you with debugging. Vcpkg, in comparison, is designed to get you the libraries you need to build your application and help you deliver through any platform you'd like (including Chocolatey!).\n","Nav":"#"},{"Path":"/en/docs/about/privacy.html","Name":"Privacy","Source":"# Vcpkg Telemetry and Privacy\n\nvcpkg collects telemetry data to understand usage issues, such as failing packages, and to guide tool improvements. The collected data is anonymous.\nFor more information about how Microsoft protects your privacy, see https://privacy.microsoft.com/en-US/privacystatement#mainenterprisedeveloperproductsmodule\n\n## Scope\n\nWe explicitly ONLY collect information from invocations of the tool itself; we do NOT add any tracking information into the produced libraries. Telemetry is collected when using any of the `vcpkg` commands.\n\n## How to opt out\n\nThe vcpkg telemetry feature is enabled by default. In order to opt-out of data collection, you can re-run the bootstrap script with the following flag, for Windows and Linux/OSX, respectively:\n\n```PS> .\\bootstrap-vcpkg.bat -disableMetrics```\n\n```~/$ ./bootstrap-vcpkg.sh -disableMetrics```\n\n## Disclosure\n\nvcpkg displays text similar to the following when you build vcpkg. This is how Microsoft notifies you about data collection.\n\n```\nTelemetry\n---------\nvcpkg collects usage data in order to help us improve your experience.\nThe data collected by Microsoft is anonymous.\nYou can opt-out of telemetry by re-running the bootstrap-vcpkg script with -disableMetrics,\npassing --disable-metrics to vcpkg on the command line,\nor by setting the VCPKG_DISABLE_METRICS environment variable.\n\nRead more about vcpkg telemetry at docs/about/privacy.md\n```\n\n## Data Collected\n\nThe telemetry feature doesn't collect personal data, such as usernames or email addresses. It doesn't scan your code and doesn't extract project-level data, such as name, repository, or author. The data is sent securely to Microsoft servers and held under restricted access.\n\nProtecting your privacy is important to us. If you suspect the telemetry is collecting sensitive data or the data is being insecurely or inappropriately handled, file an issue in the Microsoft/vcpkg repository or send an email to vcpkg@microsoft.com for investigation.\n\nWe collect various telemetry events such as the command line used, the time of invocation, and how long execution took. Some commands also add additional calculated information (such as the full set of libraries to install). We generate a completely random UUID on first use and attach it to each event.\n\nYou can see the telemetry events any command by appending `--printmetrics` after the vcpkg command line.\n\nIn the source code (included at https://github.com/microsoft/vcpkg-tool/ ), you can search for calls to the functions `track_property()`, `track_feature()`, `track_metric()`, and `track_buildtime()`\nto see every specific data point we collect.\n\n## Avoid inadvertent disclosure information\n\nvcpkg contributors and anyone else running a version of vcpkg that they built themselves should consider the path to their source code. If a crash occurs when using vcpkg, the file path from the build machine is collected as part of the stack trace and isn't hashed.\nBecause of this, builds of vcpkg shouldn't be located in directories whose path names expose personal or sensitive information.\n","Nav":"#"},{"Path":"/en/docs/examples/installing-and-using-packages.html","Name":"Installing-and-using-packages","Source":"## Installing and Using Packages Example: SQLite\n\n  - [Step 1: Install](#install)\n  - [Step 2: Use](#use)\n    - [VS/MSBuild Project (User-wide integration)](#msbuild)\n    - [CMake (Toolchain file)](#cmake)\n    - [Other integration options](../users/integration.md)\n\n---\n<a name=\"install\"></a>\n## Step 1: Install\n\nFirst, we need to know what name [SQLite](https://sqlite.org) goes by in the ports tree. To do that, we'll run the `search` command and inspect the output:\n```no-highlight\nPS D:\\src\\vcpkg> .\\vcpkg search sqlite\nlibodb-sqlite        2.4.0            Sqlite support for the ODB ORM library\nsqlite3              3.32.1           SQLite is a software library that implements a se...\n\nIf your library is not listed, please open an issue at:\n    https://github.com/Microsoft/vcpkg/issues\n```\nLooking at the list, we can see that the port is named \"sqlite3\". You can also run the `search` command without arguments to see the full list of packages.\n\nInstalling is then as simple as using the `install` command.\n```no-highlight\nPS D:\\src\\vcpkg> .\\vcpkg install sqlite3\nComputing installation plan...\nThe following packages will be built and installed:\n    sqlite3[core]:x86-windows\nStarting package 1/1: sqlite3:x86-windows\nBuilding package sqlite3[core]:x86-windows...\n-- Downloading https://sqlite.org/2020/sqlite-amalgamation-3320100.zip...\n-- Extracting source C:/src/vcpkg/downloads/sqlite-amalgamation-3320100.zip\n-- Applying patch fix-arm-uwp.patch\n-- Using source at C:/src/vcpkg/buildtrees/sqlite3/src/3320100-15aeda126a.clean\n-- Configuring x86-windows\n-- Building x86-windows-dbg\n-- Building x86-windows-rel\n-- Performing post-build validation\n-- Performing post-build validation done\nBuilding package sqlite3[core]:x86-windows... done\nInstalling package sqlite3[core]:x86-windows...\nInstalling package sqlite3[core]:x86-windows... done\nElapsed time for package sqlite3:x86-windows: 12 s\n\nTotal elapsed time: 12.04 s\n\nThe package sqlite3:x86-windows provides CMake targets:\n\n    find_package(unofficial-sqlite3 CONFIG REQUIRED)\n    target_link_libraries(main PRIVATE unofficial::sqlite3::sqlite3))\n\n```\n\nWe can check that sqlite3 was successfully installed for x86 Windows desktop by running the `list` command.\n```no-highlight\nPS D:\\src\\vcpkg> .\\vcpkg list\nsqlite3:x86-windows         3.32.1           SQLite is a software library that implements a se...\n```\n\nTo install for other architectures and platforms such as Universal Windows Platform or x64 Desktop, you can suffix the package name with `:<target>`.\n```no-highlight\nPS D:\\src\\vcpkg> .\\vcpkg install sqlite3:x86-uwp zlib:x64-windows\n```\n\nSee `.\\vcpkg help triplet` for all supported targets.\n\n---\n<a name=\"use\"></a>\n## Step 2: Use\n<a name=\"msbuild\"></a>\n#### VS/MSBuild Project (User-wide integration)\n\nThe recommended and most productive way to use vcpkg is via user-wide integration, making the system available for all projects you build. The user-wide integration will prompt for administrator access the first time it is used on a given machine, but afterwards is no longer required and the integration is configured on a per-user basis.\n```no-highlight\nPS D:\\src\\vcpkg> .\\vcpkg integrate install\nApplied user-wide integration for this vcpkg root.\n\nAll C++ projects can now #include any installed libraries.\nLinking will be handled automatically.\nInstalling new libraries will make them instantly available.\n```\n*Note: You will need to restart Visual Studio or perform a Build to update intellisense with the changes.* \n\nYou can now simply use File -> New Project in Visual Studio and the library will be automatically available. For SQLite, you can try out their [C/C++ sample](https://sqlite.org/quickstart.html).\n\nTo remove the integration for your user, you can use `.\\vcpkg integrate remove`.\n\n<a name=\"cmake\"></a>\n#### CMake (Toolchain File)\n\nThe best way to use installed libraries with cmake is via the toolchain file `scripts\\buildsystems\\vcpkg.cmake`. To use this file, you simply need to add it onto your CMake command line as:  \n`-DCMAKE_TOOLCHAIN_FILE=D:\\src\\vcpkg\\scripts\\buildsystems\\vcpkg.cmake`.\n\nIf you are using CMake through Open Folder with Visual Studio you can define `CMAKE_TOOLCHAIN_FILE` by adding a \"variables\" section to each of your `CMakeSettings.json` configurations:\n\n```json\n{\n  \"configurations\": [{\n    \"name\": \"x86-Debug\",\n    \"generator\": \"Visual Studio 15 2017\",\n    \"configurationType\" : \"Debug\",\n    \"buildRoot\":  \"${env.LOCALAPPDATA}\\\\CMakeBuild\\\\${workspaceHash}\\\\build\\\\${name}\",\n    \"cmakeCommandArgs\": \"\",\n    \"buildCommandArgs\": \"-m -v:minimal\",\n    \"variables\": [{\n      \"name\": \"CMAKE_TOOLCHAIN_FILE\",\n      \"value\": \"D:\\\\src\\\\vcpkg\\\\scripts\\\\buildsystems\\\\vcpkg.cmake\"\n    }]\n  }]\n}\n```\n*Note: It might be necessary to delete the CMake cache folder of each modified configuration, to force a full regeneration. In the `CMake` menu, under `Cache (<configuration name>)` you'll find `Delete Cache Folders`.*\n\nNow let's make a simple CMake project with a main file.\n```cmake\n# CMakeLists.txt\ncmake_minimum_required(VERSION 3.0)\nproject(test)\n\nfind_package(unofficial-sqlite3 CONFIG REQUIRED)\n\nadd_executable(main main.cpp)\n\ntarget_link_libraries(main PRIVATE unofficial::sqlite3::sqlite3)\n```\n```cpp\n// main.cpp\n#include <sqlite3.h>\n#include <stdio.h>\n\nint main()\n{\n    printf(\"%s\\n\", sqlite3_libversion());\n    return 0;\n}\n```\n\nThen, we build our project in the normal CMake way:\n```no-highlight\nPS D:\\src\\cmake-test> mkdir build \nPS D:\\src\\cmake-test> cd build\nPS D:\\src\\cmake-test\\build> cmake .. \"-DCMAKE_TOOLCHAIN_FILE=D:\\src\\vcpkg\\scripts\\buildsystems\\vcpkg.cmake\"\n    // omitted CMake output here //\n-- Build files have been written to: D:/src/cmake-test/build\nPS D:\\src\\cmake-test\\build> cmake --build .\n    // omitted MSBuild output here //\nBuild succeeded.\n    0 Warning(s)\n    0 Error(s)\n\nTime Elapsed 00:00:02.38\nPS D:\\src\\cmake-test\\build> .\\Debug\\main.exe\n3.15.0\n```\n\n*Note: The correct sqlite3.dll is automatically copied to the output folder when building for x86-windows. You will need to distribute this along with your application.*\n\n##### Handling libraries without native cmake support\n\nUnlike other platforms, we do not automatically add the `include\\` directory to your compilation line by default. If you're using a library that does not provide CMake integration, you will need to explicitly search for the files and add them yourself using [`find_path()`][1] and [`find_library()`][2].\n\n```cmake\n# To find and use catch\nfind_path(CATCH_INCLUDE_DIR catch.hpp)\ninclude_directories(${CATCH_INCLUDE_DIR})\n\n# To find and use azure-storage-cpp\nfind_path(WASTORAGE_INCLUDE_DIR was/blob.h)\nfind_library(WASTORAGE_LIBRARY wastorage)\ninclude_directories(${WASTORAGE_INCLUDE_DIR})\nlink_libraries(${WASTORAGE_LIBRARY})\n\n# Note that we recommend using the target-specific directives for a cleaner cmake:\n#     target_include_directories(main ${LIBRARY})\n#     target_link_libraries(main PRIVATE ${LIBRARY})\n```\n\n[1]: https://cmake.org/cmake/help/latest/command/find_path.html\n[2]: https://cmake.org/cmake/help/latest/command/find_library.html\n","Nav":"#"},{"Path":"/en/docs/examples/manifest-mode-cmake.html","Name":"Manifest-mode-cmake","Source":"# Manifest Mode: CMake Example\n\nWe would like to add [vcpkg manifest support](../users/manifests.md) to an existing cmake project!\nLet's create a simple project that prints the fibonacci sequence up to a certain number,\nusing some common dependencies.\n\n## Initial Layout\n\nLet's create the following file layout:\n\n```no-highlight\nfibo/\n  src/\n    main.cxx\n  CMakeLists.txt\n```\n\nAnd we wish to use [fmt](https://github.com/fmtlib/fmt), [range-v3](https://github.com/ericniebler/range-v3),\nand [cxxopts](https://github.com/jarro2783/cxxopts).\n\nLet's write our `CMakeLists.txt` first:\n\n```cmake\ncmake_minimum_required(VERSION 3.15)\n\nproject(fibo CXX)\n\nfind_package(fmt REQUIRED)\nfind_package(range-v3 REQUIRED)\nfind_package(cxxopts REQUIRED)\n\nadd_executable(fibo src/main.cxx)\ntarget_compile_features(fibo PRIVATE cxx_std_17)\n\ntarget_link_libraries(fibo\n  PRIVATE\n    fmt::fmt\n    range-v3::range-v3\n    cxxopts::cxxopts)\n```\n\nAnd then we should add `main.cxx`:\n\n```cxx\n#include <cxxopts.hpp>\n#include <fmt/format.h>\n#include <range/v3/view.hpp>\n\nnamespace view = ranges::views;\n\nint fib(int x) {\n  int a = 0, b = 1;\n\n  for (int it : view::repeat(0) | view::take(x)) {\n    (void)it;\n    int tmp = a;\n    a += b;\n    b = tmp;\n  }\n\n  return a;\n}\n\nint main(int argc, char** argv) {\n  cxxopts::Options options(\"fibo\", \"Print the fibonacci sequence up to a value 'n'\");\n    options.add_options()\n      (\"n,value\", \"The value to print to\", cxxopts::value<int>()->default_value(\"10\"));\n\n  auto result = options.parse(argc, argv);\n  auto n = result[\"value\"].as<int>();\n\n  for (int x : view::iota(1) | view::take(n)) {\n    fmt::print(\"fib({}) = {}\\n\", x, fib(x));\n  }\n}\n```\n\nThis is a simple project of course, but it should give us a clean project to start with.\nLet's try it out!\n\nLet's assume you have `fmt`, `range-v3`, and `cxxopts` installed with vcpkg classic mode;\nthen, you can just do a simple:\n\n```cmd\nD:\\src\\fibo> cmake -B build -S . -DCMAKE_TOOLCHAIN_FILE=D:\\src\\vcpkg\\scripts\\buildsystems\\vcpkg.cmake\n-- Building for: Visual Studio 16 2019\n-- Selecting Windows SDK version 10.0.18362.0 to target Windows 10.0.19041.\n-- The CXX compiler identification is MSVC 19.27.29111.0\n-- Detecting CXX compiler ABI info\n-- Detecting CXX compiler ABI info - done\n-- Check for working CXX compiler: C:/Program Files (x86)/Microsoft Visual Studio/2019/Community/VC/Tools/MSVC/14.27.29110/bin/Hostx64/x64/cl.exe - skipped\n-- Detecting CXX compile features\n-- Detecting CXX compile features - done\n-- Configuring done\n-- Generating done\n-- Build files have been written to: D:/src/fibo/build\nD:\\src\\fibo> cmake --build build\nMicrosoft (R) Build Engine version 16.7.0+b89cb5fde for .NET Framework\nCopyright (C) Microsoft Corporation. All rights reserved.\n\n  Checking Build System\n  Building Custom Rule D:/src/fibo/CMakeLists.txt\n  main.cxx\n  The contents of <span> are available only with C++20 or later.\n  fibo.vcxproj -> D:\\src\\fibo\\build\\Debug\\fibo.exe\n  Building Custom Rule D:/src/fibo/CMakeLists.txt\n```\n\nAnd now we can try out the `fibo` binary!\n\n```cmd\nD:\\src\\fibo> .\\build\\Debug\\fibo.exe -n 7 \nfib(1) = 1\nfib(2) = 1\nfib(3) = 2\nfib(4) = 3\nfib(5) = 5\nfib(6) = 8\nfib(7) = 13\n```\n\nit works!\n\n## Converting to Manifest Mode\n\nWe now wish to use manifest mode, so all of our dependencies are managed for us! Let's write a `vcpkg.json`:\n\n```json\n{\n  \"name\": \"fibo\",\n  \"version-string\": \"0.1.0\",\n  \"dependencies\": [\n    \"cxxopts\",\n    \"fmt\",\n    \"range-v3\"\n  ]\n}\n```\n\nLet's delete the build directory and rerun the build:\n\n```cmd\nD:\\src\\fibo> rmdir /S /Q build\nD:\\src\\fibo> cmake -B build -S . -DCMAKE_TOOLCHAIN_FILE=D:\\src\\vcpkg\\scripts\\buildsystems\\vcpkg.cmake\n-- Running vcpkg install\nDetecting compiler hash for triplet x64-windows...\nThe following packages will be built and installed:\n    cxxopts[core]:x64-windows\n    fmt[core]:x64-windows\n    range-v3[core]:x64-windows\nStarting package 1/3: cxxopts:x64-windows\nBuilding package cxxopts[core]:x64-windows...\nUsing cached binary package: C:\\Users\\me\\AppData\\Local\\vcpkg/archives\\d2\\d2d1e5302cdfefef2fd090d8eda84cc0c1fbe6f1.zip\nBuilding package cxxopts[core]:x64-windows... done\nInstalling package cxxopts[core]:x64-windows...\nInstalling package cxxopts[core]:x64-windows... done\nElapsed time for package cxxopts:x64-windows: 50.64 ms\nStarting package 2/3: fmt:x64-windows\nBuilding package fmt[core]:x64-windows...\nUsing cached binary package: C:\\Users\\me\\AppData\\Local\\vcpkg/archives\\bf\\bf00d5214e912d71414b545b241f54ef87fdf6e5.zip\nBuilding package fmt[core]:x64-windows... done\nInstalling package fmt[core]:x64-windows...\nInstalling package fmt[core]:x64-windows... done\nElapsed time for package fmt:x64-windows: 225 ms\nStarting package 3/3: range-v3:x64-windows\nBuilding package range-v3[core]:x64-windows...\nUsing cached binary package: C:\\Users\\me\\AppData\\Local\\vcpkg/archives\\fe\\fe2cdedef6953bf954e8ddca471bf3cc8d9b06d7.zip\nBuilding package range-v3[core]:x64-windows... done\nInstalling package range-v3[core]:x64-windows...\nInstalling package range-v3[core]:x64-windows... done\nElapsed time for package range-v3:x64-windows: 1.466 s\n\nTotal elapsed time: 1.742 s\n\n-- Running vcpkg install - done\n-- Selecting Windows SDK version 10.0.18362.0 to target Windows 10.0.19041.\n-- The CXX compiler identification is MSVC 19.27.29111.0\n-- Detecting CXX compiler ABI info\n-- Detecting CXX compiler ABI info - done\n-- Check for working CXX compiler: C:/Program Files (x86)/Microsoft Visual Studio/2019/Community/VC/Tools/MSVC/14.27.29110/bin/Hostx64/x64/cl.exe - skipped\n-- Detecting CXX compile features\n-- Detecting CXX compile features - done\n-- Configuring done\n-- Generating done\n-- Build files have been written to: D:/src/fibo/build\nD:\\src\\fibo> cmake --build build\nMicrosoft (R) Build Engine version 16.7.0+b89cb5fde for .NET Framework\nCopyright (C) Microsoft Corporation. All rights reserved.\n\n  Checking Build System\n  Building Custom Rule D:/src/fibo/CMakeLists.txt\n  main.cxx\n  The contents of <span> are available only with C++20 or later.\n  fibo.vcxproj -> D:\\src\\fibo\\build\\Debug\\fibo.exe\n  Building Custom Rule D:/src/fibo/CMakeLists.txt\n```\n\nYou can see that with just a _single file_, we've changed over to manifests without _any_ trouble.\nThe build system doesn't change _at all_! We just add a `vcpkg.json` file, delete the build directory,\nand reconfigure. And we're done!\n","Nav":"#"},{"Path":"/en/docs/examples/modify-baseline-to-pin-old-boost.html","Name":"Modify-baseline-to-pin-old-boost","Source":"# Pin old Boost versions\r\nThis document will teach you how to set versions of meta-packages like `boost` or `qt5`. \r\n\r\n**What is a meta-package?**  \r\nIn vcpkg we call meta-packages to ports that by themselves don't install anything but that instead forward installation to another port or ports. The reasons for these meta-packages to exist are plenty: to install different versions of a library depending on platform (like the old OpenSSL port did), to allow for multiple versions to exist in the vcpkg registry at the same time (OpenCV), or to conveniently install/uninstall a catalog of related packages (Boost and Qt).  \r\n\r\nIn the case of Boost, it is unlikely that a user requires all of the 140+ Boost libraries in their project. For the sake of convenience, vcpkg splits Boost into multiple sub-packages broken down to individual libraries. By doing so, users can limit the subset of Boost libraries that they depend on. \r\n\r\nIf a user wants to install all of the Boost libraries available in vcpkg, they can do so by installing the `boost` meta-package. \r\n\r\nDue to the nature of meta-packages, some unexpected issues arise when trying to use them with versioning. If a user writes the following manifest file:\r\n\r\n`vcpkg.json`\r\n```json\r\n{\r\n    \"name\": \"demo\",\r\n    \"version\": \"1.0.0\",\r\n    \"builtin-baseline\": \"787fe1418ea968913cc6daf11855ffd8b0b5e9d4\",\r\n    \"dependencies\": [ \"boost-tuple\" ],\r\n    \"overrides\": [ \r\n        { \"name\": \"boost\", \"version\": \"1.72.0\" }\r\n    ]\r\n}\r\n```\r\n\r\nThe resulting installation plan is:\r\n```\r\nThe following packages will be built and installed:\r\n    boost-assert[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-assert\\3393715b4ebe30fe1c3b68acf7f84363e611f156\r\n    boost-compatibility[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-compatibility\\cda5675366367789659c59aca65fc57d03c51deb\r\n    boost-config[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-config\\ca82ca1b9c1739c91f3cf42c68cee56c896ae6bd\r\n    boost-container-hash[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-container-hash\\bf472c23d29c3d80b562c43471eb92cea998f372\r\n    boost-core[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-core\\20a19f6ece37686a02eed33e1f58add8b7a2582a\r\n    boost-detail[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-detail\\96744251f025f9b3c856a275dfc338031876777b\r\n    boost-integer[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-integer\\de70ce0d1500df1eda3496c4f98f42f5db256b4a\r\n    boost-io[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-io\\7bf3407372f8fc2a99321d24a0e952d44fe25bf3\r\n    boost-preprocessor[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-preprocessor\\8d78b8ba2e9f54cb00137115ddd2ffec1c63c149\r\n    boost-static-assert[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-static-assert\\2a41c4703c7122de25b1c60510c43edc9371f63d\r\n    boost-throw-exception[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-throw-exception\\b13bdf32a20786a0165cc20205ef63765cac0627\r\n    boost-tuple[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-tuple\\22e3d000a178a88992c430d8ae8a0244c7dea674\r\n    boost-type-traits[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-type-traits\\8829793f6c6c913257314caa317599f8d253a5ca\r\n    boost-uninstall[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-uninstall\\08933bad27b6d41caef0940c31e2069ecb6a079c\r\n    boost-utility[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-utility\\47572946bf6a63c731b9c4142eecb8bef3d3b270\r\n    boost-vcpkg-helpers[core]:x64-windows -> 7#2 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-vcpkg-helpers\\2a21e5ab45d1ce41c185faf85dff0670ea6def1d\r\n```\r\n\r\nIt is reasonable to expect that overriding `boost` to version 1.72.0 results in all Boost packages being pinned to version 1.72.0. **However, vcpkg does not treat the `boost` meta-package any differently that any other port.** In other words, vcpkg has no notion that `boost` is related to all the other `boost-*` libraries, other than it depends on all of them. For this reason, all the other boost packages are installed at version 1.75.0, which is the baseline version.\r\n\r\nBelow, we describe two methods to pin down Boost versions effectively.\r\n\r\n## Method 1: Pin specific packages\r\nUse `\"overrides\"` to force specific versions in a package-by-package basis. \r\n\r\n`vcpkg.json`\r\n```json\r\n{\r\n    \"name\": \"demo\",\r\n    \"version\": \"1.0.0\",\r\n    \"builtin-baseline\": \"787fe1418ea968913cc6daf11855ffd8b0b5e9d4\",\r\n    \"dependencies\": [ \"boost-tuple\" ],\r\n    \"overrides\": [\r\n        { \"name\": \"boost-core\", \"version\": \"1.72\" },\r\n        { \"name\": \"boost-integer\", \"version\": \"1.72\" },\r\n        { \"name\": \"boost-io\", \"version\": \"1.72\" },\r\n        { \"name\": \"boost-tuple\", \"version\": \"1.72\" }     \r\n    ]\r\n}\r\n```\r\n\r\nThis method allows you to quickly set the specific versions you want, but you will need to write an override for each package. Boost libraries are also heavily interdependent, which means that you may end up writing a lot of override lines.\r\n\r\nThe second method makes it easy to pin the entire Boost collection and end up with a very simple manifest file.\r\n\r\n## Method 2: Modify baseline\r\nAn easy way to set the version for the entirety of boost is to use the `\"builtin-baseline\"` property. \r\n\r\nAs of right now, it is only possible to go back to Boost version `1.75.0` using a baseline. Since that was the contemporary Boost version when the versioning feature was merged. **But, it is possible to modify the baseline to whatever you like and use that instead.**\r\n\r\n### Step 1: Create a new branch\r\nAs described in the versioning documentation. The value that goes in `\"builtin-baseline\"` is a Git commit in the vcpkg repository's history. Then it stands to reason, that if you want to customize the baseline you should be able to create a new commit with said custom baseline. \r\n\r\nLet's start by creating a new branch to hold our modified baseline.  \r\nIn the directory containing your clone of the vcpkg Git repository run:\r\n\r\n```\r\ngit checkout -b custom-boost-baseline\r\n```\r\n\r\nThis will create a new branch named `custom-boost-baseline` and check it out immediately.\r\n\r\n### Step 2: Modify the baseline\r\nThe next step is to modify the baseline file, open the file in your editor of choice and modify the entries for the Boost libraries.\r\n\r\nChange the `\"baseline\"` version to your desired version.  \r\n_NOTE: Remember to also set the port versions to 0 (or your desired version)._\r\n\r\n`${vcpkg-root}/versions/baseline.json`\r\n```diff\r\n...\r\n     \"boost\": {\r\n-      \"baseline\": \"1.75.0\",\r\n+      \"baseline\": \"1.72.0\",\r\n       \"port-version\": 0\r\n     },\r\n     \"boost-accumulators\": {\r\n-      \"baseline\": \"1.75.0\",\r\n-      \"port-version\": 1\r\n+      \"baseline\": \"1.72.0\",\r\n+      \"port-version\": 0\r\n     },\r\n     \"boost-algorithm\": {\r\n-      \"baseline\": \"1.75.0\",\r\n+      \"baseline\": \"1.72.0\",\r\n       \"port-version\": 0\r\n     },\r\n     \"boost-align\": {\r\n-      \"baseline\": \"1.75.0\",\r\n+      \"baseline\": \"1.72.0\",\r\n       \"port-version\": 0\r\n     },\r\n...\r\n    \"boost-uninstall: {\r\n        \"baseline\": \"1.75.0\",\r\n        \"port-version\": 0\r\n    },\r\n...\r\n```\r\n\r\nSome `boost-` packages are helpers used by vcpkg and are not part of Boost. For example, `\"boost-uninstall\"` is a vcpkg helper to conveniently uninstall all Boost libraries, but it didn't exist for Boost version `1.72.0`, in this case it is fine to leave it at `1.75.0` to avoid baseline errors (since all versions in `baseline.json` must have existed). \r\n\r\n### Step 3: Commit your changes\r\nAfter saving your modified file, run these commands to commit your changes:\r\n\r\n```\r\ngit add versions/baseline.json\r\ngit commit -m \"Baseline Boost 1.72.0\"\r\n```\r\n\r\nYou can set the commit message to whatever you want, just make it useful for you.\r\n\r\n### Step 4: Get your baseline commit SHA\r\nOnce all your changes are ready, you can get the commit SHA by running:\r\n```\r\ngit rev-parse HEAD\r\n```\r\n\r\nThe output of that command will be the commit SHA you need to put as the `\"builtin-baseline\"` in your project's manifest file. Copy the 40-hex digits and save them to use later in your manifest file.\r\n\r\n### Step 5: (Optional) Go back to the main repository branch\r\nOnce your changes have been committed locally, you can refer to the commit SHA regardless of the repository branch you're working on. So, let's go back to the main vcpkg repository branch.\r\n\r\n```\r\ngit checkout master\r\n```\r\n\r\n### Step 6: Create your manifest file with your custom baseline\r\n\r\n```json\r\n{\r\n    \"name\": \"demo\",\r\n    \"version\": \"1.0.0\",\r\n    \"builtin-baseline\": \"9b5cf7c3d9376ddf43429671282972ec4f99aa85\",\r\n    \"dependencies\": [ \"boost-tuple\" ]\r\n}\r\n```\r\n\r\nIn this example, commit SHA `9b5cf7c3d9376ddf43429671282972ec4f99aa85` is the commit ID with the modified baseline. Even when a different branch (`master` in this case) is checked out, Git is able to find the commit as long as the branch with the modified baseline exists (the `custom-boost-baseline` branch we created in step 1).\r\n\r\nWe run `vcpkg --feature-flags=\"manifests,versions\" install` in the directory containing our manifest file and the output looks like this:\r\n\r\n```\r\nThe following packages will be built and installed:\r\n    boost-assert[core]:x64-windows -> 1.72.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-assert\\6754398591f48435b28014ca0d60e5375a4c04d1\r\n    boost-compatibility[core]:x64-windows -> 1.72.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-compatibility\\9893ff3c554575bc712df4108a949e07b269f401\r\n    boost-config[core]:x64-windows -> 1.72.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-config\\de2784767046b06ec31eb718f10df512e51f2aad\r\n    boost-container-hash[core]:x64-windows -> 1.72.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-container-hash\\cc19fb0154bbef188f309f49b2664ec7623b96b6\r\n    boost-core[core]:x64-windows -> 1.72.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-core\\0eb5e20df9e267e9eca325be946f52ceb8a60229\r\n    boost-detail[core]:x64-windows -> 1.72.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-detail\\759d7c6a3f9dbaed0b0c69fa0bb764f7606bb02d\r\n    boost-integer[core]:x64-windows -> 1.72.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-integer\\173956c61a26e83b0f8b58b0baf60f06aeee637c\r\n    boost-preprocessor[core]:x64-windows -> 1.72.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-preprocessor\\86eb3938b7875f124feb845331dbe84cbab5d1c6\r\n    boost-static-assert[core]:x64-windows -> 1.72.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-static-assert\\e82d8f7f3ee07e927dc374f5a08ed6d6f4ef81f4\r\n    boost-throw-exception[core]:x64-windows -> 1.72.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-throw-exception\\64df295f7df41de4fcb219834889b126b5020def\r\n    boost-tuple[core]:x64-windows -> 1.72.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-tuple\\b3e1b01ffce6e367e4fed0a5538a8546abacb6b2\r\n    boost-type-traits[core]:x64-windows -> 1.72.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-type-traits\\5e44ec657660eccf4d3b2710b092dd238e1e7a2d\r\n    boost-uninstall[core]:x64-windows -> 1.75.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-uninstall\\08933bad27b6d41caef0940c31e2069ecb6a079c\r\n    boost-utility[core]:x64-windows -> 1.72.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-utility\\7d721b2458d5d595ac341eb54883274f38a4b8c2\r\n    boost-vcpkg-helpers[core]:x64-windows -> 7#2 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\boost-vcpkg-helpers\\2a21e5ab45d1ce41c185faf85dff0670ea6def1d\r\n```\r\n\r\nNotice how simple our manifest file has become, instead of having a multitude of `\"overrides\"` you can pin down all Boost packages just by setting the `\"builtin-baseline\"` to be your modified baseline commit SHA.\r\n","Nav":"#"},{"Path":"/en/docs/examples/overlay-triplets-linux-dynamic.html","Name":"Overlay-triplets-linux-dynamic","Source":"# Overlay triplets example\r\n\r\n## Building dynamic libraries on Linux\r\n\r\nUsing **vcpkg** you can build libraries for many configurations out of the box. However, this doesn't currently include shared libraries on Linux and Mac OS.\r\n\r\nThis doesn't mean that you cannot use **vcpkg** to build your dynamic libraries on these platforms! This document will guide you through creating your own custom triplets with `--overlay-triplets` to easily build dynamic libraries on Linux.\r\n\r\n### Step 1: Create the custom triplet files\r\n\r\nTo save time, copy the existing `x64-linux.cmake` triplet file.\r\n\r\n```sh\r\n~/git$ mkdir custom-triplets\r\n~/git$ cp vcpkg/triplets/x64-linux.cmake custom-triplets/x64-linux-dynamic.cmake\r\n```\r\n\r\nAnd modify `custom-triplets/x64-linux-dynamic.cmake` to match the contents below:\r\n```cmake\r\n# ~/git/custom-triplets/x64-linux-dynamic.cmake\r\nset(VCPKG_TARGET_ARCHITECTURE x64)\r\nset(VCPKG_CRT_LINKAGE dynamic)\r\nset(VCPKG_LIBRARY_LINKAGE dynamic) # This changed from static to dynamic\r\n\r\nset(VCPKG_CMAKE_SYSTEM_NAME Linux)\r\n```\r\n\r\n### Step 2: Use `--overlay-triplets` to build dynamic libraries\r\n\r\nUse the `--overlay-triplets` option to include the triplets in the `custom-triplets` directory. \r\n\r\n```\r\n~/git$ vcpkg/vcpkg install sqlite3:x64-linux-dynamic --overlay-triplets=custom-triplets\r\nThe following packages will be built and installed:\r\n    sqlite3[core]:x64-linux-dynamic\r\nStarting package 1/1: sqlite3:x64-linux-dynamic\r\nBuilding package sqlite3[core]:x64-linux-dynamic...\r\n-- Loading triplet configuration from: /home/victor/git/custom-triplets/x64-linux-dynamic.cmake\r\n-- Downloading https://sqlite.org/2019/sqlite-amalgamation-3280000.zip...\r\n-- Extracting source /home/victor/git/vcpkg/downloads/sqlite-amalgamation-3280000.zip\r\n-- Applying patch fix-arm-uwp.patch\r\n-- Using source at /home/victor/git/vcpkg/buildtrees/sqlite3/src/3280000-6a3ff7ce92\r\n-- Configuring x64-linux-dynamic-dbg\r\n-- Configuring x64-linux-dynamic-rel\r\n-- Building x64-linux-dynamic-dbg\r\n-- Building x64-linux-dynamic-rel\r\n-- Performing post-build validation\r\n-- Performing post-build validation done\r\nBuilding package sqlite3[core]:x64-linux-dynamic... done\r\nInstalling package sqlite3[core]:x64-linux-dynamic...\r\nInstalling package sqlite3[core]:x64-linux-dynamic... done\r\nElapsed time for package sqlite3:x64-linux-dynamic: 44.82 s\r\n\r\nTotal elapsed time: 44.82 s\r\n\r\nThe package sqlite3:x64-linux-dynamic provides CMake targets:\r\n\r\n    find_package(unofficial-sqlite3 CONFIG REQUIRED)\r\n    target_link_libraries(main PRIVATE unofficial::sqlite3::sqlite3)\r\n```\r\n\r\nOverlay triplets enables your custom triplet files when using `vcpkg install`, `vcpkg update`, `vcpkg upgrade`, and `vcpkg remove`.\r\n\r\nWhen using the `--overlay-triplets` option, a message like the following lets you know that a custom triplet is being used: \r\n\r\n```\r\n-- Loading triplet configuration from: /home/custom-triplets/x64-linux-dynamic.cmake\r\n```\r\n\r\n## Overriding default triplets\r\n\r\nAs you may have noticed, the default triplets for Windows (`x86-windows` and `x64-windows`) install dynamic libraries, while a suffix (`-static`) is needed for static libraries. This is different with Linux and Mac OS where static libraries are built by `x64-linux` and `x64-osx`.\r\n\r\nUsing `--overlay-triplets` it is possible to override the default triplets to accomplish the same behavior on Linux:\r\n\r\n* `x64-linux`: Builds dynamic libraries,\r\n* `x64-linux-static`: Builds static libraries.\r\n\r\n### Step 1: Create the overlay triplets\r\n\r\nUsing the custom triplet created in the previous example, rename `custom-triplets/x64-linux-dynamic.cmake` to `custom-triplets/x64-linux.cmake`. Then, copy the default `x64-linux` triplet (which builds static libraries) in your `custom-triplets` folder and rename it to `x64-linux-static.cmake`.\r\n\r\n```sh\r\n~/git$ mv custom-triplets/x64-linux-dynamic.cmake custom-triplets/x64-linux.cmake\r\n~/git$ cp vcpkg/triplets/x64-linux.cmake custom-triplets/x64-linux-static.cmake\r\n```\r\n\r\n### Step 2: Use `--overlay-triplets` to override default triplets\r\n\r\nUse the `--overlay-triplets` option to include the triplets in the `custom-triplets` directory.\r\n\r\n```\r\n~/git$ vcpkg/vcpkg install sqlite3:x64-linux --overlay-triplets=custom-triplets\r\nThe following packages will be built and installed:\r\n    sqlite3[core]:x64-linux\r\nStarting package 1/1: sqlite3:x64-linux\r\nBuilding package sqlite3[core]:x64-linux...\r\n-- Loading triplet configuration from: /home/victor/git/custom-triplets/x64-linux.cmake\r\n-- Downloading https://sqlite.org/2019/sqlite-amalgamation-3280000.zip...\r\n-- Extracting source /home/victor/git/vcpkg/downloads/sqlite-amalgamation-3280000.zip\r\n-- Applying patch fix-arm-uwp.patch\r\n-- Using source at /home/victor/git/vcpkg/buildtrees/sqlite3/src/3280000-6a3ff7ce92\r\n-- Configuring x64-linux-dbg\r\n-- Configuring x64-linux-rel\r\n-- Building x64-linux-dbg\r\n-- Building x64-linux-rel\r\n-- Performing post-build validation\r\n-- Performing post-build validation done\r\nBuilding package sqlite3[core]:x64-linux... done\r\nInstalling package sqlite3[core]:x64-linux...\r\nInstalling package sqlite3[core]:x64-linux... done\r\nElapsed time for package sqlite3:x64-linux: 44.82 s\r\n\r\nTotal elapsed time: 44.82 s\r\n\r\nThe package sqlite3:x64-linux provides CMake targets:\r\n\r\n    find_package(unofficial-sqlite3 CONFIG REQUIRED)\r\n    target_link_libraries(main PRIVATE unofficial::sqlite3::sqlite3)\r\n```\r\n\r\nNote that the default triplet is masked by your custom triplet:\r\n\r\n```\r\n-- Loading triplet configuration from: /home/victor/git/custom-triplets/x64-linux.cmake\r\n```\r\n","Nav":"#"},{"Path":"/en/docs/examples/packaging-github-repos.html","Name":"Packaging-github-repos","Source":"## Packaging Github Repos Example: libogg\r\n### Create the manifest file\r\nThe manifest file (called `vcpkg.json`) is a json file describing the package's metadata.\r\n\r\nFor libogg, we'll create the file `ports/libogg/vcpkg.json` with the following content:\r\n\r\n```json\r\n{\r\n  \"name\": \"libogg\",\r\n  \"version-string\": \"1.3.3\",\r\n  \"description\": \"Ogg is a multimedia container format, and the native file and stream format for the Xiph.org multimedia codecs.\"\r\n}\r\n```\r\n\r\nYou can format the manifest file to our specifications with `vcpkg format-manifest ports/libogg/vcpkg.json`.\r\n\r\n### Create the portfile\r\n`portfile.cmake` describes how to build and install the package. First we download the project from Github with [`vcpkg_from_github`](../maintainers/vcpkg_from_github.md):\r\n\r\n```cmake\r\nvcpkg_from_github(\r\n    OUT_SOURCE_PATH SOURCE_PATH\r\n    REPO xiph/ogg\r\n    REF v1.3.3\r\n    SHA512 0bd6095d647530d4cb1f509eb5e99965a25cc3dd9b8125b93abd6b248255c890cf20710154bdec40568478eb5c4cde724abfb2eff1f3a04e63acef0fbbc9799b\r\n    HEAD_REF master\r\n)\r\n```\r\n\r\nThe important parts to update are `REPO` for the GitHub repository path, `REF` for a stable tag/commit to use, and `SHA512` with the checksum of the downloaded zipfile (you can get this easily by setting it to `0`, trying to install the package, and copying the checksum).\r\n\r\nFinally, we configure the project with CMake, install the package, and copy over the license file:\r\n\r\n```cmake\r\nvcpkg_configure_cmake(\r\n    SOURCE_PATH ${SOURCE_PATH}\r\n    PREFER_NINJA\r\n)\r\nvcpkg_install_cmake()\r\nfile(INSTALL ${SOURCE_PATH}/COPYING DESTINATION ${CURRENT_PACKAGES_DIR}/share/libogg RENAME copyright)\r\n```\r\n\r\nCheck the documentation for [`vcpkg_configure_cmake`](../maintainers/vcpkg_configure_cmake.md) and [`vcpkg_install_cmake`](../maintainers/vcpkg_install_cmake.md) if your package needs additional options. \r\n\r\nNow you can run `vcpkg install libogg` to build and install the package.\r\n\r\n### Suggested example portfiles\r\nIn the `ports/` directory are many libraries that can be used as examples, including many that are not based on CMake.\r\n\r\n- Header only libraries\r\n  - rapidjson\r\n  - range-v3\r\n- MSBuild-based\r\n  - mpg123\r\n- Non-CMake, custom buildsystem\r\n  - openssl\r\n  - ffmpeg\r\n","Nav":"#"},{"Path":"/en/docs/examples/packaging-zipfiles.html","Name":"Packaging-zipfiles","Source":"## Packaging `.zip` Files Example: zlib\n\n### Bootstrap with `create`\nFirst, locate a globally accessible archive of the library's sources. Zip, gzip, and bzip are all supported. Strongly prefer official sources or mirrors over unofficial mirrors.\n\n*Looking at zlib's website, the URL http://zlib.net/zlib-1.2.11.tar.gz looks appropriate.*\n\nSecond, determine a suitable package name. This should be ASCII, lowercase, and recognizable to someone who knows the library's \"human name\". If the library is already packaged in another package manager, prefer that name.\n\n*Since zlib is already packaged as zlib, we will use the name zlib2 for this example.*\n\nFinally, if the server's name for the archive is not very descriptive (such as downloading a zipped commit or branch from GitHub), choose a nice archive name of the form `<packagename>-<version>.zip`.\n\n*`zlib1211.zip` is a fine name, so no change needed.*\n\nAll this information can then be passed into the `create` command, which will download the sources and bootstrap the packaging process inside `ports/<packagename>`.\n\n```no-highlight\nPS D:\\src\\vcpkg> .\\vcpkg create zlib2 http://zlib.net/zlib-1.2.11.tar.gz zlib1211.tar.gz\n-- Generated portfile: D:/src/vcpkg/ports/zlib2/portfile.cmake\n```\n\n### Create the manifest file\nIn addition to the generated `ports/<package>/portfile.cmake`, we also need a `ports/<package>/vcpkg.json` file. This file is a simple set of fields describing the package's metadata.\n\n*For zlib2, we'll create the file `ports/zlib2/vcpkg.json` with the following contents:*\n```json\n{\n  \"name\": \"zlib2\",\n  \"version-string\": \"1.2.11\",\n  \"description\": \"A Massively Spiffy Yet Delicately Unobtrusive Compression Library\"\n}\n```\n\n### Tweak the generated portfile\nThe generated `portfile.cmake` will need some editing to correctly package most libraries in the wild, however we can start by trying out the build.\n\n```no-highlight\nPS D:\\src\\vcpkg> .\\vcpkg install zlib2\nComputing installation plan...\nThe following packages will be built and installed:\n    zlib2[core]:x64-uwp\nStarting package 1/1: zlib2:x64-uwp\nBuilding package zlib2[core]:x64-uwp...\n-- Using cached C:/src/vcpkg/downloads/zlib1211.tar.gz\n-- Cleaning sources at C:/src/vcpkg/buildtrees/zlib2/src/1.2.11-deec42f53b.clean. Pass --editable to vcpkg to reuse sources.\n-- Extracting source C:/src/vcpkg/downloads/zlib1211.tar.gz\n-- Applying patch cmake_dont_build_more_than_needed.patch\n-- Using source at C:/src/vcpkg/buildtrees/zlib2/src/1.2.11-deec42f53b.clean\n-- Configuring x64-uwp\n-- Building x64-uwp-dbg\n-- Building x64-uwp-rel\n-- Installing: C:/src/vcpkg/packages/zlib2_x64-uwp/share/zlib2/copyright\n-- Performing post-build validation\nInclude files should not be duplicated into the /debug/include directory. If this cannot be disabled in the project cmake, use\n    file(REMOVE_RECURSE ${CURRENT_PACKAGES_DIR}/debug/include)\n/debug/share should not exist. Please reorganize any important files, then use\n    file(REMOVE_RECURSE ${CURRENT_PACKAGES_DIR}/debug/share)\nThe software license must be available at ${CURRENT_PACKAGES_DIR}/share/zlib2/copyright\nFound 3 error(s). Please correct the portfile:\n    D:\\src\\vcpkg\\ports\\zlib2\\portfile.cmake\n```\n\nAt this point, it is a matter of reading the error messages and log files while steadily improving the quality of the portfile. Zlib required providing a discrete copy of the LICENSE to copy into the package, suppressing the build and installation of executables and headers, and removing the static libraries after they were installed.\n\n### Suggested example portfiles\nIn the `ports/` directory are many libraries that can be used as examples, including many that are not based on CMake.\n\n- Header only libraries\n    - rapidjson\n    - range-v3\n- MSBuild-based\n    - mpg123\n- Non-CMake, custom buildsystem\n    - openssl\n    - ffmpeg\n","Nav":"#"},{"Path":"/en/docs/examples/patching.html","Name":"Patching","Source":"## Patching Example: Patching libpng to work for x64-uwp\n\n### Initial error logs\nFirst, try building:\n\n```no-highlight\nPS D:\\src\\vcpkg> vcpkg install libpng:x64-uwp --editable\nComputing installation plan...\nThe following packages will be built and installed:\n    libpng[core]:x64-uwp\nStarting package 1/1: libpng:x64-uwp\nBuilding package libpng[core]:x64-uwp...\n-- Using cached D:/src/vcpkg/downloads/glennrp-libpng-v1.6.37.tar.gz\n-- Extracting source D:/src/vcpkg/downloads/glennrp-libpng-v1.6.37.tar.gz\n-- Using source at D:/src/vcpkg/buildtrees/libpng/src/v1.6.37-c993153cdf\n-- Configuring x64-uwp\n-- Building x64-uwp-rel\nCMake Error at scripts/cmake/execute_required_process.cmake:14 (message):\n  Command failed: C:/Program Files/CMake/bin/cmake.exe;--build;.;--config;Release\n\n  Working Directory: D:/src/vcpkg/buildtrees/libpng/x64-uwp-rel\n\n  See logs for more information:\n\n      D:\\src\\vcpkg\\buildtrees\\libpng\\build-x64-uwp-rel-out.log\n      D:\\src\\vcpkg\\buildtrees\\libpng\\build-x64-uwp-rel-err.log\n\nCall Stack (most recent call first):\n  scripts/cmake/vcpkg_build_cmake.cmake:3 (execute_required_process)\n  ports/libpng/portfile.cmake:22 (vcpkg_build_cmake)\n  scripts/ports.cmake:84 (include)\n\n\nError: build command failed\n```\n\nNext, looking at the above logs (build-xxx-out.log and build-xxx-err.log).\n\n```no-highlight\n// build-x64-uwp-rel-out.log\n...\n\"D:\\src\\vcpkg\\buildtrees\\libpng\\x64-uwp-rel\\ALL_BUILD.vcxproj\" (default target) (1) ->\n\"D:\\src\\vcpkg\\buildtrees\\libpng\\x64-uwp-rel\\png.vcxproj\" (default target) (3) ->\n(ClCompile target) -> \n  D:\\src\\vcpkg\\buildtrees\\libpng\\src\\v1.6.37-c993153cdf\\pngerror.c(775): warning C4013: 'ExitProcess' undefined; assuming extern returning int [D:\\src\\vcpkg\\buildtrees\\libpng\\x64-uwp-rel\\png.vcxproj]\n\n\n\"D:\\src\\vcpkg\\buildtrees\\libpng\\x64-uwp-rel\\ALL_BUILD.vcxproj\" (default target) (1) ->\n\"D:\\src\\vcpkg\\buildtrees\\libpng\\x64-uwp-rel\\png.vcxproj\" (default target) (3) ->\n(Link target) -> \n  pngerror.obj : error LNK2019: unresolved external symbol _ExitProcess referenced in function _png_longjmp [D:\\src\\vcpkg\\buildtrees\\libpng\\x64-uwp-rel\\png.vcxproj]\n  D:\\src\\vcpkg\\buildtrees\\libpng\\x64-uwp-rel\\Release\\libpng16.dll : fatal error LNK1120: 1 unresolved externals [D:\\src\\vcpkg\\buildtrees\\libpng\\x64-uwp-rel\\png.vcxproj]\n\n    1 Warning(s)\n    2 Error(s)\n\nTime Elapsed 00:00:04.19\n```\n\n### Identify the problematic code\n\nTaking a look at [MSDN](https://msdn.microsoft.com/en-us/library/windows/desktop/ms682658(v=vs.85).aspx) shows that `ExitProcess` is only available for desktop apps. Additionally, it's useful to see the surrounding context:\n\n```c\n/* buildtrees\\libpng\\src\\v1.6.37-c993153cdf\\pngerror.c:769 */\n    /* If control reaches this point, png_longjmp() must not return. The only\n    * choice is to terminate the whole process (or maybe the thread); to do\n    * this the ANSI-C abort() function is used unless a different method is\n    * implemented by overriding the default configuration setting for\n    * PNG_ABORT().\n    */\n    PNG_ABORT();\n```\n\nA recursive search for `PNG_ABORT` reveals the definition:\n```no-highlight\nPS D:\\src\\vcpkg\\buildtrees\\libpng\\src\\v1.6.37-c993153cdf> findstr /snipl \"PNG_ABORT\" *\nCHANGES:701:  Added PNG_SETJMP_SUPPORTED, PNG_SETJMP_NOT_SUPPORTED, and PNG_ABORT() macros\nlibpng-manual.txt:432:errors will result in a call to PNG_ABORT() which defaults to abort().\nlibpng-manual.txt:434:You can #define PNG_ABORT() to a function that does something\nlibpng-manual.txt:2753:errors will result in a call to PNG_ABORT() which defaults to abort().\nlibpng-manual.txt:2755:You can #define PNG_ABORT() to a function that does something\nlibpng-manual.txt:4226:PNG_NO_SETJMP, in which case it is handled via PNG_ABORT()),\nlibpng.3:942:errors will result in a call to PNG_ABORT() which defaults to abort().\nlibpng.3:944:You can #define PNG_ABORT() to a function that does something\nlibpng.3:3263:errors will result in a call to PNG_ABORT() which defaults to abort().\nlibpng.3:3265:You can #define PNG_ABORT() to a function that does something\nlibpng.3:4736:PNG_NO_SETJMP, in which case it is handled via PNG_ABORT()),\npng.h:994: * will use it; otherwise it will call PNG_ABORT().  This function was\npngerror.c:773:    * PNG_ABORT().\npngerror.c:775:   PNG_ABORT();\npngpriv.h:459:#ifndef PNG_ABORT\npngpriv.h:461:#    define PNG_ABORT() ExitProcess(0)\npngpriv.h:463:#    define PNG_ABORT() abort()\n```\n\nThis already gives us some great clues, but the full definition tells the complete story.\n\n```c\n/* buildtrees\\libpng\\src\\v1.6.37-c993153cdf\\pngpriv.h:459 */\n#ifndef PNG_ABORT\n#  ifdef _WINDOWS_\n#    define PNG_ABORT() ExitProcess(0)\n#  else\n#    define PNG_ABORT() abort()\n#  endif\n#endif\n```\n\n`abort()` is a standard CRT call and certainly available in UWP, so we just need to convince libpng to be more platform agnostic. The easiest and most reliable way to achieve this is to patch the code; while in this particular case we could pass in a compiler flag to override `PNG_ABORT` because this is a private header, in general it is more reliable to avoid adding more required compiler switches when possible (especially when it isn't already exposed as a CMake option).\n\n### Patching the code to improve compatibility\n\nWe recommend using git to create the patch file, since you'll already have it installed.\n```no-highlight\nPS D:\\src\\vcpkg\\buildtrees\\libpng\\src\\v1.6.37-c993153cdf> git init .\nInitialized empty Git repository in D:/src/vcpkg/buildtrees/libpng/src/v1.6.37-c993153cdf/.git/\n\nPS D:\\src\\vcpkg\\buildtrees\\libpng\\src\\v1.6.37-c993153cdf> git add .\nwarning: LF will be replaced by CRLF in ANNOUNCE.\nThe file will have its original line endings in your working directory.\n...\n\nPS D:\\src\\vcpkg\\buildtrees\\libpng\\src\\v1.6.37-c993153cdf> git commit -m \"temp\"\n[master (root-commit) 68f253f] temp\n 422 files changed, 167717 insertions(+)\n...\n```\n\nNow we can modify `pngpriv.h` to use `abort()` everywhere.\n```c\n/* buildtrees\\libpng\\src\\v1.6.37-c993153cdf\\pngpriv.h:459 */\n#ifndef PNG_ABORT\n#  define PNG_ABORT() abort()\n#endif\n```\n\nThe output of `git diff` is already in patch format, so we just need to save the patch into the `ports/libpng` directory.\n```no-highlight\nPS buildtrees\\libpng\\src\\v1.6.37-c993153cdf> git diff --ignore-space-at-eol | out-file -enc ascii ..\\..\\..\\..\\ports\\libpng\\use-abort-on-all-platforms.patch\n```\n\nFinally, we need to apply the patch after extracting the source.\n```cmake\n# ports\\libpng\\portfile.cmake\n...\nvcpkg_extract_source_archive_ex(\n  OUT_SOURCE_PATH SOURCE_PATH\n  ARCHIVE ${ARCHIVE}\n  PATCHES \n    \"use-abort-on-all-platforms.patch\"\n)\n\nvcpkg_configure_cmake(\n...\n```\n\n### Verification\n\nTo be completely sure this works from scratch, we need to remove the package and rebuild it:\n\n```no-highlight\nPS D:\\src\\vcpkg> vcpkg remove libpng:x64-uwp\nPackage libpng:x64-uwp was successfully removed\n```\n\nNow we try a fresh, from scratch install.\n\n```no-highlight\nPS D:\\src\\vcpkg> vcpkg install libpng:x64-uwp\nComputing installation plan...\nThe following packages will be built and installed:\n    libpng[core]:x64-uwp\nStarting package 1/1: libpng:x64-uwp\nBuilding package libpng[core]:x64-uwp...\nCould not locate cached archive: C:\\Users\\me\\AppData\\Local\\vcpkg/archives\\f4\\f44b54f818f78b9a4ccd34b3666f566f94286850.zip\n-- Using cached D:/src/vcpkg/downloads/glennrp-libpng-v1.6.37.tar.gz\n-- Extracting source D:/src/vcpkg/downloads/glennrp-libpng-v1.6.37.tar.gz\n-- Applying patch use_abort.patch\n-- Applying patch cmake.patch\n-- Applying patch pkgconfig.patch\n-- Applying patch pkgconfig.2.patch\n-- Using source at D:/src/vcpkg/buildtrees/libpng/src/v1.6.37-10db9f58e4.clean\n-- Configuring x64-uwp\n-- Building x64-uwp-dbg\n-- Building x64-uwp-rel\n-- Fixing pkgconfig file: D:/src/vcpkg/packages/libpng_x64-uwp/lib/pkgconfig/libpng.pc\n-- Fixing pkgconfig file: D:/src/vcpkg/packages/libpng_x64-uwp/lib/pkgconfig/libpng16.pc\n-- Fixing pkgconfig file: D:/src/vcpkg/packages/libpng_x64-uwp/debug/lib/pkgconfig/libpng.pc\n-- Fixing pkgconfig file: D:/src/vcpkg/packages/libpng_x64-uwp/debug/lib/pkgconfig/libpng16.pc\n-- Installing: D:/src/vcpkg/packages/libpng_x64-uwp/share/libpng/copyright\n-- Performing post-build validation\n-- Performing post-build validation done\nStored binary cache: C:\\Users\\me\\AppData\\Local\\vcpkg/archives\\f4\\f44b54f818f78b9a4ccd34b3666f566f94286850.zip\nBuilding package libpng[core]:x64-uwp... done\nInstalling package libpng[core]:x64-uwp...\nInstalling package libpng[core]:x64-uwp... done\nElapsed time for package libpng:x64-uwp: 11.94 s\n\nTotal elapsed time: 11.95 s\n\nThe package libpng:x64-uwp provides CMake targets:\n\n    find_package(libpng CONFIG REQUIRED)\n    target_link_libraries(main PRIVATE png)\n```\n\nFinally, to fully commit and publish the changes, we need to bump the port version in `vcpkg.json`,\nand add the patch file to source control, then make a Pull Request!\n\n```json\n{\n  \"name\": \"libpng\",\n  \"version\": \"1.6.37\",\n  \"port-version\": 1,\n  \"dependencies\": [\n    \"zlib\"\n  ]\n}\n```\n","Nav":"#"},{"Path":"/en/docs/examples/versioning.getting-started.html","Name":"Get Started with Versioning","Source":"# Getting started with versioning\r\n\r\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/examples/versioning.getting-started.md).**\r\n\r\nVcpkg lets you take control of which version of packages to install in your projects using manifests. \r\n\r\n## Using versions with manifests\r\n\r\nWith the `versions` feature flag enabled you can start adding version constraints to your dependencies.\r\n\r\nLet's start with creating a simple CMake project that depends on `fmt` and `zlib`.\r\n\r\nCreate a folder with the following files:\r\n\r\n**vcpkg.json**\r\n```json\r\n{\r\n    \"name\": \"versions-test\",\r\n    \"version\": \"1.0.0\",\r\n    \"dependencies\": [\r\n        {\r\n            \"name\": \"fmt\",\r\n            \"version>=\": \"7.1.3#1\"\r\n        }, \r\n        \"zlib\"\r\n    ],\r\n    \"builtin-baseline\": \"3426db05b996481ca31e95fff3734cf23e0f51bc\"\r\n}\r\n```\r\n\r\n**main.cpp**\r\n```c++\r\n#include <fmt/core.h>\r\n#include <zlib.h>\r\n\r\nint main()\r\n{\r\n    fmt::print(\"fmt version is {}\\n\"\r\n               \"zlib version is {}\\n\", \r\n               FMT_VERSION, ZLIB_VERSION);\r\n    return 0;\r\n}\r\n```\r\n\r\n**CMakeLists.txt**\r\n```CMake\r\ncmake_minimum_required(VERSION 3.18)\r\n\r\nproject(versionstest CXX)\r\n\r\nadd_executable(main main.cpp)\r\n\r\nfind_package(ZLIB REQUIRED)\r\nfind_package(fmt CONFIG REQUIRED)\r\ntarget_link_libraries(main PRIVATE ZLIB::ZLIB fmt::fmt)\r\n```\r\n\r\nAnd now we build and run our project with CMake:\r\n\r\n1. Create the build directory for the project.\r\n```\r\nPS D:\\versions-test> mkdir build\r\nPS D:\\versions-test> cd build\r\n```\r\n\r\n2. Configure CMake.  \r\n```\r\nPS D:\\versions-test\\build> cmake -G Ninja -DCMAKE_TOOLCHAIN_FILE=D:/vcpkg/scripts/buildsystems/vcpkg.cmake ..\r\n-- Running vcpkg install\r\nDetecting compiler hash for triplet x86-windows...\r\nThe following packages will be built and installed:\r\n    fmt[core]:x64-windows -> 7.1.3#1 -- D:\\Work\\viromer\\vcpkg\\buildtrees\\versioning\\versions\\fmt\\4f8427eb0bd40da1856d4e67bde39a4fda689d72\r\n    vcpkg-cmake[core]:x64-windows -> 2021-02-26 -- D:\\Work\\viromer\\vcpkg\\buildtrees\\versioning\\versions\\vcpkg-cmake\\51896aa8073adb5c8450daa423d03eedf0dfc61f\r\n    vcpkg-cmake-config[core]:x64-windows -> 2021-02-26 -- D:\\Work\\viromer\\vcpkg\\buildtrees\\versioning\\versions\\vcpkg-cmake-config\\d255b3d566a8861dcc99a958240463e678528066\r\n    zlib[core]:x64-windows -> 1.2.11#9 -- D:\\Work\\viromer\\vcpkg\\buildtrees\\versioning\\versions\\zlib\\827111046e37c98153d9d82bb6fa4183b6d728e4\r\n...\r\n```\r\n\r\n3. Build the project.\r\n```\r\nPS D:\\versions-test\\build> cmake --build .\r\n[2/2] Linking CXX executable main.exe\r\n```\r\n\r\n4. Run it!\r\n```\r\nPS D:\\versions-test\\build> ./main.exe\r\nfmt version is 70103\r\nzlib version is 1.2.11\r\n```\r\n\r\nTake a look at the output:\r\n\r\n```\r\nfmt[core]:x86-windows -> 7.1.3#1 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\fmt\\4f8427eb0bd40da1856d4e67bde39a4fda689d72\r\n...\r\nzlib[core]:x86-windows -> 1.2.11#9 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\zlib\\827111046e37c98153d9d82bb6fa4183b6d728e4\r\n```\r\n\r\nInstead of using the portfiles in `ports/`, vcpkg is checking out the files for each version in `buildtrees/versioning/versions/`. The files in `ports/` are still used when running vcpkg in classic mode or when the `versions` feature flag is disabled. \r\n\r\n_NOTE: Output from vcpkg while configuring CMake is only available when using CMake version `3.18` or newer. If you're using an older CMake you can check the `vcpkg-manifest-install.log` file in your build directory instead._\r\n\r\nRead our [manifests announcement blog post](https://devblogs.microsoft.com/cppblog/vcpkg-accelerate-your-team-development-environment-with-binary-caching-and-manifests/#using-manifests-with-msbuild-projects) to learn how to use manifests with MSBuild.\r\n\r\n### Manifest changes\r\nIf you have used manifests before you will notice that there are some new JSON properties. Let's review these changes:\r\n\r\n#### **`version`**\r\n```json\r\n{\r\n    \"name\": \"versions-test\",\r\n    \"version\": \"1.0.0\"\r\n}\r\n```\r\n\r\nThis is your project's version declaration. Previously, you could only declare versions for your projects using the `version-string` property. Now that versioning has come around, vcpkg is aware of some new versioning schemes.\r\n\r\nVersion scheme   | Description\r\n---------------- | ---------------\r\n`version`        | Dot-separated numerics: `1.0.0.5`.\r\n`version-semver` | Compliant [semantic versions](https://semver.org): `1.2.0` and `1.2.0-rc`.\r\n`version-date`   | Dates in `YYYY-MM-DD` format: `2021-01-01`\r\n`version-string` | Arbitrary strings: `vista`, `candy`.\r\n\r\n#### **`version>=`** \r\n```json\r\n{\r\n    \"dependencies\": [\r\n        { \"name\": \"fmt\", \"version>=\": \"7.1.3\" },\r\n        \"zlib\"\r\n    ]\r\n}\r\n```\r\n\r\nThis property is used to express minimum version constraints, it is allowed only as part of the `\"dependencies\"` declarations. In our example we set an explicit constraint on version `7.1.3#1` of `fmt`. \r\n\r\nVcpkg is allowed to upgrade this constraint if a transitive dependency requires a newer version. For example, if `zlib` were to declare a dependency on `fmt` version `7.1.4` then vcpkg would install `7.1.4` instead.\r\n\r\nVcpkg uses a minimum version approach, in our example, even if `fmt` version `8.0.0` were to be released, vcpkg would still install version `7.1.3#1` as that is the minimum version that satisfies the constraint. The advantages of this approach are that you don't get unexpected dependency upgrades when you update vcpkg and you get reproducible builds (in terms of version used) as long as you use the same manifest. \r\n\r\nIf you want to upgrade your dependencies, you can bump the minimum version constraint or use a newer baseline.\r\n\r\n#### **`builtin-baseline`**\r\n\r\n```json\r\n{ \"builtin-baseline\": \"3426db05b996481ca31e95fff3734cf23e0f51bc\" }\r\n```\r\n\r\nThis field declares the versioning baseline for all ports. Setting a baseline is required to enable versioning, otherwise you will get the current versions on the ports directory. You can run 'git rev-parse HEAD' to get the current commit of vcpkg and set it as the builtin-baseline. See the [`builtin-baseline` documentation](../users/versioning.md#builtin-baseline) for more information.\r\n\r\nIn our example, you can notice that we do not declare a version constraint for `zlib`; instead, the version is taken from the baseline. Internally, vcpkg will look in commit `3426db05b996481ca31e95fff3734cf23e0f51bc` to find out what version of `zlib` was the latest at that point in time (in our case it was `1.2.11#9`).\r\n\r\nDuring version resolution, baseline versions are treated as minimum version constraints. If you declare an explicit constraint that is lower than a baseline version, the explicit constraint will be upgraded to the baseline version. \r\n\r\nFor example, if we modified our dependencies like this:\r\n```json\r\n{ \"dependencies\": [\r\n    {\r\n        \"name\": \"fmt\",\r\n        \"version>=\": \"7.1.3#1\"\r\n    },\r\n    {\r\n        \"name\": \"zlib\",\r\n        \"version>=\": \"1.2.11#7\"\r\n    }\r\n] }\r\n```\r\n\r\n_NOTE: The value `1.2.11#7` represents version `1.2.11`, port version `7`._\r\n\r\nSince the baseline introduces a minimum version constraint for `zlib` at `1.2.11#9` and a higher version does satisfy the minimum version constraint for `1.2.11#7`, vcpkg is allowed to upgrade it. \r\n\r\nBaselines are also a convenient mechanism to upgrade multiple versions at a time, for example, if you wanted to depend on multiple `boost` libraries, it is more convenient to set the `baseline` once than declaring a version constraint on each package.\r\n\r\nBut what if you want to pin a version older than the baseline? \r\n\r\n#### **`overrides`**\r\n\r\nSince baselines establish a version floor for all packages and explicit constraints get upgraded when they are lower than the baseline, we need another mechanism to downgrade versions past the baseline.\r\n\r\nThe mechanism vcpkg provides for that scenario is `overrides`. When an override is declared on a package, vcpkg will ignore all other version constraints either directly declared in the manifest or from transitive dependencies. In short, `overrides` will force vcpkg to use the exact version declared, period.\r\n\r\nLet's modify our example once more, this time to force vcpkg to use version `6.0.0` of `fmt`.\r\n\r\n```json\r\n{\r\n    \"name\": \"versions-test\",\r\n    \"version\": \"1.0.0\",\r\n    \"dependencies\": [\r\n        {\r\n            \"name\": \"fmt\",\r\n            \"version>=\": \"7.1.3#1\"\r\n        },\r\n        {\r\n            \"name\": \"zlib\",\r\n            \"version>=\": \"1.2.11#7\"\r\n        }\r\n    ],\r\n    \"builtin-baseline\": \"3426db05b996481ca31e95fff3734cf23e0f51bc\",\r\n    \"overrides\": [\r\n        {\r\n            \"name\": \"fmt\",\r\n            \"version\": \"6.0.0\"\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\nRebuild our project:\r\n\r\n```\r\nPS D:\\versions-test\\build> rm ./CMakeCache.txt\r\nPS D:\\versions-test\\build> rm -r ./vcpkg_installed\r\nPS D:\\versions-test\\build> cmake -G Ninja -DCMAKE_TOOLCHAIN_FILE=D:/vcpkg/scripts/buildsystems/vcpkg.cmake ..\r\n-- Running vcpkg install\r\nDetecting compiler hash for triplet x86-windows...\r\nThe following packages will be built and installed:\r\n    fmt[core]:x86-windows -> 6.0.0 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\fmt\\d99b6a35e1406ba6b6e09d719bebd086f83ed5f3\r\n    zlib[core]:x86-windows -> 1.2.11#9 -- D:\\vcpkg\\buildtrees\\versioning\\versions\\zlib\\827111046e37c98153d9d82bb6fa4183b6d728e4\r\n...\r\nPS D:\\versions-test\\build> cmake --build .\r\n[2/2] Linking CXX executable main.exe\r\n```\r\n\r\nAnd run it!\r\n```\r\nPS D:\\versions-test\\build> .\\main.exe\r\nfmt version is 60000\r\nzlib version is 1.2.11\r\n```\r\n\r\nNotice how the `fmt` is now at version `6.0.0` just like we wanted.\r\n\r\n## Versions and custom ports\r\n\r\nThe last thing to discuss is how overlay ports interact with versioning resolution. The answer is: they don't. \r\n\r\nGoing into more detail, when you provide an overlay for a port, vcpkg will always use the overlay port without caring what version is contained in it. The reasons are two-fold: (1) it is consistent with the existing behavior of overlay ports of completely masking the existing port, and (2) overlay ports do not (and are not expected to) provide enough information to power vcpkg's versioning feature.\r\n\r\nIf you want to have flexible port customization along with versioning features, you should consider making your own custom registry. See our [registries specification for more details](../specifications/registries.md).\r\n\r\n## Further reading\r\n\r\nIf you're interested in delving deeper into the details of how versioning works we recommended that you read the [original versioning specification](../specifications/versioning.md) and the [implementation details](../users/versioning.implementation-details.md).\r\n\r\nSee also:\r\n\r\n* [Versioning docs](../users/versioning.md)\r\n* [Original specification](../specifications/versioning.md)\r\n* [Versioning implementation details](../users/versioning.implementation-details.md)\r\n","Nav":"#"},{"Path":"/en/docs/maintainers/cmake-guidelines.html","Name":"CMake-guidelines","Source":"# CMake Guidelines\r\n\r\nWe expect that all CMake scripts that are either:\r\n\r\n- In the `scripts/` directory, or\r\n- In a `vcpkg-*` port\r\n\r\nshould follow the guidelines laid out in this document.\r\nExisting scripts may not follow these guidelines yet;\r\nit is expected that we will continue to update old scripts\r\nto fall in line with these guidelines.\r\n\r\nThese guidelines are intended to create stability in our scripts.\r\nWe hope that they will make both forwards and backwards compatibility easier.\r\n\r\n## The Guidelines\r\n\r\n- Except for out-parameters, we always use `cmake_parse_arguments()`\r\n  rather than function parameters or referring to `${ARG<N>}`.\r\n  - This doesn't necessarily need to be followed for \"script-local helper functions\"\r\n    - In this case, positional parameters should be put in the function\r\n      declaration (rather than using `${ARG<N>}`),\r\n      and should be named according to local rules (i.e. `snake_case`).\r\n    - Exception: positional parameters that are optional should be\r\n      given a name via `set(argument_name \"${ARG<N>}\")`, after checking `ARGC`.\r\n  - Out-parameters should be the first parameter to a function. Example:\r\n  ```cmake\r\n  function(format out_var)\r\n    cmake_parse_arguments(PARSE_ARGV 1 \"arg\" ...)\r\n    # ... set(buffer \"output\")\r\n    set(\"${out_var}\" \"${buffer}\" PARENT_SCOPE)\r\n  endfunction()\r\n  ```\r\n- There are no unparsed or unused arguments.\r\n  Always check for `ARGN` or `arg_UNPARSED_ARGUMENTS`.\r\n  `FATAL_ERROR` when possible, `WARNING` if necessary for backwards compatibility.\r\n- All `cmake_parse_arguments` must use `PARSE_ARGV`.\r\n- All `foreach` loops must use `IN LISTS`, `IN ITEMS`, or `RANGE`.\r\n- The variables `${ARGV}` and `${ARGN}` are unreferenced,\r\n  except in helpful messages to the user.\r\n  - (i.e., `message(FATAL_ERROR \"blah was passed extra arguments: ${ARGN}\")`)\r\n- We always use functions, not macros or top level code.\r\n  - Exception: \"script-local helper macros\". It is sometimes helpful to define a small macro.\r\n    This should be done sparingly, and functions should be preferred.\r\n  - Exception: `vcpkg.cmake`'s `find_package`.\r\n- Scripts in the scripts tree should not be expected to need observable changes\r\n  as part of normal operation.\r\n  - Example violation: `vcpkg_acquire_msys()` has hard-coded packages and versions\r\n    that need updating over time due to the MSYS project dropping old packages.\r\n  - Example exception: `vcpkg_from_sourceforge()` has a list of mirrors which\r\n    needs maintenance, but does not have an observable behavior impact on the callers.\r\n- Rules for quoting: there are three kinds of arguments in CMake -\r\n  unquoted (`foo(BAR)`), quoted (`foo(\"BAR\")`), and bracketed (`foo([[BAR]])`).\r\n  Follow these rules to quote correctly:\r\n  - If an argument contains a variable expansion `${...}`,\r\n    it must be quoted.\r\n    - Exception: a \"splat\" variable expansion, when one variable will be\r\n      passed to a function as multiple arguments. In this case, the argument\r\n      should simply be `${foo}`:\r\n      ```cmake\r\n      vcpkg_list(SET working_directory)\r\n      if(DEFINED \"arg_WORKING_DIRECTORY\")\r\n        vcpkg_list(SET working_directory WORKING_DIRECTORY \"${arg_WORKING_DIRECTORY}\")\r\n      endif()\r\n      # calls do_the_thing() if NOT DEFINED arg_WORKING_DIRECTORY,\r\n      # else calls do_the_thing(WORKING_DIRECTORY \"${arg_WORKING_DIRECTORY}\")\r\n      do_the_thing(${working_directory})\r\n      ```\r\n  - Otherwise, if the argument contains any escape sequences that are not\r\n    `\\\\`, `\\\"`, or `\\$`, that argument must be a quoted argument.\r\n    - For example: `\"foo\\nbar\"` must be quoted.\r\n  - Otherwise, if the argument contains a `\\`, a `\"`, or a `$`,\r\n    that argument should be bracketed.\r\n    - Example:\r\n      ```cmake\r\n      set(x [[foo\\bar]])\r\n      set(y [=[foo([[bar\\baz]])]=])\r\n      ```\r\n  - Otherwise, if the argument contains characters that are\r\n    not alphanumeric or `_`, that argument should be quoted.\r\n  - Otherwise, the argument should be unquoted.\r\n  - Exception: arguments to `if()` of type `<variable|string>` should always be quoted:\r\n    - Both arguments to the comparison operators -\r\n      `EQUAL`, `STREQUAL`, `VERSION_LESS`, etc.\r\n    - The first argument to `MATCHES` and `IN_LIST`\r\n    - Example:\r\n      ```cmake\r\n      if(\"${FOO}\" STREQUAL \"BAR\") # ...\r\n      if(\"${BAZ}\" EQUAL \"0\") # ...\r\n      if(\"FOO\" IN_LIST list_variable) # ...\r\n      if(\"${bar}\" MATCHES [[a[bcd]+\\.[bcd]+]]) # ...\r\n      ```\r\n    - For single expressions and for other types of predicates that do not\r\n    take `<variable|string>`, use the normal rules.\r\n- There are no \"pointer\" or \"in-out\" parameters\r\n  (where a user passes a variable name rather than the contents),\r\n  except for simple out-parameters.\r\n- Variables are not assumed to be empty.\r\n  If the variable is intended to be used locally,\r\n  it must be explicitly initialized to empty with `set(foo \"\")` if it is a string variable,\r\n  and `vcpkg_list(SET foo)` if it is a list variable.\r\n- `set(var)` should not be used. Use `unset(var)` to unset a variable,\r\n  `set(var \"\")` to set it to the empty string,\r\n  and `vcpkg_list(SET var)` to set it to the empty list.\r\n  _Note: the empty string and the empty list are the same value;_\r\n  _this is a notational difference rather than a difference in result_\r\n- All variables expected to be inherited from the parent scope across an API boundary\r\n  (i.e. not a file-local function) should be documented.\r\n  Note that all variables mentioned in triplets.md are considered documented.\r\n- Out parameters are only set in `PARENT_SCOPE` and are never read.\r\n  See also the helper `z_vcpkg_forward_output_variable()` to forward out parameters through a function scope.\r\n- `CACHE` variables are used only for global variables which are shared internally among strongly coupled\r\n  functions and for internal state within a single function to avoid duplicating work.\r\n  These should be used extremely sparingly and should use the `Z_VCPKG_` prefix to avoid\r\n  colliding with any local variables that would be defined by any other code.\r\n  - Examples:\r\n    - `vcpkg_cmake_configure`'s `Z_VCPKG_CMAKE_GENERATOR`\r\n    - `z_vcpkg_get_cmake_vars`'s `Z_VCPKG_GET_CMAKE_VARS_FILE`\r\n- `include()`s are only allowed in `ports.cmake` or `vcpkg-port-config.cmake`.\r\n- `foreach(RANGE)`'s arguments _must always be_ natural numbers,\r\n  and `<start>` _must always be_ less than or equal to `<stop>`.\r\n  - This must be checked by something like:\r\n  ```cmake\r\n  if(\"${start}\" LESS_EQUAL \"${end}\")\r\n    foreach(RANGE \"${start}\" \"${end}\")\r\n      ...\r\n    endforeach()\r\n  endif()\r\n  ```\r\n- All port-based scripts must use `include_guard(GLOBAL)`\r\n  to avoid being included multiple times.\r\n\r\n### CMake Versions to Require\r\n\r\n- All CMake scripts, except for `vcpkg.cmake`,\r\n  may assume the version of CMake that is present in the\r\n  `cmake_minimum_required` of `ports.cmake`.\r\n  - This `cmake_minimum_required` should be bumped every time a new version\r\n    of CMake is added to `vcpkgTools.xml`, as should the\r\n    `cmake_minimum_required` in all of the helper `CMakeLists.txt` files.\r\n- `vcpkg.cmake` must assume a version of CMake back to 3.1 in general\r\n  - Specific functions and options may assume a greater CMake version;\r\n    if they do, make sure to comment that function or option\r\n    with the required CMake version.\r\n\r\n\r\n### Changing Existing Functions\r\n\r\n- Never remove arguments in non-internal functions;\r\n  if they should no longer do anything, just take them as normal and warn on use.\r\n- Never add a new mandatory argument.\r\n\r\n### Naming Variables\r\n\r\n- `cmake_parse_arguments`: set prefix to `\"arg\"`\r\n- Local variables are named with `snake_case`\r\n- Internal global variable names are prefixed with `Z_VCPKG_`.\r\n- External experimental global variable names are prefixed with `X_VCPKG_`.\r\n\r\n- Internal functions are prefixed with `z_vcpkg_`\r\n  - Functions which are internal to a single function (i.e., helper functions)\r\n    are named `[z_]<func>_<name>`, where `<func>` is the name of the function they are\r\n    a helper to, and `<name>` is what the helper function does.\r\n    - `z_` should be added to the front if `<func>` doesn't have a `z_`,\r\n      but don't name a helper function `z_z_foo_bar`.\r\n- Public global variables are named `VCPKG_`.\r\n","Nav":"#"},{"Path":"/en/docs/maintainers/control-files.html","Name":"Control-files","Source":"# CONTROL files\n\n**CONTROL files are retained for backwards compatibility with earlier versions of vcpkg;\nall new features are added only to [vcpkg.json manifest files](manifest-files.md), and we recommend using vcpkg.json for any newly authored port.\nUse `./vcpkg format-manifest ports/<portname>/CONTROL` to convert an existing CONTROL file to a vcpkg.json file.**\n\nThe `CONTROL` file contains metadata about the port.  The syntax is based on [the Debian `control` format][debian] although we only support the subset of fields documented here.\n\nField names are case-sensitive and start the line without leading whitespace.  Paragraphs are separated by one or more empty lines.\n\n[debian]: https://www.debian.org/doc/debian-policy/ch-controlfields.html\n\n## Source Paragraph\n\nThe first paragraph in a `CONTROL` file is the Source paragraph.  It must have a `Source`, `Version`, and `Description` field. The full set of fields is documented below.\n\n### Examples:\n```no-highlight\nSource: ace\nVersion: 6.5.5\nDescription: The ADAPTIVE Communication Environment\n```\n\n```no-highlight\nSource: vtk\nVersion: 8.2.0\nPort-Version: 2\nDescription: Software system for 3D computer graphics, image processing, and visualization\nBuild-Depends: zlib, libpng, tiff, libxml2, jsoncpp, glew, freetype, expat, hdf5, libjpeg-turbo, proj4, lz4, libtheora, atlmfc (windows), eigen3, double-conversion, pugixml, libharu, sqlite3, netcdf-c\n```\n\n\n### Recognized fields\n\n#### Source\nThe name of the port.\n\nWhen adding new ports be aware that the name may conflict with other projects that are not a part of vcpkg.  For example `json` conflicts with too many other projects so you should add a scope to the name such as `taocpp-json` to make it unique.  Verify there are no conflicts on a search engine as well as on other package collections.\n\nPackage collections to check for conflicts:\n\n+ [Repology](https://repology.org/projects/)\n+ [Debian packages](https://www.debian.org/distrib/packages)\n+ [Packages search](https://pkgs.org/)\n\n#### Version\nThe library version.\n\nThis field is an alphanumeric string that may also contain `.`, `_`, or `-`. No attempt at ordering versions is made; all versions are treated as bit strings and are only evaluated for equality.\n\nFor tagged-release ports, we follow the following convention:\n\n1. If the port follows a scheme like `va.b.c`, we remove the leading `v`. In this case, it becomes `a.b.c`.\n2. If the port includes its own name in the version like `curl-7_65_1`, we remove the leading name: `7_65_1`\n\nFor rolling-release ports, we use the date that the _commit was accessed by you_, formatted as `YYYY-MM-DD`. Stated another way: if someone had a time machine and went to that date, they would see this commit as the latest master.\n\nFor example, given:\n1. The latest commit was made on 2019-04-19\n2. The current version string is `2019-02-14-1`\n3. Today's date is 2019-06-01.\n\nThen if you update the source version today, you should give it version `2019-06-01`.\n\n#### Port-Version\nThe version of the port.\n\nThis field is a non-negative integer. It allows one to version the port file separately from the version of the underlying library; if you make a change to a port, without changing the underlying version of the library, you should increment this field by one (starting at `0`, which is equivalent to no `Port-Version` field). When the version of the underlying library is upgraded, this field should be set back to `0` (i.e., delete the `Port-Version` field).\n\n##### Examples:\n```no-highlight\nVersion: 1.0.5\nPort-Version: 2\n```\n```no-highlight\nVersion: 2019-03-21\n```\n\n#### Description\nA description of the library.\n\nBy convention the first line of the description is a summary of the library.  An optional detailed description follows.  The detailed description can be multiple lines, all starting with whitespace.\n\n##### Examples:\n```no-highlight\nDescription: C++ header-only JSON library\n```\n```no-highlight\nDescription: Mosquitto is an open source message broker that implements the MQ Telemetry Transport protocol versions 3.1 and 3.1.1.\n  MQTT provides a lightweight method of carrying out messaging using a publish/subscribe model. This makes it suitable for \"machine\n  to machine\" messaging such as with low power sensors or mobile devices such as phones, embedded computers or microcontrollers like the Arduino.\n```\n\n#### Homepage\nThe URL of the homepage for the library where a user is able to find additional documentation or the original source code.\n\nExample:\n```no-highlight\nHomepage: https://github.com/Microsoft/vcpkg\n```\n\n#### Build-Depends\nComma separated list of vcpkg ports the library has a dependency on.\n\nVcpkg does not distinguish between build-only dependencies and runtime dependencies. The complete list of dependencies needed to successfully use the library should be specified.\n\n*For example: websocketpp is a header only library, and thus does not require any dependencies at install time. However, downstream users need boost and openssl to make use of the library. Therefore, websocketpp lists boost and openssl as dependencies*\n\nIf the port is dependent on optional features of another library those can be specified using the `portname[featurelist]` syntax. If the port does not require any features from the dependency, this should be specified as `portname[core]`.\n\nDependencies can be filtered based on the target triplet to support differing requirements. These filters use the same syntax as the Supports field below and are surrounded in parentheses following the portname and feature list.\n\n##### Example:\n```no-highlight\nBuild-Depends: rapidjson, curl[core,openssl] (!windows), curl[core,winssl] (windows)\n```\n\n#### Default-Features\nComma separated list of optional port features to install by default.\n\nThis field is optional.\n\n##### Example:\n```no-highlight\nDefault-Features: dynamodb, s3, kinesis\n```\n\n<a name=\"Supports\"></a>\n#### Supports\nExpression that evaluates to true when the port is expected to build successfully for a triplet.\n\nCurrently, this field is only used in the CI testing to skip ports. In the future, this mechanism is intended to warn users in advance that a given install tree is not expected to succeed. Therefore, this field should be used optimistically; in cases where a port is expected to succeed 10% of the time, it should still be marked \"supported\".\n\nThe grammar for the supports expression uses standard operators:\n- `!expr` - negation\n- `expr|expr` - or (`||` is also supported)\n- `expr&expr` - and (`&&` is also supported)\n- `(expr)` - grouping/precedence\n\nThe predefined expressions are computed from standard triplet settings:\n- `native` - `TARGET_TRIPLET` == `HOST_TRIPLET`\n- `x64` - `VCPKG_TARGET_ARCHITECTURE` == `\"x64\"`\n- `x86` - `VCPKG_TARGET_ARCHITECTURE` == `\"x86\"`\n- `arm` - `VCPKG_TARGET_ARCHITECTURE` == `\"arm\"` or `VCPKG_TARGET_ARCHITECTURE` == `\"arm64\"`\n- `arm64` - `VCPKG_TARGET_ARCHITECTURE` == `\"arm64\"`\n- `windows` - `VCPKG_CMAKE_SYSTEM_NAME` == `\"\"` or `VCPKG_CMAKE_SYSTEM_NAME` == `\"WindowsStore\"`\n- `uwp` - `VCPKG_CMAKE_SYSTEM_NAME` == `\"WindowsStore\"`\n- `linux` - `VCPKG_CMAKE_SYSTEM_NAME` == `\"Linux\"`\n- `osx` - `VCPKG_CMAKE_SYSTEM_NAME` == `\"Darwin\"`\n- `android` - `VCPKG_CMAKE_SYSTEM_NAME` == `\"Android\"`\n- `static` - `VCPKG_LIBRARY_LINKAGE` == `\"static\"`\n- `wasm32` - `VCPKG_TARGET_ARCHITECTURE` == `\"wasm32\"`\n- `emscripten` - `VCPKG_CMAKE_SYSTEM_NAME` == `\"Emscripten\"`\n\nThese predefined expressions can be overridden in the triplet file via the [`VCPKG_DEP_INFO_OVERRIDE_VARS`](../users/triplets.md) option.\n\nThis field is optional and defaults to true.\n\n> Implementers' Note: these terms are computed from the triplet via the `vcpkg_get_dep_info` mechanism.\n\n##### Example:\n```no-highlight\nSupports: !(uwp|arm)\n```\n\n## Feature Paragraphs\n\nMultiple optional features can be specified in the `CONTROL` files.  It must have a `Feature` and `Description` field.  It can optionally have a `Build-Depends` field.  It must be separated from other paragraphs by one or more empty lines.\n\n### Example:\n```no-highlight\nSource: vtk\nVersion: 8.2.0-2\nDescription: Software system for 3D computer graphics, image processing, and visualization\nBuild-Depends: zlib, libpng, tiff, libxml2, jsoncpp, glew, freetype, expat, hdf5, libjpeg-turbo, proj4, lz4, libtheora, atlmfc (windows), eigen3, double-conversion, pugixml, libharu, sqlite3, netcdf-c\n\nFeature: openvr\nDescription: OpenVR functionality for VTK\nBuild-Depends: sdl2, openvr\n\nFeature: qt\nDescription: Qt functionality for VTK\nBuild-Depends: qt5\n\nFeature: mpi\nDescription: MPI functionality for VTK\nBuild-Depends: mpi, hdf5[parallel]\n\nFeature: python\nDescription: Python functionality for VTK\nBuild-Depends: python3\n```\n\n### Recognized fields\n\n#### Feature\nThe name of the feature.\n\n#### Description\nA description of the feature using the same syntax as the port  `Description` field.\n\n#### Build-Depends\nThe list of dependencies required to build and use this feature.\n\nOn installation the dependencies from all selected features are combined to produce the full dependency list for the build. This field follows the same syntax as `Build-Depends` in the Source Paragraph.\n","Nav":"#"},{"Path":"/en/docs/maintainers/execute_process.html","Name":"Execute_process","Source":"# execute_process\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/execute_process.md).\n\nIntercepts all calls to execute_process() inside portfiles and fails when Download Mode\nis enabled.\n\nIn order to execute a process in Download Mode call `vcpkg_execute_in_download_mode()` instead.\n\n## Source\n[scripts/cmake/execute\\_process.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/execute_process.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/internal/z_vcpkg_apply_patches.html","Name":"Z_vcpkg_apply_patches","Source":"# z_vcpkg_apply_patches\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/).\n\n**Only for internal use in vcpkg helpers. Behavior and arguments will change without notice.**\n\nApply a set of patches to a source tree.\n\n```cmake\nz_vcpkg_apply_patches(\n    SOURCE_PATH <path-to-source>\n    [QUIET]\n    PATCHES <patch>...\n)\n```\n\nThe `<path-to-source>` should be set to `${SOURCE_PATH}` by convention,\nand is the path to apply the patches in.\n\n`z_vcpkg_apply_patches` will take the list of `<patch>`es,\nwhich are by default relative to the port directory,\nand apply them in order using `git apply`.\nGenerally, these `<patch>`es take the form of `some.patch`\nto select patches in the port directory.\nOne may also download patches and use `${VCPKG_DOWNLOADS}/path/to/some.patch`.\n\nIf `QUIET` is not passed, it is a fatal error for a patch to fail to apply;\notherwise, if `QUIET` is passed, no message is printed.\nThis should only be used for edge cases, such as patches that are known to fail even on a clean source tree.\n\n## Source\n[scripts/cmake/z\\_vcpkg\\_apply\\_patches.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/z_vcpkg_apply_patches.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/internal/z_vcpkg_forward_output_variable.html","Name":"Z_vcpkg_forward_output_variable","Source":"# z_vcpkg_forward_output_variable\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/).\n\nThis macro helps with forwarding values from inner function calls,\nthrough a local function scope, into pointer out parameters.\n\n```cmake\nz_vcpkg_forward_output_variable(ptr_to_parent_var var_to_forward)\n```\n\nis equivalent to\n\n```cmake\nif(DEFINED ptr_to_parent_var)\n    if(DEFINED value_var)\n        set(\"${ptr_to_parent_var}\" \"${value_var}\" PARENT_SCOPE)\n    else()\n        unset(\"${ptr_to_parent_var}\" PARENT_SCOPE)\n    endif()\nendif()\n```\n\nTake note that the first argument should be a local variable that has a value of the parent variable name.\nMost commonly, this local is the result of a pointer-out parameter to a function.\nIf the variable in the first parameter is not defined, this function does nothing,\nsimplifying functions with optional out parameters.\nMost commonly, this should be used in cases like:\n\n```cmake\nfunction(my_function out_var)\n    file(SHA512 \"somefile.txt\" local_var)\n    z_vcpkg_forward_output_variable(out_var local_var)\nendfunction()\n```\n\n## Source\n[scripts/cmake/z\\_vcpkg\\_forward\\_output\\_variable.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/z_vcpkg_forward_output_variable.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/internal/z_vcpkg_function_arguments.html","Name":"Z_vcpkg_function_arguments","Source":"# z_vcpkg_function_arguments\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/).\n\n**Only for internal use in vcpkg helpers. Behavior and arguments will change without notice.**\nGet a list of the arguments which were passed in.\nUnlike `ARGV`, which is simply the arguments joined with `;`,\nso that `(A B)` is not distinguishable from `(\"A;B\")`,\nthis macro gives `\"A;B\"` for the first argument list,\nand `\"A\\;B\"` for the second.\n\n```cmake\nz_vcpkg_function_arguments(<out-var> [<N>])\n```\n\n`z_vcpkg_function_arguments` gets the arguments between `ARGV<N>` and the last argument.\n`<N>` defaults to `0`, so that all arguments are taken.\n\n## Example:\n```cmake\nfunction(foo_replacement)\n    z_vcpkg_function_arguments(ARGS)\n    foo(${ARGS})\n    ...\nendfunction()\n```\n\n## Source\n[scripts/cmake/z\\_vcpkg\\_function\\_arguments.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/z_vcpkg_function_arguments.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/internal/z_vcpkg_get_cmake_vars.html","Name":"Z_vcpkg_get_cmake_vars","Source":"# z_vcpkg_get_cmake_vars\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/).\n\n**Only for internal use in vcpkg helpers. Behavior and arguments will change without notice.**\nRuns a cmake configure with a dummy project to extract certain cmake variables\n\n## Usage\n```cmake\nz_vcpkg_get_cmake_vars(<out-var>)\n```\n\n`z_vcpkg_get_cmake_vars(cmake_vars_file)` sets `<out-var>` to\na path to a generated CMake file, with the detected `CMAKE_*` variables\nre-exported as `VCPKG_DETECTED_*`.\n\n## Notes\nAvoid usage in portfiles. \n\nAll calls to `z_vcpkg_get_cmake_vars` will result in the same output file;\nthe output file is not generated multiple times.\n\n## Examples\n\n* [vcpkg_configure_make](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_configure_make.cmake)\n\n### Basic Usage\n\n```cmake\nz_vcpkg_get_cmake_vars(cmake_vars_file)\ninclude(\"${cmake_vars_file}\")\nmessage(STATUS \"detected CXX flags: ${VCPKG_DETECTED_CXX_FLAGS}\")\n```\n\n## Source\n[scripts/cmake/z\\_vcpkg\\_get\\_cmake\\_vars.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/z_vcpkg_get_cmake_vars.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/internal/z_vcpkg_prettify_command_line.html","Name":"Z_vcpkg_prettify_command_line","Source":"# z_vcpkg_prettify_command_line\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/).\n\n**Only for internal use in vcpkg helpers. Behavior and arguments will change without notice.**\nTurn a command line into a formatted string.\n\n```cmake\nz_vcpkg_prettify_command_line(<out-var> <argument>...)\n```\n\nThis command is for internal use, when printing out to a message.\n\n## Examples\n\n* `scripts/cmake/vcpkg_execute_build_process.cmake`\n* `scripts/cmake/vcpkg_execute_required_process.cmake`\n* `scripts/cmake/vcpkg_execute_required_process_repeat.cmake`\n\n## Source\n[scripts/cmake/z\\_vcpkg\\_prettify\\_command\\_line.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/z_vcpkg_prettify_command_line.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/maintainer-guide.html","Name":"Maintainer-guide","Source":"# Maintainer Guidelines and Policies\r\n\r\nThis document lists a set of policies that you should apply when adding or updating a port recipe.\r\nIt is intended to serve the role of\r\n[Debian's Policy Manual](https://www.debian.org/doc/debian-policy/),\r\n[Homebrew's Maintainer Guidelines](https://docs.brew.sh/Maintainer-Guidelines), and\r\n[Homebrew's Formula Cookbook](https://docs.brew.sh/Formula-Cookbook).\r\n\r\n## PR Structure\r\n\r\n### Make separate Pull Requests per port\r\n\r\nWhenever possible, separate changes into multiple PRs.\r\nThis makes them significantly easier to review and prevents issues with one set of changes from holding up every other change.\r\n\r\n### Avoid trivial changes in untouched files\r\n\r\nFor example, avoid reformatting or renaming variables in portfiles that otherwise have no reason to be modified for the issue at hand.\r\nHowever, if you need to modify the file for the primary purpose of the PR (updating the library),\r\nthen obviously beneficial changes like fixing typos are appreciated!\r\n\r\n### Check names against other repositories\r\n\r\nA good service to check many at once is [Repology](https://repology.org/).\r\nIf the library you are adding could be confused with another one,\r\nconsider renaming to make it clear.\r\n\r\n### Use GitHub Draft PRs\r\n\r\nGitHub Draft PRs are a great way to get CI or human feedback on work that isn't yet ready to merge.\r\nMost new PRs should be opened as drafts and converted to normal PRs once the CI passes.\r\n\r\nMore information about GitHub Draft PRs:\r\nhttps://github.blog/2019-02-14-introducing-draft-pull-requests/\r\n\r\n## Portfiles\r\n\r\n### Avoid deprecated helper functions\r\n\r\nAt this time, the following helpers are deprecated:\r\n\r\n1. `vcpkg_extract_source_archive()` should be replaced by [`vcpkg_extract_source_archive_ex()`](vcpkg_extract_source_archive_ex.md)\r\n2. `vcpkg_apply_patches()` should be replaced by the `PATCHES` arguments to the \"extract\" helpers (e.g. [`vcpkg_from_github()`](vcpkg_from_github.md))\r\n3. `vcpkg_build_msbuild()` should be replaced by [`vcpkg_install_msbuild()`](vcpkg_install_msbuild.md)\r\n4. `vcpkg_copy_tool_dependencies()` should be replaced by [`vcpkg_copy_tools()`](vcpkg_copy_tools.md)\r\n\r\n### Avoid excessive comments in portfiles\r\n\r\nIdeally, portfiles should be short, simple, and as declarative as possible.\r\nRemove any boiler plate comments introduced by the `create` command before submitting a PR.\r\n\r\n## Features\r\n\r\n### Do not use features to implement alternatives\r\n\r\nFeatures must be treated as additive functionality. If port[featureA] installs and port[featureB] installs, then port[featureA,featureB] must install. Moreover, if a second port depends on [featureA] and a third port depends on [featureB], installing both the second and third ports should have their dependencies satisfied.\r\n\r\nLibraries in this situation must choose one of the available options as expressed in vcpkg, and users who want a different setting must use overlay ports at this time.\r\n\r\nExisting examples we would not accept today retained for backwards compatibility:\r\n  * `libgit2`, `libzip`, `open62541` all have features for selecting a TLS or crypto backend. Note that `curl` has different crypto backend options but allows selecting between them at runtime, meaning the above tenet is maintained.\r\n  * `darknet` has `opencv2`, `opencv3`, features to control which version of opencv to use for its dependencies.\r\n\r\n### A feature may engage preview or beta functionality\r\n\r\nNotwithstanding the above, if there is a preview branch or similar where the preview functionality has a high probability of not disrupting the non-preview functionality (for example, no API removals), a feature is acceptable to model this setting.\r\n\r\nExamples:\r\n  * The Azure SDKs (of the form `azure-Xxx`) have a `public-preview` feature.\r\n  * `imgui` has an `experimental-docking` feature which engages their preview docking branch which uses a merge commit attached to each of their public numbered releases.\r\n\r\n### Default features should enable behaviors, not APIs\r\n\r\nIf a consumer is depending directly upon a library, they can list out any desired features easily (`library[feature1,feature2]`). However, if a consumer _does not know_ they are using a library, they cannot list out those features. If that hidden library is like `libarchive` where features are adding additional compression algorithms (and thus behaviors) to an existing generic interface, default features offer a way to ensure a reasonably functional transitive library is built even if the final consumer doesn't name it directly.\r\n\r\nIf the feature adds additional APIs (or executables, or library binaries) and doesn't modify the behavior of existing APIs, it should be left off by default. This is because any consumer which might want to use those APIs can easily require it via their direct reference.\r\n\r\nIf in doubt, do not mark a feature as default.\r\n\r\n### Do not use features to control alternatives in published interfaces\r\n\r\nIf a consumer of a port depends on only the core functionality of that port, with high probability they must not be broken by turning on the feature. This is even more important when the alternative is not directly controlled by the consumer, but by compiler settings like `/std:c++17` / `-std=c++17`.\r\n\r\nExisting examples we would not accept today retained for backwards compatibility:\r\n  * `redis-plus-plus[cxx17]` controls a polyfill but does not bake the setting into the installed tree.\r\n  * `ace[wchar]` changes all APIs to accept `const wchar_t*` rather than `const char*`.\r\n\r\n### A feature may replace polyfills with aliases provided that replacement is baked into the installed tree\r\n\r\nNotwithstanding the above, ports may remove polyfills with a feature, as long as:\r\n  1. Turning on the feature changes the polyfills to aliases of the polyfilled entity\r\n  2. The state of the polyfill is baked into the installed headers, such that ABI mismatch \"impossible\" runtime errors are unlikely\r\n  3. It is possible for a consumer of the port to write code which works in both modes, for example by using a typedef which is either polyfilled or not\r\n\r\nExample:\r\n  * `abseil[cxx17]` changes `absl::string_view` to a replacement or `std::string_view`; the patch\r\nhttps://github.com/microsoft/vcpkg/blob/981e65ce0ac1f6c86e5a5ded7824db8780173c76/ports/abseil/fix-cxx-standard.patch implements the baking requirement\r\n\r\n### Recommended solutions\r\n\r\nIf it's critical to expose the underlying alternatives, we recommend providing messages at build time to instruct the user on how to copy the port into a private overlay:\r\n```cmake\r\nset(USING_DOG 0)\r\nmessage(STATUS \"This version of LibContosoFrobnicate uses the Kittens backend. To use the Dog backend instead, create an overlay port of this with USING_DOG set to 1 and the `kittens` dependency replaced with `dog`.\")\r\nmessage(STATUS \"This recipe is at ${CMAKE_CURRENT_LIST_DIR}\")\r\nmessage(STATUS \"See the overlay ports documentation at https://github.com/microsoft/vcpkg/blob/master/docs/specifications/ports-overlay.md\")\r\n```\r\n\r\n## Build Techniques\r\n\r\n### Do not use vendored dependencies\r\n\r\nDo not use embedded copies of libraries.\r\nAll dependencies should be split out and packaged separately so they can be updated and maintained.\r\n\r\n### Prefer using CMake\r\n\r\nWhen multiple buildsystems are available, prefer using CMake.\r\nAdditionally, when appropriate, it can be easier and more maintainable to rewrite alternative buildsystems into CMake using `file(GLOB)` directives.\r\n\r\nExamples: [abseil](../../ports/abseil/portfile.cmake)\r\n\r\n### Choose either static or shared binaries\r\n\r\nBy default, `vcpkg_configure_cmake()` will pass in the appropriate setting for `BUILD_SHARED_LIBS`,\r\nhowever for libraries that don't respect that variable, you can switch on `VCPKG_LIBRARY_LINKAGE`:\r\n\r\n```cmake\r\nstring(COMPARE EQUAL \"${VCPKG_LIBRARY_LINKAGE}\" \"static\" KEYSTONE_BUILD_STATIC)\r\nstring(COMPARE EQUAL \"${VCPKG_LIBRARY_LINKAGE}\" \"dynamic\" KEYSTONE_BUILD_SHARED)\r\n\r\nvcpkg_configure_cmake(\r\n    SOURCE_PATH ${SOURCE_PATH}\r\n    PREFER_NINJA\r\n    OPTIONS\r\n        -DKEYSTONE_BUILD_STATIC=${KEYSTONE_BUILD_STATIC}\r\n        -DKEYSTONE_BUILD_SHARED=${KEYSTONE_BUILD_SHARED}\r\n)\r\n```\r\n\r\n### When defining features, explicitly control dependencies\r\n\r\nWhen defining a feature that captures an optional dependency,\r\nensure that the dependency will not be used accidentally when the feature is not explicitly enabled.\r\n\r\n```cmake\r\nif (\"zlib\" IN_LIST FEATURES)\r\n  set(CMAKE_DISABLE_FIND_PACKAGE_ZLIB OFF)\r\nelse()\r\n  set(CMAKE_DISABLE_FIND_PACKAGE_ZLIB ON)\r\nendif()\r\n\r\nvcpkg_configure_cmake(\r\n  SOURCE_PATH ${SOURCE_PATH}\r\n  PREFER_NINJA\r\n  OPTIONS\r\n    -CMAKE_DISABLE_FIND_PACKAGE_ZLIB=${CMAKE_DISABLE_FIND_PACKAGE_ZLIB}\r\n)\r\n```\r\n\r\nThe snippet below using `vcpkg_check_features()` is equivalent,  [see the documentation](vcpkg_check_features.md).\r\n\r\n```cmake\r\nvcpkg_check_features(OUT_FEATURE_OPTIONS FEATURE_OPTIONS\r\n  INVERTED_FEATURES\r\n    \"zlib\"    CMAKE_DISABLE_FIND_PACKAGE_ZLIB\r\n)\r\n\r\nvcpkg_configure_cmake(\r\n    SOURCE_PATH ${SOURCE_PATH}\r\n    PREFER_NINJA\r\n    OPTIONS\r\n      ${FEATURE_OPTIONS}\r\n)\r\n```\r\n\r\nNote that `ZLIB` in the above is case-sensitive. See the [cmake documentation](https://cmake.org/cmake/help/v3.15/variable/CMAKE_DISABLE_FIND_PACKAGE_PackageName.html) for more details.\r\n\r\n### Place conflicting libs in a `manual-link` directory\r\n\r\nA lib is considered conflicting if it does any of the following:\r\n+ Define `main`\r\n+ Define malloc\r\n+ Define symbols that are also declared in other libraries\r\n\r\nConflicting libs are typically by design and not considered a defect.  Because some build systems link against everything in the lib directory, these should be moved into a subdirectory named `manual-link`.\r\n\r\n## Manifests and CONTROL files\r\n\r\nWhen adding a new port, use the new manifest syntax for defining a port;\r\nyou may also change over to manifests when modifying an existing port.\r\nYou may do so easily by running the `vcpkg format-manifest` command, which will convert existing CONTROL\r\nfiles into manifest files. Do not convert CONTROL files that have not been modified.\r\n\r\n## Versioning\r\n\r\n### Follow common conventions for the `\"version\"` field\r\n\r\nSee our [versioning documentation](../users/versioning.md#version-schemes) for a full explanation of our conventions.\r\n\r\n### Update the `\"port-version\"` field in the manifest file of any modified ports\r\n\r\nVcpkg uses this field to determine whether a given port is out-of-date and should be changed whenever the port's behavior changes.\r\n\r\nOur convention is to use the `\"port-version\"` field for changes to the port that don't change the upstream version, and to reset the `\"port-version\"` back to zero when an update to the upstream version is made.\r\n\r\nFor Example:\r\n\r\n- Zlib's package version is currently `1.2.1`, with no explicit `\"port-version\"` (equivalent to a `\"port-version\"` of `0`).\r\n- You've discovered that the wrong copyright file has been deployed, and fixed that in the portfile.\r\n- You should update the `\"port-version\"` field in the manifest file to `1`.\r\n\r\nSee our [manifest files document](manifest-files.md#port-version) for a full explanation of our conventions.\r\n\r\n### Update the version files in `versions/` of any modified ports\r\n\r\nVcpkg uses a set of metadata files to power its versioning feature.\r\nThese files are located in the following locations:\r\n* `${VCPKG_ROOT}/versions/baseline.json`, (this file is common to all ports) and\r\n* `${VCPKG_ROOT}/versions/${first-letter-of-portname}-/${portname}.json` (one per port).\r\n\r\nFor example, for `zlib` the relevant files are:\r\n* `${VCPKG_ROOT}/versions/baseline.json`\r\n* `${VCPKG_ROOT}/versions/z-/zlib.json`\r\n\r\nWe expect that each time you update a port, you also update its version files.\r\n\r\n**The recommended method to update these files is to run the `x-add-version` command, e.g.:**\r\n\r\n```\r\nvcpkg x-add-version zlib\r\n```\r\n\r\nIf you're updating multiple ports at the same time, instead you can run:\r\n\r\n```\r\nvcpkg x-add-version --all\r\n```\r\n\r\nTo update the files for all modified ports at once.\r\n\r\n_NOTE: These commands require you to have committed your changes to the ports before running them. The reason is that the Git SHA of the port directory is required in these version files. But don't worry, the `x-add-version` command will warn you if you have local changes that haven't been committed._\r\n\r\nSee our [versioning specification](../specifications/versioning.md) and [registries specification](../specifications/registries-2.md) to learn how vcpkg interacts with these files.\r\n\r\n## Patching\r\n\r\n### Prefer options over patching\r\n\r\nIt is preferable to set options in a call to `vcpkg_configure_xyz()` over patching the settings directly.\r\n\r\nCommon options that allow avoiding patching:\r\n1. [MSBUILD] `<PropertyGroup>` settings inside the project file can be overridden via `/p:` parameters\r\n2. [CMAKE] Calls to `find_package(XYz)` in CMake scripts can be disabled via [`-DCMAKE_DISABLE_FIND_PACKAGE_XYz=ON`](https://cmake.org/cmake/help/v3.15/variable/CMAKE_DISABLE_FIND_PACKAGE_PackageName.html)\r\n3. [CMAKE] Cache variables (declared as `set(VAR \"value\" CACHE STRING \"Documentation\")` or `option(VAR \"Documentation\" \"Default Value\")`) can be overridden by just passing them in on the command line as `-DVAR:STRING=Foo`. One notable exception is if the `FORCE` parameter is passed to `set()`. See also the [CMake `set` documentation](https://cmake.org/cmake/help/v3.15/command/set.html)\r\n\r\n### Prefer patching over overriding `VCPKG_<VARIABLE>` values\r\n\r\nSome variables prefixed with `VCPKG_<VARIABLE>` have an equivalent `CMAKE_<VARIABLE>`.\r\nHowever, not all of them are passed to the internal package build [(see implementation: Windows toolchain)](../../scripts/toolchains/windows.cmake).\r\n\r\nConsider the following example:\r\n\r\n```cmake\r\nset(VCPKG_C_FLAGS \"-O2 ${VCPKG_C_FLAGS}\")\r\nset(VCPKG_CXX_FLAGS \"-O2 ${VCPKG_CXX_FLAGS}\")\r\n```\r\n\r\nUsing `vcpkg`'s built-in toolchains this works, because the value of `VCPKG_<LANG>_FLAGS` is forwarded to the appropriate `CMAKE_LANG_FLAGS` variable. But, a custom toolchain that is not aware of `vcpkg`'s variables will not forward them.\r\n\r\nBecause of this, it is preferable to patch the buildsystem directly when setting `CMAKE_<LANG>_FLAGS`.\r\n\r\n### Minimize patches\r\n\r\nWhen making changes to a library, strive to minimize the final diff. This means you should _not_ reformat the upstream source code when making changes that affect a region. Also, when disabling a conditional, it is better to add a `AND FALSE` or `&& 0` to the condition than to delete every line of the conditional.\r\n\r\nThis helps to keep the size of the vcpkg repository down as well as improves the likelihood that the patch will apply to future code versions.\r\n\r\n### Do not implement features in patches\r\n\r\nThe purpose of patching in vcpkg is to enable compatibility with compilers, libraries, and platforms. It is not to implement new features in lieu of following proper Open Source procedure (submitting an Issue/PR/etc).\r\n\r\n## Do not build tests/docs/examples by default\r\n\r\nWhen submitting a new port, check for any options like `BUILD_TESTS` or `WITH_TESTS` or `POCO_ENABLE_SAMPLES` and ensure the additional binaries are disabled. This minimizes build times and dependencies for the average user.\r\n\r\nOptionally, you can add a `test` feature which enables building the tests, however this should not be in the `Default-Features` list.\r\n\r\n## Enable existing users of the library to switch to vcpkg\r\n\r\n### Do not add `CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS`\r\n\r\nUnless the author of the library is already using it, we should not use this CMake functionality because it interacts poorly with C++ templates and breaks certain compiler features. Libraries that don't provide a .def file and do not use __declspec() declarations simply do not support shared builds for Windows and should be marked as such with `vcpkg_check_linkage(ONLY_STATIC_LIBRARY)`.\r\n\r\n### Do not rename binaries outside the names given by upstream\r\n\r\nThis means that if the upstream library has different names in release and debug (libx versus libxd), then the debug library should not be renamed to `libx`. Vice versa, if the upstream library has the same name in release and debug, we should not introduce a new name.\r\n\r\nImportant caveat:\r\n- Static and shared variants often should be renamed to a common scheme. This enables consumers to use a common name and be ignorant of the downstream linkage. This is safe because we only make one at a time available.\r\n\r\nNote that if a library generates CMake integration files (`foo-config.cmake`), renaming must be done through patching the CMake build itself instead of simply calling `file(RENAME)` on the output archives/LIBs.\r\n\r\nFinally, DLL files on Windows should never be renamed post-build because it breaks the generated LIBs.\r\n\r\n## Code format\r\n\r\n### Vcpkg internal code\r\n\r\nWe require the C++ code inside vcpkg to follow the clang-format, if you change them. Please perform the following steps after modification:\r\n\r\n- Use Visual Studio:\r\n1. Configure your [clang-format tools](https://devblogs.microsoft.com/cppblog/clangformat-support-in-visual-studio-2017-15-7-preview-1/).\r\n2. Open the modified file.\r\n3. Use shortcut keys Ctrl+K, Ctrl+D to format the current file.\r\n\r\n- Use tools:\r\n1. Install [llvm clang-format](https://releases.llvm.org/download.html#10.0.0)\r\n2. Run command:\r\n```cmd\r\n> LLVM_PATH/bin/clang-format.exe -style=file -i changed_file.cpp\r\n```\r\n\r\n### Manifests\r\n\r\nWe require that the manifest file be formatted. Use the following command to format all manifest files:\r\n\r\n```cmd\r\n> vcpkg format-manifest --all\r\n```\r\n\r\n## Useful implementation notes\r\n\r\n### Portfiles are run in Script Mode\r\n\r\nWhile `portfile.cmake`'s and `CMakeLists.txt`'s share a common syntax and core CMake language constructs, portfiles run in \"Script Mode\", whereas `CMakeLists.txt` files run in \"Build Mode\" (unofficial term). The most important difference between these two modes is that \"Script Mode\" does not have a concept of \"Target\" -- any behaviors that depend on the \"target\" machine (`CMAKE_CXX_COMPILER`, `CMAKE_EXECUTABLE_SUFFIX`, `CMAKE_SYSTEM_NAME`, etc) will not be correct.\r\n\r\nPortfiles have direct access to variables set in the triplet file, but `CMakeLists.txt`s do not (though there is often a translation that happens -- `VCPKG_LIBRARY_LINKAGE` versus `BUILD_SHARED_LIBS`).\r\n\r\nPortfiles and CMake builds invoked by portfiles are run in different processes. Conceptually:\r\n\r\n```no-highlight\r\n+----------------------------+       +------------------------------------+\r\n| CMake.exe                  |       | CMake.exe                          |\r\n+----------------------------+       +------------------------------------+\r\n| Triplet file               | ====> | Toolchain file                     |\r\n| (x64-windows.cmake)        |       | (scripts/buildsystems/vcpkg.cmake) |\r\n+----------------------------+       +------------------------------------+\r\n| Portfile                   | ====> | CMakeLists.txt                     |\r\n| (ports/foo/portfile.cmake) |       | (buildtrees/../CMakeLists.txt)     |\r\n+----------------------------+       +------------------------------------+\r\n```\r\n\r\nTo determine the host in a portfile, the standard CMake variables are fine (`CMAKE_HOST_WIN32`).\r\n\r\nTo determine the target in a portfile, the vcpkg triplet variables should be used (`VCPKG_CMAKE_SYSTEM_NAME`).\r\n\r\nSee also our [triplet documentation](../users/triplets.md) for a full enumeration of possible settings.\r\n","Nav":"#"},{"Path":"/en/docs/maintainers/manifest-files.html","Name":"Manifest-files","Source":"# Manifest files - `vcpkg.json`\n\nThe `vcpkg.json` file contains metadata about the port.\nIt's a JSON file, and replaces the existing CONTROL file metadata structure.\nIt must have a top level object, and all fields are case sensitive.\n\n## Examples:\n\nThe most important fields in a manifest, the ones which are required for all ports,\nare the `\"name\"` field, and a version field (for now, just `\"version-string\"`).\nThere's more information about these fields below.\n\n```json\n{\n  \"name\": \"ace\",\n  \"version-string\": \"6.5.5\"\n}\n```\n\n```json\n{\n  \"name\": \"vtk\",\n  \"version-string\": \"8.2.0\",\n  \"port-version\": 2,\n  \"description\": \"Software system for 3D computer graphics, image processing, and visualization\",\n  \"dependencies\": [\n    {\n      \"name\": \"atlmfc\",\n      \"platform\": \"windows\"\n    },\n    \"double-conversion\",\n    \"eigen3\",\n    \"expat\",\n    \"freetype\",\n    \"glew\",\n    \"hdf5\",\n    \"jsoncpp\",\n    \"libharu\",\n    \"libjpeg-turbo\",\n    \"libpng\",\n    \"libtheora\",\n    \"libxml2\",\n    \"lz4\",\n    \"netcdf-c\",\n    \"proj4\",\n    \"pugixml\",\n    \"sqlite3\",\n    \"tiff\",\n    \"zlib\"\n  ]\n}\n```\n\n## Fields\n\n### `\"name\"`\nThe name of the port.\n\nWhen adding new ports be aware that the name may conflict with other projects that are not a part of vcpkg.  For example `json` conflicts with too many other projects so you should add a scope to the name such as `taocpp-json` to make it unique.  Verify there are no conflicts on a search engine as well as on other package collections.\n\nPackage collections to check for conflicts:\n\n+ [Repology](https://repology.org/projects/)\n+ [Debian packages](https://www.debian.org/distrib/packages)\n+ [Packages search](https://pkgs.org/)\n\nA name must be an identifier: i.e., it must only consist of lowercase ascii alphabetic characters,\nnumbers, and hyphens, and it must not begin nor end with a hyphen.\n\n### Version fields\n\nCurrently there are different fields for special versioning. Namely:\n\nManifest property | Versioning scheme\n------------------|------------------------------------\n`version`         | For dot-separated numeric versions\n`version-semver`  | For SemVer compliant versions\n`version-date`    | For dates in the format YYYY-MM-DD\n`version-string`  | For arbitrary strings\n\nSee https://github.com/microsoft/vcpkg/blob/master/docs/specifications/versioning.md#22-package-versions for more details.\n\nAdditionally, `\"port-version\"` is used to differentiate between port changes that don't change the underlying library version.\n\n#### `\"version-string\"`\n\nThis field is an ascii string, and may contain alphanumeric characters, `.`, `_`, or `-`. No attempt at ordering versions is made; all versions are treated as byte strings and are only evaluated for equality.\n\nFor tagged-release ports, we follow the following convention:\n\n1. If the library follows a scheme like `va.b.c`, we remove the leading `v`. In this case, it becomes `a.b.c`.\n2. If the library includes its own name in the version like `curl-7_65_1`, we remove the leading name: `7_65_1`\n3. If the library is versioned by dates, format the resulting version string just like the upstream library;\n   for example, Abseil formats their dates `lts_2020_02_25`, so the `\"version-string\"` should be `\"lts_2020_02_25\"`.\n\nFor rolling-release ports, we use the date that the _commit was accessed by you_, formatted as `YYYY-MM-DD`. Stated another way: if someone had a time machine and went to that date, they would see this commit as the latest master.\n\nFor example, given:\n1. The latest commit was made on 2019-04-19\n2. The current version string is `2019-02-14`\n3. Today's date is 2019-06-01.\n\nThen if you update the source version today, you should give it version `2019-06-01`.\n\n#### `\"port-version\"`\n\nThe version of the port, aside from the library version.\n\nThis field is a non-negative integer.\nIt allows one to version the port file separately from the version of the underlying library;\nif you make a change to a port, without changing the underlying version of the library,\nyou should increment this field by one (starting at `0`, which is equivalent to no `\"port-version\"` field).\nWhen the version of the underlying library is upgraded,\nthis field should be set back to `0` (i.e., delete the `\"port-version\"` field).\n\n#### Examples:\n```json\n{\n  \"version\": \"1.0.5\",\n  \"port-version\": 2\n}\n```\n\n```json\n{\n  \"version\": \"2019-03-21\"\n}\n```\n\n### `\"description\"`\n\nA description of the library.\n\nThis field can either be a single string, which should be a summary of the library,\nor can be an array, with the first line being a summary and the remaining lines being the detailed description -\none string per line.\n\n#### Examples:\n```json\n{\n  \"description\": \"C++ header-only JSON library\"\n}\n```\n```json\n{\n  \"description\": [\n    \"Mosquitto is an open source message broker that implements the MQ Telemetry Transport protocol versions 3.1 and 3.1.1.\",\n    \"MQTT provides a lightweight method of carrying out messaging using a publish/subscribe model.\"\n    \"This makes it suitable for 'machine to machine' messaging such as with low power sensors or mobile devices such as phones, embedded computers or microcontrollers like the Arduino.\"\n  ]\n}\n```\n\n### `\"homepage\"`\n\nThe URL of the homepage for the library where a user is able to find additional documentation or the original source code.\n\n### `\"documentation\"`\n\nThe URL where a user would be able to find official documentation for the library. Optional.\n\n### `\"maintainers\"`\n\nA list of strings that define the set of maintainers of a package.\nIt's recommended that these take the form of `Givenname Surname <email>`,\nbut this field is not checked for consistency.\n\nOptional.\n\n#### Example:\n```json\n{\n  \"homepage\": \"https://github.com/microsoft/vcpkg\"\n}\n```\n\n### `\"dependencies\"`\n\nAn array of ports the library has a dependency on.\n\nvcpkg does not distinguish between build-only dependencies and runtime dependencies.\nThe complete list of dependencies needed to successfully use the library should be specified.\n\nFor example: websocketpp is a header only library, and thus does not require any dependencies at install time.\nHowever, downstream users need boost and openssl to make use of the library.\nTherefore, websocketpp lists boost and openssl as dependencies.\n\nEach dependency may be either an identifier, or an object.\nFor many dependencies, just listing the name of the library should be fine;\nhowever, if one needs to add extra information to that dependency, one may use the dependency object.\nFor a dependency object, the `\"name\"` field is used to designate the library;\nfor example the dependency object `{ \"name\": \"zlib\" }` is equivalent to just writing `\"zlib\"`.\n\nIf the port is dependent on optional features of another library,\nthose can be specified using the `\"features\"` field of the dependency object.\nIf the port does not require any features from the dependency,\nthis should be specified with the `\"default-features\"` fields set to `false`.\n\nDependencies can also be filtered based on the target triplet to support differing requirements.\nThese filters use the same syntax as the `\"supports\"` field below,\nand are specified in the `\"platform\"` field.\n\n#### Example:\n```json\n{\n  \"dependencies\": [\n    {\n      \"name\": \"curl\",\n      \"default-features\": false,\n      \"features\": [\n        \"winssl\"\n      ],\n      \"platform\": \"windows\"\n    },\n    {\n      \"name\": \"curl\",\n      \"default-features\": false,\n      \"features\": [\n        \"openssl\"\n      ],\n      \"platform\": \"!windows\"\n    },\n    \"rapidjson\"\n  ]\n}\n```\n\n### `\"features\"`\n\nMultiple optional features can be specified in manifest files, in the `\"features\"` object field.\nThis field is a map from the feature name, to the feature's information.\nEach one must have a `\"description\"` field, and may also optionally have a `\"dependencies\"` field.\n\nA feature's name must be an identifier -\nin other words, lowercase alphabetic characters, digits, and hyphens,\nneither starting nor ending with a hyphen.\n\nA feature's `\"description\"` is a description of the feature,\nand is the same kind of thing as the port `\"description\"` field.\n\nA feature's `\"dependencies\"` field contains the list of extra dependencies required to build and use this feature;\nthis field isn't required if the feature doesn't require any extra dependencies.\nOn installation the dependencies from all selected features are combined to produce the full dependency list for the build.\n\n#### Example:\n\n```json\n{\n  \"name\": \"vtk\",\n  \"version-string\": \"8.2.0\",\n  \"port-version\": 2,\n  \"description\": \"Software system for 3D computer graphics, image processing, and visualization\",\n  \"dependencies\": [\n    {\n      \"name\": \"atlmfc\",\n      \"platform\": \"windows\"\n    },\n    \"double-conversion\",\n    \"eigen3\",\n    \"expat\",\n    \"freetype\",\n    \"glew\",\n    \"hdf5\",\n    \"jsoncpp\",\n    \"libharu\",\n    \"libjpeg-turbo\",\n    \"libpng\",\n    \"libtheora\",\n    \"libxml2\",\n    \"lz4\",\n    \"netcdf-c\",\n    \"proj4\",\n    \"pugixml\",\n    \"sqlite3\",\n    \"tiff\",\n    \"zlib\"\n  ],\n  \"features\": {\n    \"mpi\": {\n      \"description\": \"MPI functionality for VTK\",\n      \"dependencies\": [\n        {\n          \"name\": \"hdf5\",\n          \"features\": [\n            \"parallel\"\n          ]\n        },\n        \"mpi\"\n      ]\n    },\n    \"openvr\": {\n      \"description\": \"OpenVR functionality for VTK\",\n      \"dependencies\": [\n        \"openvr\",\n        \"sdl2\"\n      ]\n    },\n    \"python\": {\n      \"description\": \"Python functionality for VTK\",\n      \"dependencies\": [\n        \"python3\"\n      ]\n    },\n    \"qt\": {\n      \"description\": \"Qt functionality for VTK\",\n      \"dependencies\": [\n        \"qt5\"\n      ]\n    }\n  }\n}\n```\n\n### `\"default-features\"`\n\nAn array of feature names that the library uses by default, if nothing else is specified.\n\n#### Example:\n```json\n{\n  \"default-features\": [\n    \"kinesis\"\n  ],\n  \"features\": {\n    \"dynamodb\": {\n      \"description\": \"Build dynamodb support\",\n      \"dependencies\": [\n        \"dynamodb\"\n      ]\n    },\n    \"kinesis\": {\n      \"description\": \"build kinesis support\"\n    }\n  }\n}\n```\n\n### `\"supports\"`\n\nA string, formatted as a platform expression,\nthat evaluates to true when the port should build successfully for a triplet.\n\nThis field is used in the CI testing to skip ports,\nand warns users in advance that a given install tree is not expected to succeed.\nTherefore, this field should be used optimistically;\nin cases where a port is expected to succeed 10% of the time, it should still be marked \"supported\".\n\nThe grammar for this top-level platform expression, in [EBNF], is as follows:\n\n```ebnf\nwhitespace-character =\n| ? U+0009 \"CHARACTER TABULATION\" ?\n| ? U+000A \"LINE FEED\" ?\n| ? U+000D \"CARRIAGE RETURN\" ?\n| ? U+0020 \"SPACE\" ? ;\noptional-whitespace = { whitespace-character } ;\n\nlowercase-alpha =\n| \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"h\" | \"i\" | \"j\" | \"k\" | \"l\" | \"m\"\n| \"n\" | \"o\" | \"p\" | \"q\" | \"r\" | \"s\" | \"t\" | \"u\" | \"v\" | \"w\" | \"x\" | \"y\" | \"z\" ;\ndigit =\n| \"0\" | \"1\" | \"2\" | \"3\" | \"4\"\n| \"5\" | \"6\" | \"7\" | \"8\" | \"9\" ;\nidentifier-character =\n| lowercase-alpha\n| digit ;\n\nplatform-expression =\n| platform-expression-not\n| platform-expression-and\n| platform-expression-or ;\n\nplatform-expression-identifier =\n| identifier-character, { identifier-character }, optional-whitespace ;\n\nplatform-expression-simple =\n| platform-expression-identifier\n| \"(\", optional-whitespace, platform-expression, \")\", optional-whitespace ;\n\nplatform-expression-not =\n| platform-expression-simple\n| \"!\", optional-whitespace, platform-expression-simple ;\n\nplatform-expression-and =\n| platform-expression-not, { \"&\", optional-whitespace, platform-expression-not } ;\n\nplatform-expression-or =\n| platform-expression-not, { \"|\", optional-whitespace, platform-expression-not } ;\n\ntop-level-platform-expression = optional-whitespace, platform-expression ;\n```\n\nBasically, there are four kinds of expressions -- identifiers, negations, ands, and ors.\nNegations may only negate an identifier or a grouped expression.\nAnds and ors are a list of `&` or `|` separated identifiers, negated expressions, and grouped expressions.\nOne may not mix `&` and `|` without parentheses for grouping.\n\nThese predefined identifier expressions are computed from standard triplet settings:\n- `native` - `TARGET_TRIPLET` == `HOST_TRIPLET`;\n  useful for ports which depend on their own built binaries in their build.\n- `x64` - `VCPKG_TARGET_ARCHITECTURE` == `\"x64\"`\n- `x86` - `VCPKG_TARGET_ARCHITECTURE` == `\"x86\"`\n- `arm` - `VCPKG_TARGET_ARCHITECTURE` == `\"arm\"` or `VCPKG_TARGET_ARCHITECTURE` == `\"arm64\"`\n- `arm64` - `VCPKG_TARGET_ARCHITECTURE` == `\"arm64\"`\n- `windows` - `VCPKG_CMAKE_SYSTEM_NAME` == `\"\"` or `VCPKG_CMAKE_SYSTEM_NAME` == `\"WindowsStore\"`\n- `mingw` - `VCPKG_CMAKE_SYSTEM_NAME` == `\"MinGW\"`\n- `uwp` - `VCPKG_CMAKE_SYSTEM_NAME` == `\"WindowsStore\"`\n- `linux` - `VCPKG_CMAKE_SYSTEM_NAME` == `\"Linux\"`\n- `osx` - `VCPKG_CMAKE_SYSTEM_NAME` == `\"Darwin\"`\n- `android` - `VCPKG_CMAKE_SYSTEM_NAME` == `\"Android\"`\n- `static` - `VCPKG_LIBRARY_LINKAGE` == `\"static\"`\n- `wasm32` - `VCPKG_TARGET_ARCHITECTURE` == `\"wasm32\"`\n- `emscripten` - `VCPKG_CMAKE_SYSTEM_NAME` == `\"Emscripten\"`\n\nThese predefined identifier expressions can be overridden in the triplet file,\nvia the [`VCPKG_DEP_INFO_OVERRIDE_VARS`](../users/triplets.md) option,\nand new identifier expressions can be added via the same mechanism.\n\nThis field is optional and defaults to true.\n\n> Implementers' Note: these terms are computed from the triplet via the `vcpkg_get_dep_info` mechanism.\n\n[EBNF]: https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form\n\n#### Example:\n```json\n{\n  \"supports\": \"!uwp & !(arm & !arm64)\"\n}\n```\n\nThis means \"doesn't support uwp, nor arm32 (but does support arm64)\".\n","Nav":"#"},{"Path":"/en/docs/maintainers/portfile-functions.html","Name":"Portfile Helper Functions","Source":"<!-- Run regenerate.ps1 to extract scripts documentation -->\n\n# Portfile helper functions\n- [execute\\_process](execute_process.md)\n- [vcpkg\\_acquire\\_msys](vcpkg_acquire_msys.md)\n- [vcpkg\\_add\\_to\\_path](vcpkg_add_to_path.md)\n- [vcpkg\\_apply\\_patches](vcpkg_apply_patches.md) (deprecated)\n- [vcpkg\\_build\\_cmake](vcpkg_build_cmake.md) (deprecated, use [vcpkg\\_cmake\\_build](ports/vcpkg-cmake/vcpkg_cmake_build.md))\n- [vcpkg\\_build\\_make](vcpkg_build_make.md)\n- [vcpkg\\_build\\_msbuild](vcpkg_build_msbuild.md)\n- [vcpkg\\_build\\_ninja](vcpkg_build_ninja.md)\n- [vcpkg\\_build\\_nmake](vcpkg_build_nmake.md)\n- [vcpkg\\_build\\_qmake](vcpkg_build_qmake.md)\n- [vcpkg\\_buildpath\\_length\\_warning](vcpkg_buildpath_length_warning.md)\n- [vcpkg\\_check\\_features](vcpkg_check_features.md)\n- [vcpkg\\_check\\_linkage](vcpkg_check_linkage.md)\n- [vcpkg\\_clean\\_executables\\_in\\_bin](vcpkg_clean_executables_in_bin.md)\n- [vcpkg\\_clean\\_msbuild](vcpkg_clean_msbuild.md)\n- [vcpkg\\_common\\_definitions](vcpkg_common_definitions.md)\n- [vcpkg\\_configure\\_cmake](vcpkg_configure_cmake.md) (deprecated, use [vcpkg\\_cmake\\_configure](ports/vcpkg-cmake/vcpkg_cmake_configure.md))\n- [vcpkg\\_configure\\_gn](vcpkg_configure_gn.md)\n- [vcpkg\\_configure\\_make](vcpkg_configure_make.md)\n- [vcpkg\\_configure\\_meson](vcpkg_configure_meson.md)\n- [vcpkg\\_configure\\_qmake](vcpkg_configure_qmake.md)\n- [vcpkg\\_copy\\_pdbs](vcpkg_copy_pdbs.md)\n- [vcpkg\\_copy\\_tool\\_dependencies](vcpkg_copy_tool_dependencies.md)\n- [vcpkg\\_copy\\_tools](vcpkg_copy_tools.md)\n- [vcpkg\\_download\\_distfile](vcpkg_download_distfile.md)\n- [vcpkg\\_execute\\_build\\_process](vcpkg_execute_build_process.md)\n- [vcpkg\\_execute\\_in\\_download\\_mode](vcpkg_execute_in_download_mode.md)\n- [vcpkg\\_execute\\_required\\_process](vcpkg_execute_required_process.md)\n- [vcpkg\\_execute\\_required\\_process\\_repeat](vcpkg_execute_required_process_repeat.md)\n- [vcpkg\\_extract\\_source\\_archive](vcpkg_extract_source_archive.md)\n- [vcpkg\\_extract\\_source\\_archive\\_ex](vcpkg_extract_source_archive_ex.md)\n- [vcpkg\\_fail\\_port\\_install](vcpkg_fail_port_install.md)\n- [vcpkg\\_find\\_acquire\\_program](vcpkg_find_acquire_program.md)\n- [vcpkg\\_find\\_fortran](vcpkg_find_fortran.md)\n- [vcpkg\\_fixup\\_cmake\\_targets](vcpkg_fixup_cmake_targets.md) (deprecated, use [vcpkg\\_cmake\\_config\\_fixup](ports/vcpkg-cmake-config/vcpkg_cmake_config_fixup.md))\n- [vcpkg\\_fixup\\_pkgconfig](vcpkg_fixup_pkgconfig.md)\n- [vcpkg\\_from\\_bitbucket](vcpkg_from_bitbucket.md)\n- [vcpkg\\_from\\_git](vcpkg_from_git.md)\n- [vcpkg\\_from\\_github](vcpkg_from_github.md)\n- [vcpkg\\_from\\_gitlab](vcpkg_from_gitlab.md)\n- [vcpkg\\_from\\_sourceforge](vcpkg_from_sourceforge.md)\n- [vcpkg\\_get\\_program\\_files\\_platform\\_bitness](vcpkg_get_program_files_platform_bitness.md)\n- [vcpkg\\_get\\_windows\\_sdk](vcpkg_get_windows_sdk.md)\n- [vcpkg\\_install\\_cmake](vcpkg_install_cmake.md) (deprecated, use [vcpkg\\_cmake\\_install](ports/vcpkg-cmake/vcpkg_cmake_install.md))\n- [vcpkg\\_install\\_gn](vcpkg_install_gn.md)\n- [vcpkg\\_install\\_make](vcpkg_install_make.md)\n- [vcpkg\\_install\\_meson](vcpkg_install_meson.md)\n- [vcpkg\\_install\\_msbuild](vcpkg_install_msbuild.md)\n- [vcpkg\\_install\\_nmake](vcpkg_install_nmake.md)\n- [vcpkg\\_install\\_qmake](vcpkg_install_qmake.md)\n- [vcpkg\\_list](vcpkg_list.md)\n- [vcpkg\\_minimum\\_required](vcpkg_minimum_required.md)\n- [vcpkg\\_replace\\_string](vcpkg_replace_string.md)\n\n## Internal Functions\n\n- [z\\_vcpkg\\_apply\\_patches](internal/z_vcpkg_apply_patches.md)\n- [z\\_vcpkg\\_forward\\_output\\_variable](internal/z_vcpkg_forward_output_variable.md)\n- [z\\_vcpkg\\_function\\_arguments](internal/z_vcpkg_function_arguments.md)\n- [z\\_vcpkg\\_get\\_cmake\\_vars](internal/z_vcpkg_get_cmake_vars.md)\n- [z\\_vcpkg\\_prettify\\_command\\_line](internal/z_vcpkg_prettify_command_line.md)\n\n## Scripts from Ports\n\n### [vcpkg-cmake](ports/vcpkg-cmake.md)\n\n- [vcpkg\\_cmake\\_build](ports/vcpkg-cmake/vcpkg_cmake_build.md)\n- [vcpkg\\_cmake\\_configure](ports/vcpkg-cmake/vcpkg_cmake_configure.md)\n- [vcpkg\\_cmake\\_get\\_vars](ports/vcpkg-cmake/vcpkg_cmake_get_vars.md)\n- [vcpkg\\_cmake\\_install](ports/vcpkg-cmake/vcpkg_cmake_install.md)\n\n### [vcpkg-cmake-config](ports/vcpkg-cmake-config.md)\n\n- [vcpkg\\_cmake\\_config\\_fixup](ports/vcpkg-cmake-config/vcpkg_cmake_config_fixup.md)\n\n### [vcpkg-pkgconfig-get-modules](ports/vcpkg-pkgconfig-get-modules.md)\n\n- [x\\_vcpkg\\_pkgconfig\\_get\\_modules](ports/vcpkg-pkgconfig-get-modules/x_vcpkg_pkgconfig_get_modules.md)\n","Nav":"#"},{"Path":"/en/docs/maintainers/ports/vcpkg-cmake/vcpkg_cmake_build.html","Name":"vcpkg_cmake_build","Source":"# vcpkg_cmake_build\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/ports/vcpkg-cmake/vcpkg_cmake_build.md).\n\nBuild a cmake project.\n\n```cmake\nvcpkg_cmake_build(\n    [TARGET <target>]\n    [LOGFILE_BASE <base>]\n    [DISABLE_PARALLEL]\n    [ADD_BIN_TO_PATH]\n)\n```\n\n`vcpkg_cmake_build` builds an already-configured cmake project.\nYou can use the alias [`vcpkg_cmake_install()`] function\nif your CMake build system supports the `install` TARGET,\nand this is something we recommend doing whenever possible.\nOtherwise, you can use `TARGET` to set the target to build.\nThis function defaults to not passing a target to cmake.\n\n`LOGFILE_BASE` is used to set the base of the logfile names;\nby default, this is `build`, and thus the logfiles end up being something like\n`build-x86-windows-dbg.log`; if you use `vcpkg_cmake_install`,\nthis is set to `install`, so you'll get log names like `install-x86-windows-dbg.log`.\n\nFor build systems that are buggy when run in parallel,\nusing `DISABLE_PARALLEL` will run the build with only one job.\n\nFinally, `ADD_BIN_TO_PATH` adds the appropriate (either release or debug)\n`bin/` directories to the path during the build,\nsuch that executables run during the build will be able to access those DLLs.\n\n## Source\n[ports/vcpkg-cmake/vcpkg\\_cmake\\_build.cmake](https://github.com/Microsoft/vcpkg/blob/master/ports/vcpkg-cmake/vcpkg_cmake_build.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/ports/vcpkg-cmake/vcpkg_cmake_configure.html","Name":"vcpkg_cmake_configure","Source":"# vcpkg_cmake_configure\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/ports/vcpkg-cmake/vcpkg_cmake_configure.md).\n\nConfigure a CMake buildsystem.\n\n```cmake\nvcpkg_cmake_configure(\n    SOURCE_PATH <source-path>\n    [LOGFILE_BASE <logname-base>]\n    [DISABLE_PARALLEL_CONFIGURE]\n    [NO_CHARSET_FLAG]\n    [WINDOWS_USE_MSBUILD]\n    [GENERATOR <generator>]\n    [OPTIONS\n        <configure-setting>...]\n    [OPTIONS_RELEASE\n        <configure-setting>...]\n    [OPTIONS_DEBUG\n        <configure-setting>...]\n    [MAYBE_UNUSED_VARIABLES\n        <option-name>...]\n)\n```\n\n`vcpkg_cmake_configure` configures a CMake build system for use with\n`vcpkg_cmake_buildsystem_build` and `vcpkg_cmake_buildsystem_install`.\n`source-path` is where the source is located; by convention,\nthis is usually `${SOURCE_PATH}`, which is set by one of the `vcpkg_from_*` functions.\nThis function configures the build system for both Debug and Release builds by default,\nassuming that `VCPKG_BUILD_TYPE` is not set; if it is, then it will only configure for\nthat build type.\n\nUse the `OPTIONS` argument to set the configure settings for both release and debug,\nand use `OPTIONS_RELEASE` and `OPTIONS_DEBUG` to set the configure settings for\nrelease only and debug only respectively.\n\nBy default, when possible, `vcpkg_cmake_configure` uses [ninja-build]\nas its build system. If the `WINDOWS_USE_MSBUILD` argument is passed, then\n`vcpkg_cmake_configure` will use a Visual Studio generator on Windows;\non every other platform, `vcpkg_cmake_configure` just uses Ninja.\n\n[ninja-build]: https://ninja-build.org/\n\nAdditionally, one may pass the specific generator a port should use with `GENERATOR`.\nThis is useful if some project-specific buildsystem\nhas been wrapped in a CMake build system that doesn't perform an actual build.\nIf used for this purpose, it should be set to `\"NMake Makefiles\"`.\n`vcpkg_cmake_buildsystem_build` and `install` do not support this being set to anything\nexcept for NMake.\n\nFor libraries which cannot be configured in parallel,\npass the `DISABLE_PARALLEL_CONFIGURE` flag. This is needed, for example,\nif the library's build system writes back into the source directory during configure.\nThis also disables the `CMAKE_DISABLE_SOURCE_CHANGES` option.\n\nBy default, this function adds flags to `CMAKE_C_FLAGS` and `CMAKE_CXX_FLAGS`\nwhich set the default character set to utf-8 for MSVC.\nIf the library sets its own code page, pass the `NO_CHARSET_FLAG` option.\n\nThis function makes certain that all options passed in are used by the\nunderlying CMake build system. If there are options that might be unused,\nperhaps on certain platforms, pass those variable names to\n`MAYBE_UNUSED_VARIABLES`. For example:\n```cmake\nvcpkg_cmake_configure(\n    ...\n    OPTIONS\n        -DBUILD_EXAMPLE=OFF\n    ...\n    MAYBE_UNUSED_VARIABLES\n        BUILD_EXAMPLE\n)\n```\n\n`LOGFILE_BASE` is used to set the base of the logfile names;\nby default, this is `config`, and thus the logfiles end up being something like\n`config-x86-windows-dbg.log`. You can set it to anything you like;\nif you set it to `config-the-first`,\nyou'll get something like `config-the-first-x86-windows.dbg.log`.\n\n## Notes\nThis command supplies many common arguments to CMake. To see the full list, examine the source.\n\n## Examples\n\n* [zlib](https://github.com/Microsoft/vcpkg/blob/master/ports/zlib/portfile.cmake)\n* [cpprestsdk](https://github.com/Microsoft/vcpkg/blob/master/ports/cpprestsdk/portfile.cmake)\n* [poco](https://github.com/Microsoft/vcpkg/blob/master/ports/poco/portfile.cmake)\n* [opencv](https://github.com/Microsoft/vcpkg/blob/master/ports/opencv/portfile.cmake)\n\n## Source\n[ports/vcpkg-cmake/vcpkg\\_cmake\\_configure.cmake](https://github.com/Microsoft/vcpkg/blob/master/ports/vcpkg-cmake/vcpkg_cmake_configure.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/ports/vcpkg-cmake/vcpkg_cmake_get_vars.html","Name":"vcpkg_cmake_get_vars","Source":"# vcpkg_cmake_get_vars\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/ports/vcpkg-cmake/vcpkg_cmake_get_vars.md).\n\nRuns a cmake configure with a dummy project to extract certain cmake variables\n\n## Usage\n```cmake\nvcpkg_cmake_get_vars(<out-var>)\n```\n\n`vcpkg_cmake_get_vars(<out-var>)` sets `<out-var>` to\na path to a generated CMake file, with the detected `CMAKE_*` variables\nre-exported as `VCPKG_DETECTED_CMAKE_*`.\n\n## Notes\nAvoid usage in portfiles.\n\nAll calls to `vcpkg_cmake_get_vars` will result in the same output file;\nthe output file is not generated multiple times.\n\n### Basic Usage\n\n```cmake\nvcpkg_cmake_get_vars(cmake_vars_file)\ninclude(\"${cmake_vars_file}\")\nmessage(STATUS \"detected CXX flags: ${VCPKG_DETECTED_CMAKE_CXX_FLAGS}\")\n```\n\n## Source\n[ports/vcpkg-cmake/vcpkg\\_cmake\\_get\\_vars.cmake](https://github.com/Microsoft/vcpkg/blob/master/ports/vcpkg-cmake/vcpkg_cmake_get_vars.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/ports/vcpkg-cmake/vcpkg_cmake_install.html","Name":"vcpkg_cmake_install","Source":"# vcpkg_cmake_install\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/ports/vcpkg-cmake/vcpkg_cmake_install.md).\n\nBuild and install a cmake project.\n\n```cmake\nvcpkg_cmake_install(\n    [DISABLE_PARALLEL]\n    [ADD_BIN_TO_PATH]\n)\n```\n\n`vcpkg_cmake_install` transparently forwards to [`vcpkg_cmake_build()`],\nwith additional parameters to set the `TARGET` to `install`,\nand to set the `LOGFILE_ROOT` to `install` as well.\n\n[`vcpkg_cmake_build()`]: vcpkg_cmake_build.cmake\n\n## Examples:\n\n* [zlib](https://github.com/Microsoft/vcpkg/blob/master/ports/zlib/portfile.cmake)\n\n## Source\n[ports/vcpkg-cmake/vcpkg\\_cmake\\_install.cmake](https://github.com/Microsoft/vcpkg/blob/master/ports/vcpkg-cmake/vcpkg_cmake_install.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/ports/vcpkg-cmake-config/vcpkg_cmake_config_fixup.html","Name":"vcpkg_cmake_config_fixup","Source":"# vcpkg_cmake_config_fixup\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/ports/vcpkg-cmake-config/vcpkg_cmake_config_fixup.md).\n\nMerge release and debug CMake targets and configs to support multiconfig generators.\n\nAdditionally corrects common issues with targets, such as absolute paths and incorrectly placed binaries.\n\n```cmake\nvcpkg_cmake_config_fixup(\n    [PACKAGE_NAME <name>]\n    [CONFIG_PATH <config-directory>]\n    [DO_NOT_DELETE_PARENT_CONFIG_PATH]\n    [NO_PREFIX_CORRECTION]\n)\n```\n\nFor many ports, `vcpkg_cmake_config_fixup()` on its own should work,\nas `PACKAGE_NAME` defaults to `${PORT}` and `CONFIG_PATH` defaults to `share/${PACKAGE_NAME}`.\nFor ports where the package name passed to `find_package` is distinct from the port name,\n`PACKAGE_NAME` should be changed to be that name instead.\nFor ports where the directory of the `*config.cmake` files cannot be set,\nuse the `CONFIG_PATH` to change the directory where the files come from.\n\nBy default the parent directory of CONFIG_PATH is removed if it is named \"cmake\".\nPassing the `DO_NOT_DELETE_PARENT_CONFIG_PATH` option disable such behavior,\nas it is convenient for ports that install\nmore than one CMake package configuration file.\n\nThe `NO_PREFIX_CORRECTION` option disables the correction of `_IMPORT_PREFIX`\ndone by vcpkg due to moving the config files.\nCurrently the correction does not take into account how the files are moved,\nand applies a rather simply correction which in some cases will yield the wrong results.\n\n## How it Works\n\n1. Moves `/debug/<CONFIG_PATH>/*targets-debug.cmake` to `/share/${PACKAGE_NAME}`.\n2. Removes `/debug/<CONFIG_PATH>/*config.cmake`.\n3. Transform all references matching `/bin/*.exe` to `/tools/<port>/*.exe` on Windows.\n4. Transform all references matching `/bin/*` to `/tools/<port>/*` on other platforms.\n5. Fixes `${_IMPORT_PREFIX}` in auto generated targets.\n6. Replace `${CURRENT_INSTALLED_DIR}` with `${_IMPORT_PREFIX}` in configs and targets.\n\n## Examples\n\n* [concurrentqueue](https://github.com/Microsoft/vcpkg/blob/master/ports/concurrentqueue/portfile.cmake)\n* [curl](https://github.com/Microsoft/vcpkg/blob/master/ports/curl/portfile.cmake)\n* [nlohmann-json](https://github.com/Microsoft/vcpkg/blob/master/ports/nlohmann-json/portfile.cmake)\n\n## Source\n[ports/vcpkg-cmake-config/vcpkg\\_cmake\\_config\\_fixup.cmake](https://github.com/Microsoft/vcpkg/blob/master/ports/vcpkg-cmake-config/vcpkg_cmake_config_fixup.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/ports/vcpkg-cmake-config.html","Name":"vcpkg-cmake-config","Source":"# vcpkg-cmake-config\n\n`vcpkg-cmake-config` provides `vcpkg_cmake_config_fixup()`,\na function which both:\n\n- Fixes common mistakes in port build systems, like using absolute paths\n- Merges the debug and release config files.\n\nThis function should almost always be used when a port has `*config.cmake` files,\neven when the buildsystem of the project is not CMake.\n","Nav":"#"},{"Path":"/en/docs/maintainers/ports/vcpkg-cmake.html","Name":"vcpkg-cmake","Source":"# vcpkg-cmake\n\nThis port contains cmake functions for dealing with a CMake buildsystem.\n\nIn the common case, `vcpkg_cmake_configure()` (with appropriate arguments)\nfollowed by `vcpkg_cmake_install()` will be enough to build and install a port.\n`vcpkg_cmake_build()` is provided for more complex cases.\n","Nav":"#"},{"Path":"/en/docs/maintainers/ports/vcpkg-pkgconfig-get-modules/x_vcpkg_pkgconfig_get_modules.html","Name":"X_vcpkg_pkgconfig_get_modules","Source":"# x_vcpkg_pkgconfig_get_modules\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/ports/vcpkg-pkgconfig-get-modules/x_vcpkg_pkgconfig_get_modules.md).\n\nExperimental\nRetrieve required module information from pkgconfig modules\n\n## Usage\n```cmake\nx_vcpkg_pkgconfig_get_modules(\n    PREFIX <prefix>\n    MODULES <pkgconfig_modules>...\n    [LIBS]\n    [LIBRARIES]\n    [LIBRARIES_DIRS]\n    [INCLUDE_DIRS]\n)\n```\n## Parameters\n\n### PREFIX\nUsed variable prefix to use\n\n### MODULES\nList of pkgconfig modules to retrieve information for.\n\n### LIBS\nReturns `\"${PKGCONFIG}\" --libs` in <prefix>_LIBS_(DEBUG|RELEASE)\n\n### LIBRARIES\nReturns `\"${PKGCONFIG}\" --libs-only-l` in <prefix>_LIBRARIES_(DEBUG|RELEASE)\n\n### LIBRARIES_DIRS\nReturns `\"${PKGCONFIG}\" --libs-only-L` in <prefix>_LIBRARIES_DIRS_(DEBUG|RELEASE)\n\n### INCLUDE_DIRS\nReturns `\"${PKGCONFIG}\"  --cflags-only-I` in <prefix>_INCLUDE_DIRS_(DEBUG|RELEASE)\n\n## Examples\n\n* [qt5-base](https://github.com/microsoft/vcpkg/blob/master/ports/qt5-base/portfile.cmake)\n\n## Source\n[ports/vcpkg-pkgconfig-get-modules/x\\_vcpkg\\_pkgconfig\\_get\\_modules.cmake](https://github.com/Microsoft/vcpkg/blob/master/ports/vcpkg-pkgconfig-get-modules/x_vcpkg_pkgconfig_get_modules.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/ports/vcpkg-pkgconfig-get-modules.html","Name":"vcpkg-pkgconfig-get-modules","Source":"# vcpkg-pkgconfig-get-modules\n\n**Experimental: will change or be removed at any time**\n\n`vcpkg-pkgconfig-get-modules` provides `x_vcpkg_pkgconfig_get_modules()`, a function which simplifies calling\n`pkg-config` in portfiles in order to gather dependencies for exotic buildsystems.\n","Nav":"#"},{"Path":"/en/docs/maintainers/pr-review-checklist.html","Name":"PR Checklist","Source":"Vcpkg PR Checklist\n=====================\nRevision: 1\n\n## Overview\nThis document provides an annotated checklist which vcpkg team members use to apply the \"reviewed\" label on incoming pull requests. If a pull request violates any of these points, we may ask contributors to make necessary changes before we can merge the changeset.\n\nFeel free to create an issue or pull request if you feel that this checklist can be improved. Please increment the revision number when modifying the checklist content.\n\n## Checklist\nYou can link any of these checklist items in a GitHub comment by copying the link address attached to each item code.\n\n<details id=\"c000001\">\n<summary><a href=\"#c000001\">c000001</a>: No deprecated helper functions are used</summary>\n\nSee our [Maintainer Guidelines and Policies](maintainer-guide.md#Avoid-deprecated-helper-functions) for more information.\n\n</details>\n\n<details id=\"c000002\">\n<summary><a href=\"#c000002\">c000002</a>: `\"port-version\"` field is updated</summary>\n\nSee our [Maintainer Guidelines and Policies](maintainer-guide.md#versioning) for more information.\n\n</details>\n\n<details id=\"c000003\">\n<summary><a href=\"#c000003\">c000003</a>: New ports contain a `\"description\"` field written in English</summary>\n\nA description only one or a few sentences long is helpful. Consider using the library's official description from their `README.md` or similar if possible. Automatic translations are acceptable and we are happy to clean up translations to English for our contributors.\n\nSee our [manifest file documentation](manifest-files.md#description) for more information.\n    \n</details>\n\n<details id=\"c000004\">\n<summary><a href=\"#c000004\">c000004</a>: No unnecessary comments are present in the changeset</summary>\n\nSee our [Maintainer Guidelines and Policies](maintainer-guide.md#Avoid-excessive-comments-in-portfiles) for more information.\n\n</details>\n\n<details id=\"c000005\">\n<summary><a href=\"#c000005\">c000005</a>: Downloaded archives are versioned if available</summary\n\nTo ensure archive content does not change, archives downloaded preferably have an associated version tag that can be incremented alongside the port's `\"version\"`.\n\n</details>\n\n<details id=\"c000006\">\n<summary><a href=\"#c000006\">c000006</a>: New ports pass CI checks for triplets that the library officially supports</summary>\n\nTo ensure vcpkg ports are of a high quality, we ask that incoming ports support the official platforms for the library in question.\n\n</details>\n\n<details id=\"c000007\">\n<summary><a href=\"#c000007\">c000007</a>: Patches fix issues that are vcpkg-specific only</summary>\n\nIf possible, patches to the library source code should be upstreamed to the library's official repository. Opening up a pull request on the library's repository will help to improve the library for everyone, not just vcpkg users.\n\n</details>\n\n<details id=\"c000008\">\n<summary><a href=\"#c000008\">c000008</a>: New ports download source code from the official source if available</summary>\n\nTo respect library authors and keep code secure, please have ports download source code from the official source. We may make exceptions if the original source code is not available and there is substantial community interest in maintaining the library in question.\n\n</details>\n\n<details id=\"c000009\">\n<summary><a href=\"#c000009\">c000009</a>: Ports and port features are named correctly</summary>\n\nFor user accessibility, we prefer names of ports and port features to be intuitive and close to their counterparts in official sources and other package managers. If you are unsure about the naming of a port or port feature, we recommend checking repology.org, packages.ubuntu.com, or searching for additional information using a search engine. We can also help our contributors with this, so feel free to ask for naming suggestions if you are unsure.\n\n</details>\n\n<details id=\"c000010\">\n<summary><a href=\"#c000010\">c000010</a>: Library targets are exported when appropriate</summary>\n\nTo provide users with a seamless build system integration, please be sure to export and provide a means of finding the library targets intended to be used downstream. Targets not meant to be exported should be be marked private and not exported.\n\n</details>\n\n<details id=\"c000011\">\n<summary><a href=\"#c000011\">c000011</a>: Ports do not use applications which modify the user's system</summary>\n    \nPorts should uphold vcpkg's contract of not modifying the user's system by avoiding applications which do so. Examples of these applications are `sudo`, `apt`, `brew`, or `pip`. Please use an alternative to these types of programs wherever possible.\n\n</details>\n\n<details id=\"c000012\">\n<summary><a href=\"#c000012\">c000012</a>: Ports with system dependencies include an information message during installation</summary>\n\nSome ports have library and tool dependencies that do not exist within vcpkg. For these missing dependencies, we ask that contributors add a message to the top of the port's `portfile.cmake` stating the missing dependencies and how to acquire them. We ask that the message is displayed before any major work is done to ensure that users can \"early out\" of the installation process as soon as possible in case they are missing the dependency.\n\nExample:\n```cmake\nmessage(\n\"${PORT} currently requires the following libraries from the system package manager:\n    autoconf libtool\nThese can be installed on Ubuntu systems via sudo apt install autoconf libtool\"\n)\n```\n\n</details>\n\n<details id=\"c000013\">\n<summary><a href=\"#c000013\">c000013</a>: Manifest files are used instead of CONTROL files for new ports</summary>\n\nMany existing ports use the CONTROL file syntax; while this syntax will be supported for some time to come,\nnew ports should not use these. Any newly added port _must_ use the manifest files.\n\nWe also recommend, when significant modifications are made to ports, that one switches to manifest files;\nhowever, this is not required. You may find `vcpkg format-manifest` useful.\n","Nav":"#"},{"Path":"/en/docs/maintainers/registries.html","Name":"Registries","Source":"# Creating Registries\n\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/maintainers/registries.md).**\n\nThere are two parts to using registries; this documents the creation side of\nthe relationship. In order to learn more about using registries that others\nhave created, please read [this documentation](../users/registries.md).\n## Table of Contents\n\n- [Creating Registries](#creating-registries)\n  - [Table of Contents](#table-of-contents)\n  - [Overview](#overview)\n    - [Git Registries](#git-registries)\n      - [Adding a New Version](#adding-a-new-version)\n    - [Filesystem Registries](#filesystem-registries)\n      - [Adding a New Version](#adding-a-new-version-1)\n\n## Overview\n\nRegistries are collections of ports and their versions. There are two major\nchoices of implementation for registries, if you want to create your own -\ngit registries, and filesystem registries.\n\nGit registries are simple git repositories, and can be shared publicly or\nprivately via normal mechanisms for git repositories. The vcpkg repository at\n<https://github.com/microsoft/vcpkg>, for example, is a git registry.\n\nFilesystem registries are designed as more of a testing ground. Given that they\nliterally live on your filesystem, the only way to share them is via shared\ndirectories. However, filesystem registries can be useful as a way to represent\nregistries held in non-git version control systems, assuming one has some way\nto get the registry onto the disk.\n\nNote that we expect the set of registry types to grow over time; if you would\nlike support for registries built in your favorite public version control\nsystem, don't hesitate to open a PR.\n\nThe basic structure of a registry is:\n\n- The set of versions that are considered \"latest\" at certain times in history,\n  known as the \"baseline\".\n- The set of all the versions of all the ports, and where to find each of\n  these in the registry.\n\n### Git Registries\n\nAs you're following along with this documentation, it may be helpful to have\na working example to refer to. We've written one and put it here:\n<https://github.com/northwindtraders/vcpkg-registry>.\n\nAll git registries must have a `versions/baseline.json` file. This file\ncontains the set of \"latest versions\" at a certain commit. It is laid out as\na top-level object containing only the `\"default\"` field. This field should\ncontain an object mapping port names to the version which is currently the\nlatest.\n\nHere's an example of a valid baseline.json:\n\n```json\n{\n  \"default\": {\n    \"kitten\": {\n      \"baseline\": \"2.6.2\",\n      \"port-version\": 0\n    },\n    \"port-b\": {\n      \"baseline\": \"19.00\",\n      \"port-version\": 2\n    }\n  }\n}\n```\n\nThe `versions` directory contains all the information about which versions of\nwhich packages are contained in the registry, along with where those versions\nare stored. The rest of the registry just acts as a backing store, as far as\nvcpkg is concerned: only things inside the `versions` directory will be used\nto direct how your registry is seen by vcpkg.\n\nEach port in a registry should exist in the versions directory as\n`<first letter of port>-/<name of port>.json`; in other words, the\ninformation about the `kitten` port would be located in\n`versions/k-/kitten.json`. This should be a top-level object with only a\nsingle field: `\"versions\"`. This field should contain an array of version \nobjects:\n\n- The version of the port in question; should be exactly the same as the\n  `vcpkg.json` file, including the version fields and `\"port-version\"`.\n- The `\"git-tree\"` field, which is a git tree; in other words, what you get\n  when you write `git rev-parse COMMIT-ID:path/to/port`.\n\nNote that the version fields for ports with `CONTROL` files, is \n`\"version-string\"`; we do not recommend using `CONTROL` files in new\nregistries, however.\n\n_WARNING_: One very important part of registries is that versions should\n_never_ be changed. Updating to a later ref should never remove or change an\nexisting version. It must always be safe to update a registry.\n\nHere's an example of a valid version database for a `kitten` port with one \nversion:\n\n```json\n{\n  \"versions\": [\n    {\n      \"version\": \"2.6.2\",\n      \"port-version\": 0,\n      \"git-tree\": \"67d60699c271b7716279fdea5a5c6543929eb90e\"\n    }\n  ]\n}\n```\n\nIn general, it's not important where you place port directories. However, the\nidiom in vcpkg is to follow what the built in vcpkg registry does: your \n`kitten` port should be placed in `ports/kitten`.\n\n_WARNING_: One other thing to keep in mind is that when you update a registry,\nall previous versions should also be accessible. Since your user will set their\nbaseline to a commit ID, that commit ID must always exist, and be accessible\nfrom your HEAD commit, which is what is actually fetched. This means that your\nHEAD commit should be a child of all previous HEAD commits.\n\n#### Adding a New Version\n\nThere is some git trickery involved in creating a new version of a port. The\nfirst thing to do is make some changes, update the `\"port-version\"` and regular\nversion field as you need to, and then test with `overlay-ports`:\n`vcpkg install kitten --overlay-ports=ports/kitten`.\n\nOnce you've finished your testing, you'll need to make sure that the directory\nas it is is under git's purview. You'll do this by creating a temporary commit:\n\n```pwsh\n> git add ports/kitten\n> git commit -m 'temporary commit'\n```\n\nThen, get the git tree ID of the directory:\n\n```pwsh\n> git rev-parse HEAD:ports/kitten\n73ad3c823ef701c37421b450a34271d6beaf7b07\n```\n\nThen, you can add this version to the versions database. At the top of your\n`versions/k-/kitten.json`, you can add (assuming you're adding version\n`2.6.3#0`):\n\n```json\n{\n  \"versions\": [\n    {\n      \"version\": \"2.6.3\",\n      \"port-version\": 0,\n      \"git-tree\": \"73ad3c823ef701c37421b450a34271d6beaf7b07\"\n    },\n    {\n      \"version\": \"2.6.2\",\n      \"port-version\": 0,\n      \"git-tree\": \"67d60699c271b7716279fdea5a5c6543929eb90e\"\n    }\n  ]\n}\n```\n\nthen, you'll want to modify your `versions/baseline.json` with your new version \nas well:\n\n```json\n{\n  \"default\": {\n    \"kitten\": {\n      \"baseline\": \"2.6.3\",\n      \"port-version\": 0\n    },\n    \"port-b\": {\n      \"baseline\": \"19.00\",\n      \"port-version\": 2\n    }\n  }\n}\n```\n\nand amend your current commit:\n\n```pwsh\n> git commit --amend\n```\n\nthen share away!\n\n### Filesystem Registries\n\nAs you're following along with this documentation, it may be helpful to have\na working example to refer to. We've written one and put it here:\n<https://github.com/vcpkg/example-filesystem-registry>.\n\nAll filesystem registries must have a `versions/baseline.json` file. This file\ncontains the set of \"latest versions\" for a certain version of the registry.\nIt is laid out as a top-level object containing a map from version name to\n\"baseline objects\", which map port names to the version which is considered\n\"latest\" for that version of the registry.\n\nFilesystem registries need to decide on a versioning scheme. Unlike git \nregistries, which have the implicit versioning scheme of refs, filesystem\nregistries can't rely on the version control system here. One possible option\nis to do a daily release, and have your \"versions\" be dates.\n\n_WARNING_: A baseline must always refer to the same set of versions. If you\nwant to add new versions, you need to create a new version of the registry in\nthe `baseline.json` file.\n\nHere's an example of a valid `baseline.json`, for a registry that has decided\nupon dates for their versions:\n\n```json\n{\n  \"2021-04-16\": {\n    \"kitten\": {\n      \"baseline\": \"2.6.2\",\n      \"port-version\": 0\n    },\n    \"port-b\": {\n      \"baseline\": \"19.00\",\n      \"port-version\": 2\n    }\n  },\n  \"2021-04-15\": {\n    \"kitten\": {\n      \"baseline\": \"2.6.2\",\n      \"port-version\": 0\n    },\n    \"port-b\": {\n      \"baseline\": \"19.00\",\n      \"port-version\": 1\n    }\n  }\n}\n```\n\nThe `versions` directory contains all the information about which versions of\nwhich packages are contained in the registry, along with where those versions\nare stored. The rest of the registry just acts as a backing store, as far as\nvcpkg is concerned: only things inside the `versions` directory will be used\nto direct how your registry is seen by vcpkg.\n\nEach port in a registry should exist in the versions directory as\n`<first letter of port>-/<name of port>.json`; in other words, the\ninformation about the `kitten` port would be located in\n`versions/k-/kitten.json`. This should be a top-level object with only a\nsingle field: `\"versions\"`. This field should contain an array of version \nobjects:\n\n- The version of the port in question; should be exactly the same as the\n  `vcpkg.json` file, including the version fields and `\"port-version\"`.\n- The `\"path\"` field: a relative directory, rooted at the base of the registry\n  (in other words, the directory where `versions` is located), to the port \n  directory. It should look something like `\"$/path/to/port/dir`\"\n\nNote that the version fields for ports with `CONTROL` files, is \n`\"version-string\"`; we do not recommend using `CONTROL` files in new\nregistries, however.\n\nIn general, it's not important where you place port directories. However, the\nidiom in vcpkg is to follow somewhat closely to what the built in vcpkg\nregistry does: your `kitten` port at version `x.y.z` should be placed in\n`ports/kitten/x.y.z`, with port versions appended as you see fit (although\nsince `#` is not a good character to use for file names, perhaps use `_`).\n\n_WARNING_: One very important part of registries is that versions should\n_never_ be changed. One should never remove or change an existing version.\nYour changes to your registry shouldn't change behavior to downstream users.\n\nHere's an example of a valid version database for a `kitten` port with one \nversion:\n\n```json\n{\n  \"versions\": [\n    {\n      \"version\": \"2.6.2\",\n      \"port-version\": 0,\n      \"path\": \"$/ports/kitten/2.6.2_0\"\n    }\n  ]\n}\n```\n\n#### Adding a New Version\n\nUnlike git registries, adding a new version to a filesystem registry mostly\ninvolves a lot of copying. The first thing to do is to copy the latest\nversion of your port into a new version directory, update the version and\n`\"port-version\"` fields as you need to, and then test with `overlay-ports`:\n`vcpkg install kitten --overlay-ports=ports/kitten/new-version`.\n\nOnce you've finished your testing, you can add this new version to the top of\nyour `versions/k-/kitten.json`:\n\n```json\n{\n  \"versions\": [\n    {\n      \"version\": \"2.6.3\",\n      \"port-version\": 0,\n      \"path\": \"$/ports/kitten/2.6.3_0\"\n    },\n    {\n      \"version\": \"2.6.2\",\n      \"port-version\": 0,\n      \"path\": \"$/ports/kitten/2.6.2_0\"\n    }\n  ]\n}\n```\n\nthen, you'll want to modify your `versions/baseline.json` with your new version \nas well (remember not to modify existing baselines):\n\n```json\n{\n  \"2021-04-17\": {\n    \"kitten\": {\n      \"baseline\": \"2.6.3\",\n      \"port-version\": 0\n    },\n    \"port-b\": {\n      \"baseline\": \"19.00\",\n      \"port-version\": 2\n    }\n  },\n  \"2021-04-16\": {\n    \"kitten\": {\n      \"baseline\": \"2.6.2\",\n      \"port-version\": 0\n    },\n    \"port-b\": {\n      \"baseline\": \"19.00\",\n      \"port-version\": 2\n    }\n  },\n  \"2021-04-15\": {\n    \"kitten\": {\n      \"baseline\": \"2.6.2\",\n      \"port-version\": 0\n    },\n    \"port-b\": {\n      \"baseline\": \"19.00\",\n      \"port-version\": 1\n    }\n  }\n}\n```\n\nand you're done!\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_acquire_msys.html","Name":"vcpkg_acquire_msys","Source":"# vcpkg_acquire_msys\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_acquire_msys.md).\n\nDownload and prepare an MSYS2 instance.\n\n## Usage\n```cmake\nvcpkg_acquire_msys(<MSYS_ROOT_VAR>\n    PACKAGES <package>...\n    [NO_DEFAULT_PACKAGES]\n    [DIRECT_PACKAGES <URL> <SHA512> <URL> <SHA512> ...]\n)\n```\n\n## Parameters\n### MSYS_ROOT_VAR\nAn out-variable that will be set to the path to MSYS2.\n\n### PACKAGES\nA list of packages to acquire in msys.\n\nTo ensure a package is available: `vcpkg_acquire_msys(MSYS_ROOT PACKAGES make automake1.16)`\n\n### NO_DEFAULT_PACKAGES\nExclude the normal base packages.\n\nThe list of base packages includes: bash, coreutils, sed, grep, gawk, diffutils, make, and pkg-config\n\n### DIRECT_PACKAGES\nA list of URL/SHA512 pairs to acquire in msys.\n\nThis parameter can be used by a port to privately extend the list of msys packages to be acquired.\nThe URLs can be found on the msys2 website[1] and should be a direct archive link:\n\n    https://repo.msys2.org/mingw/i686/mingw-w64-i686-gettext-0.19.8.1-9-any.pkg.tar.zst\n\n[1] https://packages.msys2.org/search\n\n## Notes\nA call to `vcpkg_acquire_msys` will usually be followed by a call to `bash.exe`:\n```cmake\nvcpkg_acquire_msys(MSYS_ROOT)\nset(BASH ${MSYS_ROOT}/usr/bin/bash.exe)\n\nvcpkg_execute_required_process(\n    COMMAND ${BASH} --noprofile --norc \"${CMAKE_CURRENT_LIST_DIR}\\\\build.sh\"\n    WORKING_DIRECTORY ${CURRENT_BUILDTREES_DIR}/${TARGET_TRIPLET}-rel\n    LOGNAME build-${TARGET_TRIPLET}-rel\n)\n```\n\n## Examples\n\n* [ffmpeg](https://github.com/Microsoft/vcpkg/blob/master/ports/ffmpeg/portfile.cmake)\n* [icu](https://github.com/Microsoft/vcpkg/blob/master/ports/icu/portfile.cmake)\n* [libvpx](https://github.com/Microsoft/vcpkg/blob/master/ports/libvpx/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_acquire\\_msys.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_acquire_msys.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_add_to_path.html","Name":"vcpkg_add_to_path","Source":"# vcpkg_add_to_path\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_add_to_path.md).\n\nAdd a directory or directories to the PATH environment variable\n\n```cmake\nvcpkg_add_to_path([PREPEND] [<path>...])\n```\n\n`vcpkg_add_to_path` adds all of the paths passed to it to the PATH environment variable.\nIf PREPEND is passed, then those paths are prepended to the PATH environment variable,\nso that they are searched first; otherwise, those paths are appended, so they are\nsearched after the paths which are already in the environment variable.\n\nThe paths are added in the order received, so that the first path is always searched\nbefore a later path.\n\nIf no paths are passed, then nothing will be done.\n\n## Examples:\n* [curl](https://github.com/Microsoft/vcpkg/blob/master/ports/curl/portfile.cmake#L75)\n* [folly](https://github.com/Microsoft/vcpkg/blob/master/ports/folly/portfile.cmake#L15)\n* [z3](https://github.com/Microsoft/vcpkg/blob/master/ports/z3/portfile.cmake#L13)\n\n## Source\n[scripts/cmake/vcpkg\\_add\\_to\\_path.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_add_to_path.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_apply_patches.html","Name":"vcpkg_apply_patches","Source":"# vcpkg_apply_patches\n\n**This function has been deprecated in favor of the `PATCHES` argument to [`vcpkg_from_github()`](vcpkg_from_github.md) et al.**\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_apply_patches.md).\n\nApply a set of patches to a source tree.\n\n```cmake\nvcpkg_apply_patches(\n    SOURCE_PATH <${SOURCE_PATH}>\n    [QUIET]\n    PATCHES <patch1.patch>...\n)\n```\n\n## Source\n[scripts/cmake/vcpkg\\_apply\\_patches.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_apply_patches.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_build_cmake.html","Name":"vcpkg_build_cmake","Source":"# vcpkg_build_cmake\n\n**This function has been deprecated in favor of [`vcpkg_cmake_build`](ports/vcpkg-cmake/vcpkg_cmake_build.md) from the vcpkg-cmake port.**\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_build_cmake.md).\n\nBuild a cmake project.\n\n## Usage:\n```cmake\nvcpkg_build_cmake([DISABLE_PARALLEL] [TARGET <target>])\n```\n\n## Parameters:\n### DISABLE_PARALLEL\nThe underlying buildsystem will be instructed to not parallelize\n\n### TARGET\nThe target passed to the cmake build command (`cmake --build . --target <target>`). If not specified, no target will\nbe passed.\n\n### ADD_BIN_TO_PATH\nAdds the appropriate Release and Debug `bin\\` directories to the path during the build such that executables can run against the in-tree DLLs.\n\n## Notes:\nThis command should be preceded by a call to [`vcpkg_configure_cmake()`](vcpkg_configure_cmake.md).\nYou can use the alias [`vcpkg_install_cmake()`](vcpkg_configure_cmake.md) function if your CMake script supports the\n\"install\" target\n\n## Examples:\n\n* [zlib](https://github.com/Microsoft/vcpkg/blob/master/ports/zlib/portfile.cmake)\n* [cpprestsdk](https://github.com/Microsoft/vcpkg/blob/master/ports/cpprestsdk/portfile.cmake)\n* [poco](https://github.com/Microsoft/vcpkg/blob/master/ports/poco/portfile.cmake)\n* [opencv](https://github.com/Microsoft/vcpkg/blob/master/ports/opencv/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_build\\_cmake.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_build_cmake.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_build_make.html","Name":"vcpkg_build_make","Source":"# vcpkg_build_make\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_build_make.md).\n\nBuild a linux makefile project.\n\n## Usage:\n```cmake\nvcpkg_build_make([BUILD_TARGET <target>]\n                 [ADD_BIN_TO_PATH]\n                 [ENABLE_INSTALL]\n                 [MAKEFILE <makefileName>]\n                 [LOGFILE_ROOT <logfileroot>])\n```\n\n### BUILD_TARGET\nThe target passed to the make build command (`./make <target>`). If not specified, the 'all' target will\nbe passed.\n\n### ADD_BIN_TO_PATH\nAdds the appropriate Release and Debug `bin\\` directories to the path during the build such that executables can run against the in-tree DLLs.\n\n### ENABLE_INSTALL\nIF the port supports the install target use vcpkg_install_make() instead of vcpkg_build_make()\n\n### MAKEFILE\nSpecifies the Makefile as a relative path from the root of the sources passed to `vcpkg_configure_make()`\n\n### BUILD_TARGET\nThe target passed to the make build command (`./make <target>`). Defaults to 'all'.\n\n### INSTALL_TARGET\nThe target passed to the make build command (`./make <target>`) if `ENABLE_INSTALL` is used. Defaults to 'install'.\n\n### DISABLE_PARALLEL\nThe underlying buildsystem will be instructed to not parallelize\n\n### SUBPATH\nAdditional subdir to invoke make in. Useful if only parts of a port should be built. \n\n## Notes:\nThis command should be preceded by a call to [`vcpkg_configure_make()`](vcpkg_configure_make.md).\nYou can use the alias [`vcpkg_install_make()`](vcpkg_install_make.md) function if your makefile supports the\n\"install\" target\n\n## Examples\n\n* [x264](https://github.com/Microsoft/vcpkg/blob/master/ports/x264/portfile.cmake)\n* [tcl](https://github.com/Microsoft/vcpkg/blob/master/ports/tcl/portfile.cmake)\n* [freexl](https://github.com/Microsoft/vcpkg/blob/master/ports/freexl/portfile.cmake)\n* [libosip2](https://github.com/Microsoft/vcpkg/blob/master/ports/libosip2/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_build\\_make.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_build_make.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_build_msbuild.html","Name":"vcpkg_build_msbuild","Source":"# vcpkg_build_msbuild\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_build_msbuild.md).\n\nBuild a msbuild-based project. Deprecated in favor of `vcpkg_install_msbuild()`.\n\n## Usage\n```cmake\nvcpkg_build_msbuild(\n    PROJECT_PATH <${SOURCE_PATH}/port.sln>\n    [RELEASE_CONFIGURATION <Release>]\n    [DEBUG_CONFIGURATION <Debug>]\n    [TARGET <Build>]\n    [TARGET_PLATFORM_VERSION <10.0.15063.0>]\n    [PLATFORM <${TRIPLET_SYSTEM_ARCH}>]\n    [PLATFORM_TOOLSET <${VCPKG_PLATFORM_TOOLSET}>]\n    [OPTIONS </p:ZLIB_INCLUDE_PATH=X>...]\n    [OPTIONS_RELEASE </p:ZLIB_LIB=X>...]\n    [OPTIONS_DEBUG </p:ZLIB_LIB=X>...]\n    [USE_VCPKG_INTEGRATION]\n)\n```\n\n## Parameters\n### USE_VCPKG_INTEGRATION\nApply the normal `integrate install` integration for building the project.\n\nBy default, projects built with this command will not automatically link libraries or have header paths set.\n\n### PROJECT_PATH\nThe path to the solution (`.sln`) or project (`.vcxproj`) file.\n\n### RELEASE_CONFIGURATION\nThe configuration (``/p:Configuration`` msbuild parameter) used for Release builds.\n\n### DEBUG_CONFIGURATION\nThe configuration (``/p:Configuration`` msbuild parameter)\nused for Debug builds.\n\n### TARGET_PLATFORM_VERSION\nThe WindowsTargetPlatformVersion (``/p:WindowsTargetPlatformVersion`` msbuild parameter)\n\n### TARGET\nThe MSBuild target to build. (``/t:<TARGET>``)\n\n### PLATFORM\nThe platform (``/p:Platform`` msbuild parameter) used for the build.\n\n### PLATFORM_TOOLSET\nThe platform toolset (``/p:PlatformToolset`` msbuild parameter) used for the build.\n\n### OPTIONS\nAdditional options passed to msbuild for all builds.\n\n### OPTIONS_RELEASE\nAdditional options passed to msbuild for Release builds. These are in addition to `OPTIONS`.\n\n### OPTIONS_DEBUG\nAdditional options passed to msbuild for Debug builds. These are in addition to `OPTIONS`.\n\n## Examples\n\n* [chakracore](https://github.com/Microsoft/vcpkg/blob/master/ports/chakracore/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_build\\_msbuild.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_build_msbuild.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_build_ninja.html","Name":"vcpkg_build_ninja","Source":"# vcpkg_build_ninja\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_build_ninja.md).\n\nBuild a ninja project\n\n## Usage:\n```cmake\nvcpkg_build_ninja(\n    [TARGETS <target>...]\n)\n```\n\n## Parameters:\n### TARGETS\nOnly build the specified targets.\n\n## Source\n[scripts/cmake/vcpkg\\_build\\_ninja.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_build_ninja.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_build_nmake.html","Name":"vcpkg_build_nmake","Source":"# vcpkg_build_nmake\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_build_nmake.md).\n\nBuild a msvc makefile project.\n\n## Usage:\n```cmake\nvcpkg_build_nmake(\n    SOURCE_PATH <${SOURCE_PATH}>\n    [NO_DEBUG]\n    [TARGET <all>]\n    [PROJECT_SUBPATH <${SUBPATH}>]\n    [PROJECT_NAME <${MAKEFILE_NAME}>]\n    [PRERUN_SHELL <${SHELL_PATH}>]\n    [PRERUN_SHELL_DEBUG <${SHELL_PATH}>]\n    [PRERUN_SHELL_RELEASE <${SHELL_PATH}>]\n    [OPTIONS <-DUSE_THIS_IN_ALL_BUILDS=1>...]\n    [OPTIONS_RELEASE <-DOPTIMIZE=1>...]\n    [OPTIONS_DEBUG <-DDEBUGGABLE=1>...]\n    [TARGET <target>])\n```\n\n## Parameters\n### SOURCE_PATH\nSpecifies the directory containing the source files.\nBy convention, this is usually set in the portfile as the variable `SOURCE_PATH`.\n\n### PROJECT_SUBPATH\nSpecifies the sub directory containing the `makefile.vc`/`makefile.mak`/`makefile.msvc` or other msvc makefile.\n\n### PROJECT_NAME\nSpecifies the name of msvc makefile name.\nDefault is `makefile.vc`\n\n### NO_DEBUG\nThis port doesn't support debug mode.\n\n### ENABLE_INSTALL\nInstall binaries after build.\n\n### PRERUN_SHELL\nScript that needs to be called before build\n\n### PRERUN_SHELL_DEBUG\nScript that needs to be called before debug build\n\n### PRERUN_SHELL_RELEASE\nScript that needs to be called before release build\n\n### OPTIONS\nAdditional options passed to generate during the generation.\n\n### OPTIONS_RELEASE\nAdditional options passed to generate during the Release generation. These are in addition to `OPTIONS`.\n\n### OPTIONS_DEBUG\nAdditional options passed to generate during the Debug generation. These are in addition to `OPTIONS`.\n\n### TARGET\nThe target passed to the nmake build command (`nmake/nmake install`). If not specified, no target will\nbe passed.\n\n### ADD_BIN_TO_PATH\nAdds the appropriate Release and Debug `bin\\` directories to the path during the build such that executables can run against the in-tree DLLs.\n\n## Notes:\nThis command should be preceded by a call to [`vcpkg_configure_nmake()`](vcpkg_configure_nmake.md).\nYou can use the alias [`vcpkg_install_nmake()`](vcpkg_install_nmake.md) function if your makefile supports the\n\"install\" target\n\n## Examples\n\n* [tcl](https://github.com/Microsoft/vcpkg/blob/master/ports/tcl/portfile.cmake)\n* [freexl](https://github.com/Microsoft/vcpkg/blob/master/ports/freexl/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_build\\_nmake.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_build_nmake.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_build_qmake.html","Name":"vcpkg_build_qmake","Source":"# vcpkg_build_qmake\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_build_qmake.md).\n\nBuild a qmake-based project, previously configured using vcpkg_configure_qmake.\n\n```cmake\nvcpkg_build_qmake()\n```\n\n## Source\n[scripts/cmake/vcpkg\\_build\\_qmake.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_build_qmake.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_buildpath_length_warning.html","Name":"vcpkg_buildpath_length_warning","Source":"# vcpkg_buildpath_length_warning\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_buildpath_length_warning.md).\n\nWarns the user if their vcpkg installation path might be too long for the package they're installing.\n\n```cmake\nvcpkg_buildpath_length_warning(<N>)\n```\n\n`vcpkg_buildpath_length_warning` warns the user if the number of bytes in the\npath to `buildtrees` is bigger than `N`. Note that this is simply a warning,\nand isn't relied on for correctness.\n\n## Source\n[scripts/cmake/vcpkg\\_buildpath\\_length\\_warning.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_buildpath_length_warning.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_check_features.html","Name":"vcpkg_check_features","Source":"# vcpkg_check_features\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_check_features.md).\nCheck if one or more features are a part of a package installation.\n\n```cmake\nvcpkg_check_features(\n    OUT_FEATURE_OPTIONS <out-var>\n    [PREFIX <prefix>]\n    [FEATURES\n        [<feature-name> <feature-var>]...\n        ]\n    [INVERTED_FEATURES\n        [<feature-name> <feature-var>]...\n        ]\n)\n```\n\nThe `<out-var>` should be set to `FEATURE_OPTIONS` by convention.\n\n`vcpkg_check_features()` will:\n\n- for each `<feature-name>` passed in `FEATURES`:\n    - if the feature is set, add `-D<feature-var>=ON` to `<out-var>`,\n      and set `<prefix>_<feature-var>` to ON.\n    - if the feature is not set, add `-D<feature-var>=OFF` to `<out-var>`,\n      and set `<prefix>_<feature-var>` to OFF.\n- for each `<feature-name>` passed in `INVERTED_FEATURES`:\n    - if the feature is set, add `-D<feature-var>=OFF` to `<out-var>`,\n      and set `<prefix>_<feature-var>` to OFF.\n    - if the feature is not set, add `-D<feature-var>=ON` to `<out-var>`,\n      and set `<prefix>_<feature-var>` to ON.\n\nIf `<prefix>` is not passed, then the feature vars set are simply `<feature-var>`,\nnot `_<feature-var>`.\n\nIf `INVERTED_FEATURES` is not passed, then the `FEATURES` keyword is optional.\nThis behavior is deprecated.\n\nIf the same `<feature-var>` is passed multiple times,\nthen `vcpkg_check_features` will cause a fatal error,\nsince that is a bug.\n\n## Examples\n\n### Example 1: Regular features\n\n```cmake\n$ ./vcpkg install mimalloc[asm,secure]\n\n# ports/mimalloc/portfile.cmake\nvcpkg_check_features(OUT_FEATURE_OPTIONS FEATURE_OPTIONS\n    FEATURES\n        asm       MI_SEE_ASM\n        override  MI_OVERRIDE\n        secure    MI_SECURE\n)\n\nvcpkg_configure_cmake(\n    SOURCE_PATH ${SOURCE_PATH}\n    PREFER_NINJA\n    OPTIONS\n        # Expands to \"-DMI_SEE_ASM=ON;-DMI_OVERRIDE=OFF;-DMI_SECURE=ON\"\n        ${FEATURE_OPTIONS}\n)\n```\n\n### Example 2: Inverted features\n\n```cmake\n$ ./vcpkg install cpprestsdk[websockets]\n\n# ports/cpprestsdk/portfile.cmake\nvcpkg_check_features(\n    INVERTED_FEATURES\n        brotli      CPPREST_EXCLUDE_BROTLI\n        websockets  CPPREST_EXCLUDE_WEBSOCKETS\n)\n\nvcpkg_configure_cmake(\n    SOURCE_PATH ${SOURCE_PATH}\n    PREFER_NINJA\n    OPTIONS\n        # Expands to \"-DCPPREST_EXCLUDE_BROTLI=ON;-DCPPREST_EXCLUDE_WEBSOCKETS=OFF\"\n        ${FEATURE_OPTIONS}\n)\n```\n\n### Example 3: Set multiple options for same feature\n\n```cmake\n$ ./vcpkg install pcl[cuda]\n\n# ports/pcl/portfile.cmake\nvcpkg_check_features(\n    FEATURES\n        cuda  WITH_CUDA\n        cuda  BUILD_CUDA\n        cuda  BUILD_GPU\n)\n\nvcpkg_configure_cmake(\n    SOURCE_PATH ${SOURCE_PATH}\n    PREFER_NINJA\n    OPTIONS\n        # Expands to \"-DWITH_CUDA=ON;-DBUILD_CUDA=ON;-DBUILD_GPU=ON\"\n        ${FEATURE_OPTIONS}\n)\n```\n\n### Example 4: Use regular and inverted features\n\n```cmake\n$ ./vcpkg install rocksdb[tbb]\n\n# ports/rocksdb/portfile.cmake\nvcpkg_check_features(\n    FEATURES\n        tbb   WITH_TBB\n    INVERTED_FEATURES\n        tbb   ROCKSDB_IGNORE_PACKAGE_TBB\n)\n\nvcpkg_configure_cmake(\n    SOURCE_PATH ${SOURCE_PATH}\n    PREFER_NINJA\n    OPTIONS\n        # Expands to \"-DWITH_TBB=ON;-DROCKSDB_IGNORE_PACKAGE_TBB=OFF\"\n        ${FEATURE_OPTIONS}\n)\n```\n\n## Examples in portfiles\n\n* [cpprestsdk](https://github.com/microsoft/vcpkg/blob/master/ports/cpprestsdk/portfile.cmake)\n* [pcl](https://github.com/microsoft/vcpkg/blob/master/ports/pcl/portfile.cmake)\n* [rocksdb](https://github.com/microsoft/vcpkg/blob/master/ports/rocksdb/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_check\\_features.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_check_features.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_check_linkage.html","Name":"vcpkg_check_linkage","Source":"# vcpkg_check_linkage\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_check_linkage.md).\n\nAsserts the available library and CRT linkage options for the port.\n\n## Usage\n```cmake\nvcpkg_check_linkage(\n    [ONLY_STATIC_LIBRARY | ONLY_DYNAMIC_LIBRARY]\n    [ONLY_STATIC_CRT | ONLY_DYNAMIC_CRT]\n)\n```\n\n## Parameters\n### ONLY_STATIC_LIBRARY\nIndicates that this port can only be built with static library linkage.\n\nNote: If the user requested a dynamic build ONLY_STATIC_LIBRARY will result in a note being printed, not a fatal error.\n\n### ONLY_DYNAMIC_LIBRARY\nIndicates that this port can only be built with dynamic/shared library linkage.\n\n### ONLY_STATIC_CRT\nIndicates that this port can only be built with static CRT linkage.\n\n### ONLY_DYNAMIC_CRT\nIndicates that this port can only be built with dynamic/shared CRT linkage.\n\n## Notes\nThis command will either alter the settings for `VCPKG_LIBRARY_LINKAGE` or fail, depending on what was requested by the user versus what the library supports.\n\n## Examples\n\n* [abseil](https://github.com/Microsoft/vcpkg/blob/master/ports/abseil/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_check\\_linkage.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_check_linkage.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_clean_executables_in_bin.html","Name":"vcpkg_clean_executables_in_bin","Source":"# vcpkg_clean_executables_in_bin\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_clean_executables_in_bin.md).\n\nRemove specified executables found in `${CURRENT_PACKAGES_DIR}/bin` and `${CURRENT_PACKAGES_DIR}/debug/bin`. If, after all specified executables have been removed, and the `bin` and `debug/bin` directories are empty, then also delete `bin` and `debug/bin` directories.\n\n## Usage\n```cmake\nvcpkg_clean_executables_in_bin(\n    FILE_NAMES <file1>...\n)\n```\n\n## Parameters\n### FILE_NAMES\nA list of executable filenames without extension.\n\n## Notes\nGenerally, there is no need to call this function manually. Instead, pass an extra `AUTO_CLEAN` argument when calling `vcpkg_copy_tools`.\n\n## Examples\n* [czmq](https://github.com/microsoft/vcpkg/blob/master/ports/czmq/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_clean\\_executables\\_in\\_bin.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_clean_executables_in_bin.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_clean_msbuild.html","Name":"vcpkg_clean_msbuild","Source":"# vcpkg_clean_msbuild\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_clean_msbuild.md).\n\nClean intermediate files generated by `vcpkg_install_msbuild()`.\n\n## Usage\n```cmake\nvcpkg_clean_msbuild()\n```\n\n## Examples\n\n* [python3](https://github.com/Microsoft/vcpkg/blob/master/ports/python3/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_clean\\_msbuild.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_clean_msbuild.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_common_definitions.html","Name":"vcpkg_common_definitions","Source":"# vcpkg_common_definitions\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_common_definitions.md).\n\nThis file defines the following variables which are commonly needed or used in portfiles:\n\n```cmake\nVCPKG_TARGET_IS_<target>                 with <target> being one of the following: WINDOWS, UWP, LINUX, OSX, ANDROID, FREEBSD, OPENBSD. only defined if <target>\nVCPKG_HOST_IS_<target>                   with <host> being one of the following: WINDOWS, LINUX, OSX, FREEBSD, OPENBSD. only defined if <host>\nVCPKG_HOST_PATH_SEPARATOR                Host specific path separator (USAGE: \"<something>${VCPKG_HOST_PATH_SEPARATOR}<something>\"; only use and pass variables with VCPKG_HOST_PATH_SEPARATOR within \"\")\nVCPKG_HOST_EXECUTABLE_SUFFIX             executable suffix of the host\nVCPKG_TARGET_EXECUTABLE_SUFFIX           executable suffix of the target\nVCPKG_TARGET_STATIC_LIBRARY_PREFIX       static library prefix for target (same as CMAKE_STATIC_LIBRARY_PREFIX)\nVCPKG_TARGET_STATIC_LIBRARY_SUFFIX       static library suffix for target (same as CMAKE_STATIC_LIBRARY_SUFFIX)\nVCPKG_TARGET_SHARED_LIBRARY_PREFIX       shared library prefix for target (same as CMAKE_SHARED_LIBRARY_PREFIX)\nVCPKG_TARGET_SHARED_LIBRARY_SUFFIX       shared library suffix for target (same as CMAKE_SHARED_LIBRARY_SUFFIX)\nVCPKG_TARGET_IMPORT_LIBRARY_PREFIX       import library prefix for target (same as CMAKE_IMPORT_LIBRARY_PREFIX)\nVCPKG_TARGET_IMPORT_LIBRARY_SUFFIX       import library suffix for target (same as CMAKE_IMPORT_LIBRARY_SUFFIX)\nVCPKG_FIND_LIBRARY_PREFIXES              target dependent prefixes used for find_library calls in portfiles\nVCPKG_FIND_LIBRARY_SUFFIXES              target dependent suffixes used for find_library calls in portfiles\nVCPKG_SYSTEM_LIBRARIES                   list of libraries are provide by the toolchain and are not managed by vcpkg\nTARGET_TRIPLET                           the name of the current triplet to build for\nCURRENT_INSTALLED_DIR                    the absolute path to the installed files for the current triplet\nHOST_TRIPLET                             the name of the triplet corresponding to the host\nCURRENT_HOST_INSTALLED_DIR               the absolute path to the installed files for the host triplet\nVCPKG_CROSSCOMPILING                     Whether vcpkg is cross-compiling: in other words, whether TARGET_TRIPLET and HOST_TRIPLET are different\n```\n\nCMAKE_STATIC_LIBRARY_(PREFIX|SUFFIX), CMAKE_SHARED_LIBRARY_(PREFIX|SUFFIX) and CMAKE_IMPORT_LIBRARY_(PREFIX|SUFFIX) are defined for the target\nFurthermore the variables CMAKE_FIND_LIBRARY_(PREFIXES|SUFFIXES) are also defined for the target so that\nportfiles are able to use find_library calls to discover dependent libraries within the current triplet for ports.\n\n## Source\n[scripts/cmake/vcpkg\\_common\\_definitions.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_common_definitions.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_configure_cmake.html","Name":"vcpkg_configure_cmake","Source":"# vcpkg_configure_cmake\n\n**This function has been deprecated in favor of [`vcpkg_cmake_configure`](ports/vcpkg-cmake/vcpkg_cmake_configure.md) from the vcpkg-cmake port.**\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_configure_cmake.md).\n\nConfigure CMake for Debug and Release builds of a project.\n\n## Usage\n```cmake\nvcpkg_configure_cmake(\n    SOURCE_PATH <${SOURCE_PATH}>\n    [PREFER_NINJA]\n    [DISABLE_PARALLEL_CONFIGURE]\n    [NO_CHARSET_FLAG]\n    [GENERATOR <\"NMake Makefiles\">]\n    [OPTIONS <-DUSE_THIS_IN_ALL_BUILDS=1>...]\n    [OPTIONS_RELEASE <-DOPTIMIZE=1>...]\n    [OPTIONS_DEBUG <-DDEBUGGABLE=1>...]\n    [MAYBE_UNUSED_VARIABLES <OPTION_NAME>...]\n)\n```\n\n## Parameters\n### SOURCE_PATH\nSpecifies the directory containing the `CMakeLists.txt`.\nBy convention, this is usually set in the portfile as the variable `SOURCE_PATH`.\n\n### PREFER_NINJA\nIndicates that, when available, Vcpkg should use Ninja to perform the build.\nThis should be specified unless the port is known to not work under Ninja.\n\n### DISABLE_PARALLEL_CONFIGURE\nDisables running the CMake configure step in parallel.\nThis is needed for libraries which write back into their source directory during configure.\n\nThis also disables CMAKE_DISABLE_SOURCE_CHANGES.\n\n### NO_CHARSET_FLAG\nDisables passing `utf-8` as the default character set to `CMAKE_C_FLAGS` and `CMAKE_CXX_FLAGS`.\n\nThis is needed for libraries that set their own source code's character set.\n\n### GENERATOR\nSpecifies the precise generator to use.\n\nThis is useful if some project-specific buildsystem has been wrapped in a cmake script that won't perform an actual build.\nIf used for this purpose, it should be set to `\"NMake Makefiles\"`.\n\n### OPTIONS\nAdditional options passed to CMake during the configuration.\n\n### OPTIONS_RELEASE\nAdditional options passed to CMake during the Release configuration. These are in addition to `OPTIONS`.\n\n### OPTIONS_DEBUG\nAdditional options passed to CMake during the Debug configuration. These are in addition to `OPTIONS`.\n\n### MAYBE_UNUSED_VARIABLES\nAny CMake variables which are explicitly passed in, but which may not be used on all platforms.\nFor example:\n```cmake\nvcpkg_cmake_configure(\n    ...\n    OPTIONS\n        -DBUILD_EXAMPLE=OFF\n    ...\n    MAYBE_UNUSED_VARIABLES\n        BUILD_EXAMPLE\n)\n```\n\n### LOGNAME\nName of the log to write the output of the configure call to.\n\n## Notes\nThis command supplies many common arguments to CMake. To see the full list, examine the source.\n\n## Examples\n\n* [zlib](https://github.com/Microsoft/vcpkg/blob/master/ports/zlib/portfile.cmake)\n* [cpprestsdk](https://github.com/Microsoft/vcpkg/blob/master/ports/cpprestsdk/portfile.cmake)\n* [poco](https://github.com/Microsoft/vcpkg/blob/master/ports/poco/portfile.cmake)\n* [opencv](https://github.com/Microsoft/vcpkg/blob/master/ports/opencv/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_configure\\_cmake.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_configure_cmake.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_configure_gn.html","Name":"vcpkg_configure_gn","Source":"# vcpkg_configure_gn\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_configure_gn.md).\n\nGenerate Ninja (GN) targets\n\n## Usage:\n```cmake\nvcpkg_configure_gn(\n    SOURCE_PATH <SOURCE_PATH>\n    [OPTIONS <OPTIONS>]\n    [OPTIONS_DEBUG <OPTIONS_DEBUG>]\n    [OPTIONS_RELEASE <OPTIONS_RELEASE>]\n)\n```\n\n## Parameters:\n### SOURCE_PATH (required)\nThe path to the GN project.\n\n### OPTIONS\nOptions to be passed to both the debug and release targets.\nNote: Must be provided as a space-separated string.\n\n### OPTIONS_DEBUG (space-separated string)\nOptions to be passed to the debug target.\n\n### OPTIONS_RELEASE (space-separated string)\nOptions to be passed to the release target.\n\n## Source\n[scripts/cmake/vcpkg\\_configure\\_gn.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_configure_gn.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_configure_make.html","Name":"vcpkg_configure_make","Source":"# vcpkg_configure_make\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_configure_make.md).\n\nConfigure configure for Debug and Release builds of a project.\n\n## Usage\n```cmake\nvcpkg_configure_make(\n    SOURCE_PATH <${SOURCE_PATH}>\n    [AUTOCONFIG]\n    [USE_WRAPPERS]\n    [DETERMINE_BUILD_TRIPLET]\n    [BUILD_TRIPLET \"--host=x64 --build=i686-unknown-pc\"]\n    [NO_ADDITIONAL_PATHS]\n    [CONFIG_DEPENDENT_ENVIRONMENT <SOME_VAR>...]\n    [CONFIGURE_ENVIRONMENT_VARIABLES <SOME_ENVVAR>...]\n    [ADD_BIN_TO_PATH]\n    [NO_DEBUG]\n    [SKIP_CONFIGURE]\n    [PROJECT_SUBPATH <${PROJ_SUBPATH}>]\n    [PRERUN_SHELL <${SHELL_PATH}>]\n    [OPTIONS <-DUSE_THIS_IN_ALL_BUILDS=1>...]\n    [OPTIONS_RELEASE <-DOPTIMIZE=1>...]\n    [OPTIONS_DEBUG <-DDEBUGGABLE=1>...]\n)\n```\n\n## Parameters\n### SOURCE_PATH\nSpecifies the directory containing the `configure`/`configure.ac`.\nBy convention, this is usually set in the portfile as the variable `SOURCE_PATH`.\n\n### PROJECT_SUBPATH\nSpecifies the directory containing the ``configure`/`configure.ac`.\nBy convention, this is usually set in the portfile as the variable `SOURCE_PATH`.\n\n### SKIP_CONFIGURE\nSkip configure process\n\n### USE_WRAPPERS\nUse autotools ar-lib and compile wrappers (only applies to windows cl and lib)\n\n### BUILD_TRIPLET\nUsed to pass custom --build/--target/--host to configure. Can be globally overwritten by VCPKG_MAKE_BUILD_TRIPLET\n\n### DETERMINE_BUILD_TRIPLET\nFor ports having a configure script following the autotools rules for selecting the triplet\n\n### NO_ADDITIONAL_PATHS\nDon't pass any additional paths except for --prefix to the configure call\n\n### AUTOCONFIG\nNeed to use autoconfig to generate configure file.\n\n### PRERUN_SHELL\nScript that needs to be called before configuration (do not use for batch files which simply call autoconf or configure)\n\n### ADD_BIN_TO_PATH\nAdds the appropriate Release and Debug `bin\\` directories to the path during configure such that executables can run against the in-tree DLLs.\n\n## DISABLE_VERBOSE_FLAGS\ndo not pass '--disable-silent-rules --verbose' to configure\n\n### OPTIONS\nAdditional options passed to configure during the configuration.\n\n### OPTIONS_RELEASE\nAdditional options passed to configure during the Release configuration. These are in addition to `OPTIONS`.\n\n### OPTIONS_DEBUG\nAdditional options passed to configure during the Debug configuration. These are in addition to `OPTIONS`.\n\n### CONFIG_DEPENDENT_ENVIRONMENT\nList of additional configuration dependent environment variables to set. \nPass SOMEVAR to set the environment and have SOMEVAR_(DEBUG|RELEASE) set in the portfile to the appropriate values\nGeneral environment variables can be set from within the portfile itself. \n\n### CONFIGURE_ENVIRONMENT_VARIABLES\nList of additional environment variables to pass via the configure call. \n\n## Notes\nThis command supplies many common arguments to configure. To see the full list, examine the source.\n\n## Examples\n\n* [x264](https://github.com/Microsoft/vcpkg/blob/master/ports/x264/portfile.cmake)\n* [tcl](https://github.com/Microsoft/vcpkg/blob/master/ports/tcl/portfile.cmake)\n* [freexl](https://github.com/Microsoft/vcpkg/blob/master/ports/freexl/portfile.cmake)\n* [libosip2](https://github.com/Microsoft/vcpkg/blob/master/ports/libosip2/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_configure\\_make.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_configure_make.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_configure_meson.html","Name":"vcpkg_configure_meson","Source":"# vcpkg_configure_meson\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_configure_meson.md).\n\nConfigure Meson for Debug and Release builds of a project.\n\n## Usage\n```cmake\nvcpkg_configure_meson(\n    SOURCE_PATH <${SOURCE_PATH}>\n    [OPTIONS <-DUSE_THIS_IN_ALL_BUILDS=1>...]\n    [OPTIONS_RELEASE <-DOPTIMIZE=1>...]\n    [OPTIONS_DEBUG <-DDEBUGGABLE=1>...]\n)\n```\n\n## Parameters\n### SOURCE_PATH\nSpecifies the directory containing the `meson.build`.\nBy convention, this is usually set in the portfile as the variable `SOURCE_PATH`.\n\n### OPTIONS\nAdditional options passed to Meson during the configuration.\n\n### OPTIONS_RELEASE\nAdditional options passed to Meson during the Release configuration. These are in addition to `OPTIONS`.\n\n### OPTIONS_DEBUG\nAdditional options passed to Meson during the Debug configuration. These are in addition to `OPTIONS`.\n\n## Notes\nThis command supplies many common arguments to Meson. To see the full list, examine the source.\n\n## Examples\n\n* [fribidi](https://github.com/Microsoft/vcpkg/blob/master/ports/fribidi/portfile.cmake)\n* [libepoxy](https://github.com/Microsoft/vcpkg/blob/master/ports/libepoxy/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_configure\\_meson.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_configure_meson.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_configure_qmake.html","Name":"vcpkg_configure_qmake","Source":"# vcpkg_configure_qmake\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_configure_qmake.md).\n\nConfigure a qmake-based project.\n\n```cmake\nvcpkg_configure_qmake(\n    SOURCE_PATH <pro_file_path>\n    [OPTIONS arg1 [arg2 ...]]\n    [OPTIONS_RELEASE arg1 [arg2 ...]]\n    [OPTIONS_DEBUG arg1 [arg2 ...]]\n)\n```\n\n### SOURCE_PATH\nThe path to the *.pro qmake project file.\n\n### OPTIONS, OPTIONS\\_RELEASE, OPTIONS\\_DEBUG\nThe options passed to qmake.\n\n## Source\n[scripts/cmake/vcpkg\\_configure\\_qmake.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_configure_qmake.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_copy_pdbs.html","Name":"vcpkg_copy_pdbs","Source":"# vcpkg_copy_pdbs\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_copy_pdbs.md).\n\nAutomatically locate pdbs in the build tree and copy them adjacent to all DLLs.\n\n```cmake\nvcpkg_copy_pdbs(\n    [BUILD_PATHS <glob>...])\n```\n\nThe `<glob>`s are patterns which will be passed to `file(GLOB_RECURSE)`,\nfor locating DLLs. It defaults to using:\n\n- `${CURRENT_PACKAGES_DIR}/bin/*.dll`\n- `${CURRENT_PACKAGES_DIR}/debug/bin/*.dll`\n\nsince that is generally where DLLs are located.\n\n## Notes\nThis command should always be called by portfiles after they have finished rearranging the binary output.\n\n## Examples\n\n* [zlib](https://github.com/Microsoft/vcpkg/blob/master/ports/zlib/portfile.cmake)\n* [cpprestsdk](https://github.com/Microsoft/vcpkg/blob/master/ports/cpprestsdk/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_copy\\_pdbs.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_copy_pdbs.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_copy_tool_dependencies.html","Name":"vcpkg_copy_tool_dependencies","Source":"# vcpkg_copy_tool_dependencies\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_copy_tool_dependencies.md).\n\nCopy all DLL dependencies of built tools into the tool folder.\n\n## Usage\n```cmake\nvcpkg_copy_tool_dependencies(<${CURRENT_PACKAGES_DIR}/tools/${PORT}>)\n```\n## Parameters\nThe path to the directory containing the tools.\n\n## Notes\nThis command should always be called by portfiles after they have finished rearranging the binary output, if they have any tools.\n\n## Examples\n\n* [glib](https://github.com/Microsoft/vcpkg/blob/master/ports/glib/portfile.cmake)\n* [fltk](https://github.com/Microsoft/vcpkg/blob/master/ports/fltk/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_copy\\_tool\\_dependencies.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_copy_tool_dependencies.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_copy_tools.html","Name":"vcpkg_copy_tools","Source":"# vcpkg_copy_tools\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_copy_tools.md).\n\nCopy tools and all their DLL dependencies into the `tools` folder.\n\n## Usage\n```cmake\nvcpkg_copy_tools(\n    TOOL_NAMES <tool1>...\n    [SEARCH_DIR <${CURRENT_PACKAGES_DIR}/bin>]\n    [DESTINATION <${CURRENT_PACKAGES_DIR}/tools/${PORT}>]\n    [AUTO_CLEAN]\n)\n```\n## Parameters\n### TOOL_NAMES\nA list of tool filenames without extension.\n\n### SEARCH_DIR\nThe path to the directory containing the tools. This will be set to `${CURRENT_PACKAGES_DIR}/bin` if omitted.\n\n### DESTINATION\nDestination to copy the tools to. This will be set to `${CURRENT_PACKAGES_DIR}/tools/${PORT}` if omitted.\n\n### AUTO_CLEAN\nAuto clean executables in `${CURRENT_PACKAGES_DIR}/bin` and `${CURRENT_PACKAGES_DIR}/debug/bin`.\n\n## Examples\n\n* [cpuinfo](https://github.com/microsoft/vcpkg/blob/master/ports/cpuinfo/portfile.cmake)\n* [nanomsg](https://github.com/microsoft/vcpkg/blob/master/ports/nanomsg/portfile.cmake)\n* [uriparser](https://github.com/microsoft/vcpkg/blob/master/ports/uriparser/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_copy\\_tools.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_copy_tools.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_download_distfile.html","Name":"vcpkg_download_distfile","Source":"# vcpkg_download_distfile\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_download_distfile.md).\n\nDownload and cache a file needed for this port.\n\nThis helper should always be used instead of CMake's built-in `file(DOWNLOAD)` command.\n\n## Usage\n```cmake\nvcpkg_download_distfile(\n    <OUT_VARIABLE>\n    URLS <http://mainUrl> <http://mirror1>...\n    FILENAME <output.zip>\n    SHA512 <5981de...>\n    [ALWAYS_REDOWNLOAD]\n)\n```\n## Parameters\n### OUT_VARIABLE\nThis variable will be set to the full path to the downloaded file. This can then immediately be passed in to [`vcpkg_extract_source_archive`](vcpkg_extract_source_archive.md) for sources.\n\n### URLS\nA list of URLs to be consulted. They will be tried in order until one of the downloaded files successfully matches the SHA512 given.\n\n### FILENAME\nThe local name for the file. Files are shared between ports, so the file may need to be renamed to make it clearly attributed to this port and avoid conflicts.\n\n### SHA512\nThe expected hash for the file.\n\nIf this doesn't match the downloaded version, the build will be terminated with a message describing the mismatch.\n\n### QUIET\nSuppress output on cache hit\n\n### SKIP_SHA512\nSkip SHA512 hash check for file.\n\nThis switch is only valid when building with the `--head` command line flag.\n\n### ALWAYS_REDOWNLOAD\nAvoid caching; this is a REST call or otherwise unstable.\n\nRequires `SKIP_SHA512`.\n\n### HEADERS\nA list of headers to append to the download request. This can be used for authentication during a download.\n\nHeaders should be specified as \"<header-name>: <header-value>\".\n\n## Notes\nThe helper [`vcpkg_from_github`](vcpkg_from_github.md) should be used for downloading from GitHub projects.\n\n## Examples\n\n* [apr](https://github.com/Microsoft/vcpkg/blob/master/ports/apr/portfile.cmake)\n* [fontconfig](https://github.com/Microsoft/vcpkg/blob/master/ports/fontconfig/portfile.cmake)\n* [freetype](https://github.com/Microsoft/vcpkg/blob/master/ports/freetype/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_download\\_distfile.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_download_distfile.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_execute_build_process.html","Name":"vcpkg_execute_build_process","Source":"# vcpkg_execute_build_process\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_execute_build_process.md).\n\nExecute a required build process\n\n## Usage\n```cmake\nvcpkg_execute_build_process(\n    COMMAND <cmd> [<args>...]\n    [NO_PARALLEL_COMMAND <cmd> [<args>...]]\n    WORKING_DIRECTORY </path/to/dir>\n    LOGNAME <log_name>\n)\n```\n## Parameters\n### COMMAND\nThe command to be executed, along with its arguments.\n\n### NO_PARALLEL_COMMAND\nOptional parameter which specifies a non-parallel command to attempt if a\nfailure potentially due to parallelism is detected.\n\n### WORKING_DIRECTORY\nThe directory to execute the command in.\n\n### LOGNAME\nThe prefix to use for the log files.\n\nThis should be a unique name for different triplets so that the logs don't\nconflict when building multiple at once.\n\n## Examples\n\n* [icu](https://github.com/Microsoft/vcpkg/blob/master/ports/icu/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_execute\\_build\\_process.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_execute_build_process.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_execute_in_download_mode.html","Name":"vcpkg_execute_in_download_mode","Source":"# vcpkg_execute_in_download_mode\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_execute_in_download_mode.md).\n\nExecute a process even in download mode.\n\n## Usage\n```cmake\nvcpkg_execute_in_download_mode(\n    ...\n)\n```\n\nThe signature of this function is identical to `execute_process()`.\n\nSee [`execute_process()`] for more details.\n\n[`execute_process()`]: https://cmake.org/cmake/help/latest/command/execute_process.html\n\n## Source\n[scripts/cmake/vcpkg\\_execute\\_in\\_download\\_mode.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_execute_in_download_mode.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_execute_required_process.html","Name":"vcpkg_execute_required_process","Source":"# vcpkg_execute_required_process\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_execute_required_process.md).\n\nExecute a process with logging and fail the build if the command fails.\n\n## Usage\n```cmake\nvcpkg_execute_required_process(\n    COMMAND <${PERL}> [<arguments>...]\n    WORKING_DIRECTORY <${CURRENT_BUILDTREES_DIR}/${TARGET_TRIPLET}-dbg>\n    LOGNAME <build-${TARGET_TRIPLET}-dbg>\n    [TIMEOUT <seconds>]\n    [OUTPUT_VARIABLE <var>]\n    [ERROR_VARIABLE <var>]\n)\n```\n## Parameters\n### ALLOW_IN_DOWNLOAD_MODE\nAllows the command to execute in Download Mode.\n[See execute_process() override](../../scripts/cmake/execute_process.cmake).\n\n### COMMAND\nThe command to be executed, along with its arguments.\n\n### WORKING_DIRECTORY\nThe directory to execute the command in.\n\n### LOGNAME\nThe prefix to use for the log files.\n\n### TIMEOUT\nOptional timeout after which to terminate the command.\n\n### OUTPUT_VARIABLE\nOptional variable to receive stdout of the command.\n\n### ERROR_VARIABLE\nOptional variable to receive stderr of the command.\n\nThis should be a unique name for different triplets so that the logs don't conflict when building multiple at once.\n\n## Examples\n\n* [ffmpeg](https://github.com/Microsoft/vcpkg/blob/master/ports/ffmpeg/portfile.cmake)\n* [openssl](https://github.com/Microsoft/vcpkg/blob/master/ports/openssl/portfile.cmake)\n* [boost](https://github.com/Microsoft/vcpkg/blob/master/ports/boost/portfile.cmake)\n* [qt5](https://github.com/Microsoft/vcpkg/blob/master/ports/qt5/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_execute\\_required\\_process.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_execute_required_process.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_execute_required_process_repeat.html","Name":"vcpkg_execute_required_process_repeat","Source":"# vcpkg_execute_required_process_repeat\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_execute_required_process_repeat.md).\n\nExecute a process until the command succeeds, or until the COUNT is reached.\n\n## Usage\n```cmake\nvcpkg_execute_required_process_repeat(\n    COMMAND <cmd> [<arguments>]\n    COUNT <num>\n    WORKING_DIRECTORY <directory>\n    LOGNAME <name>\n    [ALLOW_IN_DOWNLOAD_MODE]\n)\n```\n\n## Source\n[scripts/cmake/vcpkg\\_execute\\_required\\_process\\_repeat.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_execute_required_process_repeat.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_extract_source_archive.html","Name":"vcpkg_extract_source_archive","Source":"# vcpkg_extract_source_archive\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_extract_source_archive.md).\n\nExtract an archive into the source directory.\n\n## Usage\nThere are two \"overloads\" of this function. The first is deprecated:\n\n```cmake\nvcpkg_extract_source_archive(<${ARCHIVE}> [<${TARGET_DIRECTORY}>])\n```\n\nThis overload should not be used.\n\nThe latter is suggested to use for all future `vcpkg_extract_source_archive`s.\n\n```cmake\nvcpkg_extract_source_archive(<out-var>\n    ARCHIVE <path>\n    [NO_REMOVE_ONE_LEVEL]\n    [PATCHES <patch>...]\n    [SOURCE_BASE <base>]\n    [BASE_DIRECTORY <relative-path> | WORKING_DIRECTORY <absolute-path>]\n)\n```\n\n`vcpkg_extract_source_archive` takes an archive and extracts it.\nIt replaces existing uses of `vcpkg_extract_source_archive_ex`.\nThe simplest use of it is:\n\n```cmake\nvcpkg_download_distfile(archive ...)\nvcpkg_extract_source_archive(source_path ARCHIVE \"${archive}\")\n```\n\nThe general expectation is that an archives are laid out with a base directory,\nand all the actual files underneath that directory; in other words, if you\nextract the archive, you'll get something that looks like:\n\n```\nzlib-1.2.11/\n    doc/\n        ...\n    examples/\n        ...\n    ChangeLog\n    CMakeLists.txt\n    README\n    zlib.h\n    ...\n```\n\n`vcpkg_extract_source_archive` automatically removes this directory,\nand gives you the items under it directly. However, this only works\nwhen there is exactly one item in the top level of an archive.\nOtherwise, you'll have to pass the `NO_REMOVE_ONE_LEVEL` argument to\nprevent `vcpkg_extract_source_archive` from performing this transformation.\n\nIf the source needs to be patched in some way, the `PATCHES` argument\nallows one to do this, just like other `vcpkg_from_*` functions.\n\n`vcpkg_extract_source_archive` extracts the files to\n`${CURRENT_BUILDTREES_DIR}/<base-directory>/<source-base>-<hash>.clean`.\nWhen in editable mode, no `.clean` is appended,\nto allow for a user to modify the sources.\n`base-directory` defaults to `src`,\nand `source-base` defaults to the stem of `<archive>`.\nYou can change these via the `BASE_DIRECTORY` and `SOURCE_BASE` arguments\nrespectively.\nIf you need to extract to a location that is not based in `CURRENT_BUILDTREES_DIR`,\nyou can use the `WORKING_DIRECTORY` argument to do the same.\n\n## Examples\n\n* [libraw](https://github.com/Microsoft/vcpkg/blob/master/ports/libraw/portfile.cmake)\n* [protobuf](https://github.com/Microsoft/vcpkg/blob/master/ports/protobuf/portfile.cmake)\n* [msgpack](https://github.com/Microsoft/vcpkg/blob/master/ports/msgpack/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_extract\\_source\\_archive.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_extract_source_archive.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_extract_source_archive_ex.html","Name":"vcpkg_extract_source_archive_ex","Source":"# vcpkg_extract_source_archive_ex\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_extract_source_archive_ex.md).\n\nExtract an archive into the source directory.\nOriginally replaced [`vcpkg_extract_source_archive()`],\nbut new ports should instead use the second overload of\n[`vcpkg_extract_source_archive()`].\n\n## Usage\n```cmake\nvcpkg_extract_source_archive_ex(\n    [OUT_SOURCE_PATH <source_path>]\n    ...\n)\n```\n\nSee the documentation for [`vcpkg_extract_source_archive()`] for other parameters.\nAdditionally, `vcpkg_extract_source_archive_ex()` adds the `REF` and `WORKING_DIRECTORY`\nparameters, which are wrappers around `SOURCE_BASE` and `BASE_DIRECTORY`\nrespectively.\n\n[`vcpkg_extract_source_archive()`]: vcpkg_extract_source_archive.md\n\n## Source\n[scripts/cmake/vcpkg\\_extract\\_source\\_archive\\_ex.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_extract_source_archive_ex.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_fail_port_install.html","Name":"vcpkg_fail_port_install","Source":"# vcpkg_fail_port_install\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_fail_port_install.md).\n\nChecks common requirements and fails the current portfile with a (default) error message\n\n## Usage\n```cmake\nvcpkg_fail_port_install(\n    [ALWAYS]\n    [MESSAGE <\"Reason for failure\">]\n    [ON_TARGET <Windows> [<OSX> ...]]\n    [ON_ARCH <x64> [<arm> ...]]\n    [ON_CRT_LINKAGE <static> [<dynamic> ...]])\n    [ON_LIBRARY_LINKAGE <static> [<dynamic> ...]]\n)\n```\n\n## Parameters\n### MESSAGE\nAdditional failure message. If none is given, a default message will be displayed depending on the failure condition.\n\n### ALWAYS\nWill always fail early\n\n### ON_TARGET\nTargets for which the build should fail early. Valid targets are `<target>` from `VCPKG_IS_TARGET_<target>` (see `vcpkg_common_definitions.cmake`).\n\n### ON_ARCH\nArchitecture for which the build should fail early.\n\n### ON_CRT_LINKAGE\nCRT linkage for which the build should fail early.\n\n### ON_LIBRARY_LINKAGE\nLibrary linkage for which the build should fail early.\n\n## Examples\n\n* [aws-lambda-cpp](https://github.com/Microsoft/vcpkg/blob/master/ports/aws-lambda-cpp/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_fail\\_port\\_install.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_fail_port_install.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_find_acquire_program.html","Name":"vcpkg_find_acquire_program","Source":"# vcpkg_find_acquire_program\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_find_acquire_program.md).\n\nDownload or find a well-known tool.\n\n## Usage\n```cmake\nvcpkg_find_acquire_program(<VAR>)\n```\n## Parameters\n### VAR\nThis variable specifies both the program to be acquired as well as the out parameter that will be set to the path of the program executable.\n\n## Notes\nThe current list of programs includes:\n\n* 7Z\n* ARIA2 (Downloader)\n* BISON\n* CLANG\n* DARK\n* DOXYGEN\n* FLEX\n* GASPREPROCESSOR\n* GPERF\n* PERL\n* PYTHON2\n* PYTHON3\n* GIT\n* GN\n* GO\n* JOM\n* MESON\n* NASM\n* NINJA\n* NUGET\n* SCONS\n* SWIG\n* YASM\n\nNote that msys2 has a dedicated helper function: [`vcpkg_acquire_msys`](vcpkg_acquire_msys.md).\n\n## Examples\n\n* [ffmpeg](https://github.com/Microsoft/vcpkg/blob/master/ports/ffmpeg/portfile.cmake)\n* [openssl](https://github.com/Microsoft/vcpkg/blob/master/ports/openssl/portfile.cmake)\n* [qt5](https://github.com/Microsoft/vcpkg/blob/master/ports/qt5/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_find\\_acquire\\_program.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_find_acquire_program.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_find_fortran.html","Name":"vcpkg_find_fortran","Source":"# vcpkg_find_fortran\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_find_fortran.md).\n\nChecks if a Fortran compiler can be found.\nWindows(x86/x64) Only: If not it will switch/enable MinGW gfortran \n                       and return required cmake args for building. \n\n## Usage\n```cmake\nvcpkg_find_fortran(<additional_cmake_args_out>)\n```\n\n## Source\n[scripts/cmake/vcpkg\\_find\\_fortran.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_find_fortran.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_fixup_cmake_targets.html","Name":"vcpkg_fixup_cmake_targets","Source":"# vcpkg_fixup_cmake_targets\n\n**This function has been deprecated in favor of [`vcpkg_cmake_config_fixup`](ports/vcpkg-cmake-config/vcpkg_cmake_config_fixup.md) from the vcpkg-cmake-config port.**\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_fixup_cmake_targets.md).\n\nMerge release and debug CMake targets and configs to support multiconfig generators.\n\nAdditionally corrects common issues with targets, such as absolute paths and incorrectly placed binaries.\n\n## Usage\n```cmake\nvcpkg_fixup_cmake_targets([CONFIG_PATH <share/${PORT}>] \n                          [TARGET_PATH <share/${PORT}>] \n                          [TOOLS_PATH <tools/${PORT}>]\n                          [DO_NOT_DELETE_PARENT_CONFIG_PATH])\n```\n\n## Parameters\n\n### CONFIG_PATH\nSubpath currently containing `*.cmake` files subdirectory (like `lib/cmake/${PORT}`). Should be relative to `${CURRENT_PACKAGES_DIR}`.\n\nDefaults to `share/${PORT}`.\n\n### TARGET_PATH\nSubpath to which the above `*.cmake` files should be moved. Should be relative to `${CURRENT_PACKAGES_DIR}`.\nThis needs to be specified if the port name differs from the `find_package()` name.\n\nDefaults to `share/${PORT}`.\n\n### DO_NOT_DELETE_PARENT_CONFIG_PATH\nBy default the parent directory of CONFIG_PATH is removed if it is named \"cmake\".\nPassing this option disable such behavior, as it is convenient for ports that install\nmore than one CMake package configuration file.\n\n### NO_PREFIX_CORRECTION\nDisables the correction of_IMPORT_PREFIX done by vcpkg due to moving the targets.\nCurrently the correction does not take into account how the files are moved and applies\nI rather simply correction which in some cases will yield the wrong results.\n\n### TOOLS_PATH\nDefine the base path to tools. Default: `tools/<PORT>`\n\n## Notes\nTransform all `/debug/<CONFIG_PATH>/*targets-debug.cmake` files and move them to `/<TARGET_PATH>`.\nRemoves all `/debug/<CONFIG_PATH>/*targets.cmake` and `/debug/<CONFIG_PATH>/*config.cmake`.\n\nTransform all references matching `/bin/*.exe` to `/${TOOLS_PATH}/*.exe` on Windows.\nTransform all references matching `/bin/*` to `/${TOOLS_PATH}/*`  on other platforms.\n\nFix `${_IMPORT_PREFIX}` in auto generated targets to be one folder deeper.\nReplace `${CURRENT_INSTALLED_DIR}` with `${_IMPORT_PREFIX}` in configs and targets.\n\n## Examples\n\n* [concurrentqueue](https://github.com/Microsoft/vcpkg/blob/master/ports/concurrentqueue/portfile.cmake)\n* [curl](https://github.com/Microsoft/vcpkg/blob/master/ports/curl/portfile.cmake)\n* [nlohmann-json](https://github.com/Microsoft/vcpkg/blob/master/ports/nlohmann-json/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_fixup\\_cmake\\_targets.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_fixup_cmake_targets.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_fixup_pkgconfig.html","Name":"vcpkg_fixup_pkgconfig","Source":"# vcpkg_fixup_pkgconfig\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_fixup_pkgconfig.md).\n\nFix common paths in *.pc files and make everything relative to $(prefix).\nAdditionally, on static triplets, private entries are merged with their non-private counterparts,\nallowing pkg-config to be called without the ``--static`` flag.\nNote that vcpkg is designed to never have to call pkg-config with the ``--static`` flag,\nsince a consumer cannot know if a dependent library has been built statically or not.\n\n## Usage\n```cmake\nvcpkg_fixup_pkgconfig(\n    [RELEASE_FILES <PATHS>...]\n    [DEBUG_FILES <PATHS>...]\n    [SKIP_CHECK]\n)\n```\n\n## Parameters\n### RELEASE_FILES\nSpecifies a list of files to apply the fixes for release paths.\nDefaults to every *.pc file in the folder ${CURRENT_PACKAGES_DIR} without ${CURRENT_PACKAGES_DIR}/debug/\n\n### DEBUG_FILES\nSpecifies a list of files to apply the fixes for debug paths.\nDefaults to every *.pc file in the folder ${CURRENT_PACKAGES_DIR}/debug/\n\n### SKIP_CHECK\nSkips the library checks in vcpkg_fixup_pkgconfig. Only use if the script itself has unhandled cases.\n\n### SYSTEM_PACKAGES (deprecated)\nThis argument has been deprecated and has no effect.\n\n### SYSTEM_LIBRARIES (deprecated)\nThis argument has been deprecated and has no effect.\n\n### IGNORE_FLAGS (deprecated)\nThis argument has been deprecated and has no effect.\n\n## Notes\nStill work in progress. If there are more cases which can be handled here feel free to add them\n\n## Examples\n\n* [brotli](https://github.com/Microsoft/vcpkg/blob/master/ports/brotli/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_fixup\\_pkgconfig.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_fixup_pkgconfig.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_from_bitbucket.html","Name":"vcpkg_from_bitbucket","Source":"# vcpkg_from_bitbucket\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_from_bitbucket.md).\n\nDownload and extract a project from Bitbucket.\n\n## Usage:\n```cmake\nvcpkg_from_bitbucket(\n    OUT_SOURCE_PATH <SOURCE_PATH>\n    REPO <Microsoft/cpprestsdk>\n    [REF <v2.0.0>]\n    [SHA512 <45d0d7f8cc350...>]\n    [HEAD_REF <master>]\n    [PATCHES <patch1.patch> <patch2.patch>...]\n)\n```\n\n## Parameters:\n### OUT_SOURCE_PATH\nSpecifies the out-variable that will contain the extracted location.\n\nThis should be set to `SOURCE_PATH` by convention.\n\n### REPO\nThe organization or user and repository on GitHub.\n\n### REF\nA stable git commit-ish (ideally a tag) that will not change contents. **This should not be a branch.**\n\nFor repositories without official releases, this can be set to the full commit id of the current latest master.\n\nIf `REF` is specified, `SHA512` must also be specified.\n\n### SHA512\nThe SHA512 hash that should match the archive (https://bitbucket.com/${REPO}/get/${REF}.tar.gz).\n\nThis is most easily determined by first setting it to `0`, then trying to build the port. The error message will contain the full hash, which can be copied back into the portfile.\n\n### HEAD_REF\nThe unstable git commit-ish (ideally a branch) to pull for `--head` builds.\n\nFor most projects, this should be `master`. The chosen branch should be one that is expected to be always buildable on all supported platforms.\n\n### PATCHES\nA list of patches to be applied to the extracted sources.\n\nRelative paths are based on the port directory.\n\n## Notes:\nAt least one of `REF` and `HEAD_REF` must be specified, however it is preferable for both to be present.\n\nThis exports the `VCPKG_HEAD_VERSION` variable during head builds.\n\n## Examples:\n\n* [blaze](https://github.com/Microsoft/vcpkg/blob/master/ports/blaze/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_from\\_bitbucket.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_from_bitbucket.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_from_git.html","Name":"vcpkg_from_git","Source":"# vcpkg_from_git\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_from_git.md).\n\nDownload and extract a project from git\n\n## Usage:\n```cmake\nvcpkg_from_git(\n    OUT_SOURCE_PATH <SOURCE_PATH>\n    URL <https://android.googlesource.com/platform/external/fdlibm>\n    REF <59f7335e4d...>\n    [HEAD_REF <ref>]\n    [PATCHES <patch1.patch> <patch2.patch>...]\n)\n```\n\n## Parameters:\n### OUT_SOURCE_PATH\nSpecifies the out-variable that will contain the extracted location.\n\nThis should be set to `SOURCE_PATH` by convention.\n\n### URL\nThe url of the git repository.\n\n### REF\nThe git sha of the commit to download.\n\n### HEAD_REF\nThe git branch to use when the package is requested to be built from the latest sources.\n\nExample: `main`, `develop`, `HEAD`\n\n### PATCHES\nA list of patches to be applied to the extracted sources.\n\nRelative paths are based on the port directory.\n\n## Notes:\n`OUT_SOURCE_PATH`, `REF`, and `URL` must be specified.\n\n## Examples:\n\n* [fdlibm](https://github.com/Microsoft/vcpkg/blob/master/ports/fdlibm/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_from\\_git.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_from_git.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_from_github.html","Name":"vcpkg_from_github","Source":"# vcpkg_from_github\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_from_github.md).\n\nDownload and extract a project from GitHub. Enables support for `install --head`.\n\n## Usage:\n```cmake\nvcpkg_from_github(\n    OUT_SOURCE_PATH <SOURCE_PATH>\n    REPO <Microsoft/cpprestsdk>\n    [REF <v2.0.0>]\n    [SHA512 <45d0d7f8cc350...>]\n    [HEAD_REF <master>]\n    [PATCHES <patch1.patch> <patch2.patch>...]\n    [GITHUB_HOST <https://github.com>]\n    [AUTHORIZATION_TOKEN <${SECRET_FROM_FILE}>]\n    [FILE_DISAMBIGUATOR <N>]\n)\n```\n\n## Parameters:\n### OUT_SOURCE_PATH\nSpecifies the out-variable that will contain the extracted location.\n\nThis should be set to `SOURCE_PATH` by convention.\n\n### REPO\nThe organization or user and repository on GitHub.\n\n### REF\nA stable git commit-ish (ideally a tag or commit) that will not change contents. **This should not be a branch.**\n\nFor repositories without official releases, this can be set to the full commit id of the current latest master.\n\nIf `REF` is specified, `SHA512` must also be specified.\n\n### SHA512\nThe SHA512 hash that should match the archive (https://github.com/${REPO}/archive/${REF}.tar.gz).\n\nThis is most easily determined by first setting it to `0`, then trying to build the port. The error message will contain the full hash, which can be copied back into the portfile.\n\n### HEAD_REF\nThe unstable git commit-ish (ideally a branch) to pull for `--head` builds.\n\nFor most projects, this should be `master`. The chosen branch should be one that is expected to be always buildable on all supported platforms.\n\n### PATCHES\nA list of patches to be applied to the extracted sources.\n\nRelative paths are based on the port directory.\n\n### GITHUB_HOST\nA replacement host for enterprise GitHub instances.\n\nThis field should contain the scheme, host, and port of the desired URL without a trailing slash.\n\n### AUTHORIZATION_TOKEN\nA token to be passed via the Authorization HTTP header as \"token ${AUTHORIZATION_TOKEN}\".\n\n### FILE_DISAMBIGUATOR\nA token to uniquely identify the resulting filename if the SHA512 changes even though a git ref does not, to avoid stepping on the same file name.\n\n## Notes:\nAt least one of `REF` and `HEAD_REF` must be specified, however it is preferable for both to be present.\n\nThis exports the `VCPKG_HEAD_VERSION` variable during head builds.\n\n## Examples:\n\n* [cpprestsdk](https://github.com/Microsoft/vcpkg/blob/master/ports/cpprestsdk/portfile.cmake)\n* [ms-gsl](https://github.com/Microsoft/vcpkg/blob/master/ports/ms-gsl/portfile.cmake)\n* [boost-beast](https://github.com/Microsoft/vcpkg/blob/master/ports/boost-beast/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_from\\_github.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_from_github.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_from_gitlab.html","Name":"vcpkg_from_gitlab","Source":"# vcpkg_from_gitlab\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_from_gitlab.md).\n\nDownload and extract a project from Gitlab instances. Enables support for `install --head`.\n\n## Usage:\n```cmake\nvcpkg_from_gitlab(\n    GITLAB_URL <https://gitlab.com>\n    OUT_SOURCE_PATH <SOURCE_PATH>\n    REPO <gitlab-org/gitlab-ce>\n    [REF <v10.7.3>]\n    [SHA512 <45d0d7f8cc350...>]\n    [HEAD_REF <master>]\n    [PATCHES <patch1.patch> <patch2.patch>...]\n    [FILE_DISAMBIGUATOR <N>]\n)\n```\n\n## Parameters:\n\n### GITLAB_URL\nThe URL of the Gitlab instance to use.\n\n### OUT_SOURCE_PATH\nSpecifies the out-variable that will contain the extracted location.\n\nThis should be set to `SOURCE_PATH` by convention.\n\n### REPO\nThe organization or user plus the repository name on the Gitlab instance.\n\n### REF\nA stable git commit-ish (ideally a tag) that will not change contents. **This should not be a branch.**\n\nFor repositories without official releases, this can be set to the full commit id of the current latest master.\n\nIf `REF` is specified, `SHA512` must also be specified.\n\n### SHA512\nThe SHA512 hash that should match the archive (${GITLAB_URL}/${REPO}/-/archive/${REF}/${REPO_NAME}-${REF}.tar.gz).\nThe REPO_NAME variable is parsed from the value of REPO.\n\nThis is most easily determined by first setting it to `0`, then trying to build the port. The error message will contain the full hash, which can be copied back into the portfile.\n\n### HEAD_REF\nThe unstable git commit-ish (ideally a branch) to pull for `--head` builds.\n\nFor most projects, this should be `master`. The chosen branch should be one that is expected to be always buildable on all supported platforms.\n\n### PATCHES\nA list of patches to be applied to the extracted sources.\n\nRelative paths are based on the port directory.\n\n### FILE_DISAMBIGUATOR\nA token to uniquely identify the resulting filename if the SHA512 changes even though a git ref does not, to avoid stepping on the same file name.\n\n## Notes:\nAt least one of `REF` and `HEAD_REF` must be specified, however it is preferable for both to be present.\n\nThis exports the `VCPKG_HEAD_VERSION` variable during head builds.\n\n## Examples:\n* [curl][https://github.com/Microsoft/vcpkg/blob/master/ports/curl/portfile.cmake#L75]\n* [folly](https://github.com/Microsoft/vcpkg/blob/master/ports/folly/portfile.cmake#L15)\n* [z3](https://github.com/Microsoft/vcpkg/blob/master/ports/z3/portfile.cmake#L13)\n\n## Source\n[scripts/cmake/vcpkg\\_from\\_gitlab.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_from_gitlab.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_from_sourceforge.html","Name":"vcpkg_from_sourceforge","Source":"# vcpkg_from_sourceforge\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_from_sourceforge.md).\n\nDownload and extract a project from sourceforge.\n\nThis function automatically checks a set of sourceforge mirrors.\nAdditional mirrors can be injected through the `VCPKG_SOURCEFORGE_EXTRA_MIRRORS`\nlist variable in the triplet.\n\n## Usage:\n```cmake\nvcpkg_from_sourceforge(\n    OUT_SOURCE_PATH SOURCE_PATH\n    REPO <cunit/CUnit>\n    [REF <2.1-3>]\n    SHA512 <547b417109332...>\n    FILENAME <CUnit-2.1-3.tar.bz2>\n    [DISABLE_SSL]\n    [NO_REMOVE_ONE_LEVEL]\n    [PATCHES <patch1.patch> <patch2.patch>...]\n)\n```\n\n## Parameters:\n### OUT_SOURCE_PATH\nSpecifies the out-variable that will contain the extracted location.\n\nThis should be set to `SOURCE_PATH` by convention.\n\n### REPO\nThe organization or user and repository (optional) on sourceforge.\n\n### REF\nA stable version number that will not change contents.\n\n### FILENAME\nThe local name for the file. Files are shared between ports, so the file may need to be renamed to make it clearly attributed to this port and avoid conflicts.\n\nFor example, we can get the download link:\nhttps://sourceforge.net/settings/mirror_choices?projectname=mad&filename=libmad/0.15.1b/libmad-0.15.1b.tar.gz&selected=nchc\nSo the REPO is `mad/libmad`, the REF is `0.15.1b`, and the FILENAME is `libmad-0.15.1b.tar.gz`\n\nFor some special links:\nhttps://sourceforge.net/settings/mirror_choices?projectname=soxr&filename=soxr-0.1.3-Source.tar.xz&selected=nchc\nThe REPO is `soxr`, REF is not exist, and the FILENAME is `soxr-0.1.3-Source.tar.xz`\n\n### SHA512\nThe SHA512 hash that should match the archive.\n\nThis is most easily determined by first setting it to `0`, then trying to build the port. The error message will contain the full hash, which can be copied back into the portfile.\n\n### WORKING_DIRECTORY\nIf specified, the archive will be extracted into the working directory instead of `${CURRENT_BUILDTREES_DIR}/src/`.\n\nNote that the archive will still be extracted into a subfolder underneath that directory (`${WORKING_DIRECTORY}/${REF}-${HASH}/`).\n\n### PATCHES\nA list of patches to be applied to the extracted sources.\n\nRelative paths are based on the port directory.\n\n### NO_REMOVE_ONE_LEVEL\nSpecifies that the default removal of the top level folder should not occur.\n\n## Examples:\n\n* [cunit](https://github.com/Microsoft/vcpkg/blob/master/ports/cunit/portfile.cmake)\n* [polyclipping](https://github.com/Microsoft/vcpkg/blob/master/ports/polyclipping/portfile.cmake)\n* [tinyfiledialogs](https://github.com/Microsoft/vcpkg/blob/master/ports/tinyfiledialogs/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_from\\_sourceforge.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_from_sourceforge.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_get_program_files_platform_bitness.html","Name":"vcpkg_get_program_files_platform_bitness","Source":"# vcpkg_get_program_files_platform_bitness\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_get_program_files_platform_bitness.md).\n\nGet the Program Files directory of the current platform's bitness:\neither `$ENV{ProgramW6432}` on 64-bit windows,\nor `$ENV{PROGRAMFILES}` on 32-bit windows.\n\n## Usage:\n```cmake\nvcpkg_get_program_files_platform_bitness(<variable>)\n```\n\n## Source\n[scripts/cmake/vcpkg\\_get\\_program\\_files\\_platform\\_bitness.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_get_program_files_platform_bitness.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_get_windows_sdk.html","Name":"vcpkg_get_windows_sdk","Source":"# vcpkg_get_windows_sdk\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_get_windows_sdk.md).\n\nGet the Windows SDK number.\n\n## Usage:\n```cmake\nvcpkg_get_windows_sdk(<variable>)\n```\n\n## Source\n[scripts/cmake/vcpkg\\_get\\_windows\\_sdk.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_get_windows_sdk.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_install_cmake.html","Name":"vcpkg_install_cmake","Source":"# vcpkg_install_cmake\n\n**This function has been deprecated in favor of [`vcpkg_cmake_install`](ports/vcpkg-cmake/vcpkg_cmake_install.md) from the vcpkg-cmake port.**\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_install_cmake.md).\n\nBuild and install a cmake project.\n\n## Usage:\n```cmake\nvcpkg_install_cmake(...)\n```\n\n## Parameters:\nSee [`vcpkg_build_cmake()`](vcpkg_build_cmake.md).\n\n## Notes:\nThis command transparently forwards to [`vcpkg_build_cmake()`](vcpkg_build_cmake.md), adding a `TARGET install`\nparameter.\n\n## Examples:\n\n* [zlib](https://github.com/Microsoft/vcpkg/blob/master/ports/zlib/portfile.cmake)\n* [cpprestsdk](https://github.com/Microsoft/vcpkg/blob/master/ports/cpprestsdk/portfile.cmake)\n* [poco](https://github.com/Microsoft/vcpkg/blob/master/ports/poco/portfile.cmake)\n* [opencv](https://github.com/Microsoft/vcpkg/blob/master/ports/opencv/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_install\\_cmake.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_install_cmake.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_install_gn.html","Name":"vcpkg_install_gn","Source":"# vcpkg_install_gn\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_install_gn.md).\n\nInstalls a GN project.\n\nIn order to build a GN project without installing, use [`vcpkg_build_ninja()`].\n\n## Usage:\n```cmake\nvcpkg_install_gn(\n     SOURCE_PATH <SOURCE_PATH>\n     [TARGETS <target>...]\n)\n```\n\n## Parameters:\n### SOURCE_PATH\nThe path to the source directory\n\n### TARGETS\nOnly install the specified targets.\n\nNote: includes must be handled separately\n\n[`vcpkg_build_ninja()`]: vcpkg_build_ninja.md\n\n## Source\n[scripts/cmake/vcpkg\\_install\\_gn.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_install_gn.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_install_make.html","Name":"vcpkg_install_make","Source":"# vcpkg_install_make\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_install_make.md).\n\nBuild and install a make project.\n\n## Usage:\n```cmake\nvcpkg_install_make(...)\n```\n\n## Parameters:\nSee [`vcpkg_build_make()`](vcpkg_build_make.md).\n\n## Notes:\nThis command transparently forwards to [`vcpkg_build_make()`](vcpkg_build_make.md), adding `ENABLE_INSTALL`\n\n## Examples\n\n* [x264](https://github.com/Microsoft/vcpkg/blob/master/ports/x264/portfile.cmake)\n* [tcl](https://github.com/Microsoft/vcpkg/blob/master/ports/tcl/portfile.cmake)\n* [freexl](https://github.com/Microsoft/vcpkg/blob/master/ports/freexl/portfile.cmake)\n* [libosip2](https://github.com/Microsoft/vcpkg/blob/master/ports/libosip2/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_install\\_make.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_install_make.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_install_meson.html","Name":"vcpkg_install_meson","Source":"# vcpkg_install_meson\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_install_meson.md).\n\nBuilds a meson project previously configured with `vcpkg_configure_meson()`.\n\n## Usage\n```cmake\nvcpkg_install_meson([ADD_BIN_TO_PATH])\n```\n\n## Parameters:\n### ADD_BIN_TO_PATH\nAdds the appropriate Release and Debug `bin\\` directories to the path during the build such that executables can run against the in-tree DLLs.\n\n## Examples\n\n* [fribidi](https://github.com/Microsoft/vcpkg/blob/master/ports/fribidi/portfile.cmake)\n* [libepoxy](https://github.com/Microsoft/vcpkg/blob/master/ports/libepoxy/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_install\\_meson.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_install_meson.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_install_msbuild.html","Name":"vcpkg_install_msbuild","Source":"# vcpkg_install_msbuild\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_install_msbuild.md).\n\nBuild and install a msbuild-based project. This replaces `vcpkg_build_msbuild()`.\n\n## Usage\n```cmake\nvcpkg_install_msbuild(\n    SOURCE_PATH <${SOURCE_PATH}>\n    PROJECT_SUBPATH <port.sln>\n    [INCLUDES_SUBPATH <include>]\n    [LICENSE_SUBPATH <LICENSE>]\n    [RELEASE_CONFIGURATION <Release>]\n    [DEBUG_CONFIGURATION <Debug>]\n    [TARGET <Build>]\n    [TARGET_PLATFORM_VERSION <10.0.15063.0>]\n    [PLATFORM <${TRIPLET_SYSTEM_ARCH}>]\n    [PLATFORM_TOOLSET <${VCPKG_PLATFORM_TOOLSET}>]\n    [OPTIONS </p:ZLIB_INCLUDE_PATH=X>...]\n    [OPTIONS_RELEASE </p:ZLIB_LIB=X>...]\n    [OPTIONS_DEBUG </p:ZLIB_LIB=X>...]\n    [USE_VCPKG_INTEGRATION]\n    [ALLOW_ROOT_INCLUDES | REMOVE_ROOT_INCLUDES]\n)\n```\n\n## Parameters\n### SOURCE_PATH\nThe path to the root of the source tree.\n\nBecause MSBuild uses in-source builds, the source tree will be copied into a temporary location for the build. This\nparameter is the base for that copy and forms the base for all XYZ_SUBPATH options.\n\n### USE_VCPKG_INTEGRATION\nApply the normal `integrate install` integration for building the project.\n\nBy default, projects built with this command will not automatically link libraries or have header paths set.\n\n### PROJECT_SUBPATH\nThe subpath to the solution (`.sln`) or project (`.vcxproj`) file relative to `SOURCE_PATH`.\n\n### LICENSE_SUBPATH\nThe subpath to the license file relative to `SOURCE_PATH`.\n\n### INCLUDES_SUBPATH\nThe subpath to the includes directory relative to `SOURCE_PATH`.\n\nThis parameter should be a directory and should not end in a trailing slash.\n\n### ALLOW_ROOT_INCLUDES\nIndicates that top-level include files (e.g. `include/zlib.h`) should be allowed.\n\n### REMOVE_ROOT_INCLUDES\nIndicates that top-level include files (e.g. `include/Makefile.am`) should be removed.\n\n### SKIP_CLEAN\nIndicates that the intermediate files should not be removed.\n\nPorts using this option should later call [`vcpkg_clean_msbuild()`](vcpkg_clean_msbuild.md) to manually clean up.\n\n### RELEASE_CONFIGURATION\nThe configuration (``/p:Configuration`` msbuild parameter) used for Release builds.\n\n### DEBUG_CONFIGURATION\nThe configuration (``/p:Configuration`` msbuild parameter) used for Debug builds.\n\n### TARGET_PLATFORM_VERSION\nThe WindowsTargetPlatformVersion (``/p:WindowsTargetPlatformVersion`` msbuild parameter)\n\n### TARGET\nThe MSBuild target to build. (``/t:<TARGET>``)\n\n### PLATFORM\nThe platform (``/p:Platform`` msbuild parameter) used for the build.\n\n### PLATFORM_TOOLSET\nThe platform toolset (``/p:PlatformToolset`` msbuild parameter) used for the build.\n\n### OPTIONS\nAdditional options passed to msbuild for all builds.\n\n### OPTIONS_RELEASE\nAdditional options passed to msbuild for Release builds. These are in addition to `OPTIONS`.\n\n### OPTIONS_DEBUG\nAdditional options passed to msbuild for Debug builds. These are in addition to `OPTIONS`.\n\n## Examples\n\n* [libirecovery](https://github.com/Microsoft/vcpkg/blob/master/ports/libirecovery/portfile.cmake)\n* [libfabric](https://github.com/Microsoft/vcpkg/blob/master/ports/libfabric/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_install\\_msbuild.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_install_msbuild.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_install_nmake.html","Name":"vcpkg_install_nmake","Source":"# vcpkg_install_nmake\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_install_nmake.md).\n\nBuild and install a msvc makefile project.\n\n## Usage:\n```cmake\nvcpkg_install_nmake(\n    SOURCE_PATH <${SOURCE_PATH}>\n    [NO_DEBUG]\n    [TARGET <all>]\n    PROJECT_SUBPATH <${SUBPATH}>\n    PROJECT_NAME <${MAKEFILE_NAME}>\n    [PRERUN_SHELL <${SHELL_PATH}>]\n    [PRERUN_SHELL_DEBUG <${SHELL_PATH}>]\n    [PRERUN_SHELL_RELEASE <${SHELL_PATH}>]\n    [OPTIONS <-DUSE_THIS_IN_ALL_BUILDS=1>...]\n    [OPTIONS_RELEASE <-DOPTIMIZE=1>...]\n    [OPTIONS_DEBUG <-DDEBUGGABLE=1>...]\n```\n\n## Parameters\n### SOURCE_PATH\nSpecifies the directory containing the source files.\nBy convention, this is usually set in the portfile as the variable `SOURCE_PATH`.\n\n### PROJECT_SUBPATH\nSpecifies the sub directory containing the `makefile.vc`/`makefile.mak`/`makefile.msvc` or other msvc makefile.\n\n### PROJECT_NAME\nSpecifies the name of msvc makefile name.\nDefault is makefile.vc\n\n### NO_DEBUG\nThis port doesn't support debug mode.\n\n### PRERUN_SHELL\nScript that needs to be called before build\n\n### PRERUN_SHELL_DEBUG\nScript that needs to be called before debug build\n\n### PRERUN_SHELL_RELEASE\nScript that needs to be called before release build\n\n### OPTIONS\nAdditional options passed to generate during the generation.\n\n### OPTIONS_RELEASE\nAdditional options passed to generate during the Release generation. These are in addition to `OPTIONS`.\n\n### OPTIONS_DEBUG\nAdditional options passed to generate during the Debug generation. These are in addition to `OPTIONS`.\n\n## Parameters:\nSee [`vcpkg_build_nmake()`](vcpkg_build_nmake.md).\n\n## Notes:\nThis command transparently forwards to [`vcpkg_build_nmake()`](vcpkg_build_nmake.md), adding `ENABLE_INSTALL`\n\n## Examples\n\n* [tcl](https://github.com/Microsoft/vcpkg/blob/master/ports/tcl/portfile.cmake)\n* [freexl](https://github.com/Microsoft/vcpkg/blob/master/ports/freexl/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_install\\_nmake.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_install_nmake.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_install_qmake.html","Name":"vcpkg_install_qmake","Source":"# vcpkg_install_qmake\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_install_qmake.md).\n\nBuild and install a qmake project.\n\n## Usage:\n```cmake\nvcpkg_install_qmake(...)\n```\n\n## Parameters:\nSee [`vcpkg_build_qmake()`](vcpkg_build_qmake.md).\n\n## Notes:\nThis command transparently forwards to [`vcpkg_build_qmake()`](vcpkg_build_qmake.md).\n\nAdditionally, this command will copy produced .libs/.dlls/.as/.dylibs/.sos to the appropriate\nstaging directories.\n\n## Examples\n\n* [libqglviewer](https://github.com/Microsoft/vcpkg/blob/master/ports/libqglviewer/portfile.cmake)\n\n## Source\n[scripts/cmake/vcpkg\\_install\\_qmake.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_install_qmake.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_list.html","Name":"vcpkg_list","Source":"# vcpkg_list\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_list.md).\n\nA replacement for CMake's `list()` function, which correctly handles elements\nwith internal semicolons (in other words, escaped semicolons).\nUse `vcpkg_list()` instead of `list()` whenever possible.\n\n```cmake\nvcpkg_list(SET <out-var> [<element>...])\nvcpkg_list(<COMMAND> <list-var> [<other-arguments>...])\n```\n\nIn addition to all of the commands from `list()`, `vcpkg_list` adds\na `vcpkg_list(SET)` command.\nThis command takes its arguments, escapes them, and then concatenates\nthem into a list; this should be used instead of `set()` for setting any\nlist variable.\n\nOtherwise, the `vcpkg_list()` function is the same as the built-in\n`list()` function, with the following restrictions:\n\n- `GET`, `REMOVE_ITEM`, and `REMOVE_AT` support only one index/value\n- `POP_BACK` and `POP_FRONT` do not support getting the value into\n  another out variable. Use C++ style `GET` then `POP_(BACK|FRONT)`.\n- `FILTER` and `TRANSFORM` are unsupported.\n\nSee the [CMake documentation for `list()`](https://cmake.org/cmake/help/latest/command/list.html)\nfor more information.\n\n## Notes: Some Weirdnesses\n\nThe most major weirdness is due to `\"\"` pulling double-duty as \"list of zero elements\",\nand \"list of one element, which is empty\". `vcpkg_list` always uses the former understanding.\nThis can cause weird behavior, for example:\n\n```cmake\nset(lst \"\")\nvcpkg_list(APPEND lst \"\" \"\")\n# lst = \";\"\n```\n\nThis is because you're appending two elements to the empty list.\nOne very weird behavior that comes out of this would be:\n\n```cmake\nset(lst \"\")\nvcpkg_list(APPEND lst \"\")\n# lst = \"\"\n```\n\nsince `\"\"` is the empty list, we append the empty element and end up with a list\nof one element, which is empty. This does not happen for non-empty lists;\nfor example:\n\n```cmake\nset(lst \"a\")\nvcpkg_list(APPEND lst \"\")\n# lst = \"a;\"\n```\n\nonly the empty list has this odd behavior.\n\n## Examples\n\n### Creating a list\n\n```cmake\nvcpkg_list(SET foo_param)\nif(DEFINED arg_FOO)\n    vcpkg_list(SET foo_param FOO \"${arg_FOO}\")\nendif()\n```\n\n### Appending to a list\n\n```cmake\nset(OPTIONS -DFOO=BAR)\nif(VCPKG_TARGET_IS_WINDOWS)\n    vcpkg_list(APPEND OPTIONS \"-DOS=WINDOWS;FOO\")\nendif()\n```\n\n### Popping the end off a list\n\n```cmake\nif(NOT list STREQUAL \"\")\n    vcpkg_list(GET list end -1)\n    vcpkg_list(POP_BACK list)\nendif()\n```\n\n## Source\n[scripts/cmake/vcpkg\\_list.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_list.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_minimum_required.html","Name":"vcpkg_minimum_required","Source":"# vcpkg_minimum_required\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_minimum_required.md).\n\nAsserts that the version of the vcpkg program being used to build a port is later than the supplied date, inclusive.\n\n## Usage\n```cmake\nvcpkg_minimum_required(VERSION 2021-01-13)\n```\n\n## Parameters\n### VERSION\nThe date-version to check against.\n\n## Source\n[scripts/cmake/vcpkg\\_minimum\\_required.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_minimum_required.cmake)\n","Nav":"#"},{"Path":"/en/docs/maintainers/vcpkg_replace_string.html","Name":"vcpkg_replace_string","Source":"# vcpkg_replace_string\n\nThe latest version of this document lives in the [vcpkg repo](https://github.com/Microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_replace_string.md).\n\nReplace a string in a file.\n\n```cmake\nvcpkg_replace_string(<filename> <match> <replace>)\n```\n\n## Source\n[scripts/cmake/vcpkg\\_replace\\_string.cmake](https://github.com/Microsoft/vcpkg/blob/master/scripts/cmake/vcpkg_replace_string.cmake)\n","Nav":"#"},{"Path":"/en/docs/specifications/binarycaching.html","Name":"Binarycaching","Source":"# Binary Caching v1.1 (Jul 14, 2020)\r\n\r\n**Note: this is the feature as it was initially specified and does not necessarily reflect the current behavior.**\r\n\r\n**Up-to-date documentation is available at [Binarycaching](../users/binarycaching.md).**\r\n\r\n## Motivation\r\n\r\nThe primary motivation of binary caching is to accelerate two broad scenarios in an easily accessible way\r\n\r\n- Continuous Integration\r\n\r\n- Developer Environment Changes (first-time or branch change)\r\n\r\nWe generally believe both of these scenarios are addressed with the same feature set, however when differences arise they will be discussed in the individual scenarios. \r\n\r\nIt should also be explicitly noted that this specification does not intend to propose a \"Microsoft Sanctioned Public Binaries Service\" such as nuget.org  we only intend to enable users to leverage services they already have access to, such as GitHub, local file shares, Azure Artifacts, etc.\r\n\r\n## Key User Stories\r\n\r\n### CI -> CI\r\n\r\nIn this story, a CI build using either persistent or non-persistent machines wants to potentially reuse binaries built in a previous run of the pipeline. This is partially covered by the Cache tasks in GitHub Actions or Azure DevOps Pipelines, however the Cache task is all-or-nothing: a single package change will prevent restoration and require rebuilding the entire graph which is unacceptable in many scenarios (such as if actively developing one of the packages).\r\n\r\n### CI -> Developer\r\n\r\nIn this story, the developer wants to reuse binaries built during a CI run. Given appropriate CI coverage, most developers will always have any needed dependencies pre-built by the CI system.\r\n\r\nNotably, this scenario indicates a need for Read/Write access granularity on the remote storage solution. Developers should not need write access to the output from the CI system for security reasons.\r\n\r\n### Single Developer (same machine reuse)\r\n\r\nWith the introduction of manifest files, each project will have separate instances of Vcpkg. The performance costs of rebuilding binaries across each cloned project can be debilitating for those working in micro-repos or open source; for the monolithic enterprise developer it is simply frustrating.\r\n\r\nUser-wide binary caching alleviates the pain of this scenario by ensuring the same binaries arent built multiple times (as long as the projects truly overlap with respect to versions/packages/etc).\r\n\r\n### Developer <-> Developer (multi-machine / team scenario)\r\n\r\nIn a small team scenario, it's reasonable that multiple developer machines can trust each other enough to share binaries. This also applies to developers that have multiple machines and wish to share binaries between them (given a similar enough environment).\r\n\r\n## Solution Aspects\r\n\r\n### Tracking Compilers\r\n\r\nIn order to provide reliable binary caching, vcpkg must determine if the produced binaries are appropriate for the current context. Currently, we consider many factors, including:\r\n\r\n- All files in the port directory\r\n\r\n- The toolchain file contents\r\n\r\n- The triplet contents\r\n\r\n- All dependency binaries\r\n\r\n- The version of the CMake tool used to build\r\n\r\nand a few others.\r\n\r\nHowever, we notably do not currently track the compiler used. This is critical for all cross-machine scenarios, as the environment is likely to change incompatibly from machine to machine. We propose hashing the compiler that will used by CMake. This can be accomplished either by reimplementing the logic of CMake or running some partial project and extracting the results. For performance reasons, we will prefer first using heuristics to approximate the CMake logic with accompanying documentation for users that fall outside those bounds.\r\n\r\nAnother aspect of the environment we don't currently track is the CRT version on Linux systems. Currently, we believe this will not cause as many problems in most practices (thus not suitable for an MVP), since the compiler will (generally) link against the system CRT and should sufficiently reflect any differences. This can also be easily worked around by the user with documentation  the toolchain file can simply have a comment such as \"# this uses muslc\", which will cause it to hash differently.\r\n\r\n### Better control over source modifications\r\n\r\nCurrently, vcpkg caches sources inside `buildtrees/$PORT/src/`. The built-in helpers, such as `vcpkg_extract_archive_ex()` assume that if the appropriately named source folder exists, it is true, accurate, and without modification.\r\n\r\nHowever, the basic workflow for working on ports (specifically, developing patches) breaks this assumption by directly editing whatever extracted source directory the tool is currently using until a successful build is achieved. The user then usually builds a patch file from their changes, then checks it in to the port directory (adding the changes to one of the tracked locations above) and everything is restored to normal.\r\n\r\nHowever, this causes serious issues with the current tracking system, because modifications to this cached source are not detected and tracked into the binary package.\r\n\r\nOur proposed solution is to force source re-extraction each time during builds that have uploading to any protocol enabled. Uploading/downloading can then be disabled on the command line via the --editable switch to reuse extracted sources and enable the current workflow.\r\n\r\n### Protocols\r\n\r\nTo service different scenarios and user requirements, we need to support multiple backends. Currently, our CI system uses our only implemented backend: file-based archives.\r\n\r\n#### Backend #1: File-Based Archives\r\n\r\nThis backend simply stores .zip files in a hierarchy similar to git objects: `$VCPKG_ROOT/archives/$XX/$YYYY.zip` with `$XX` being the first two characters of the computed package hash, and `$YYYY` being the full expanded hash. It also supports storing failure logs as `$VCPKG_ROOT/archives/fail/$XX/$YYYY.zip`, however we consider this an internal feature that is not relevant to the key User Stories.\r\n\r\nOur CI system uses this backend by symlinking this directory to an Azure Files share, enabling built binaries and failure logs to be shared by all machines in the pool. Credentials are handled at the time of mounting the Azure Files share, so this does not require interactive authentication.\r\n\r\nThis protocol is ideal due to simplicity for same-machine reuse and simple serverless scenarios such as using networked SMB folders across multiple machines for very small teams. However, it has three significant limitations in the current incarnation:\r\n\r\n- It uses the hardcoded directory `$VCPKG_ROOT/archives` (redirectable using symlinks, but unwieldy)\r\n\r\n- It cannot use multiple directories\r\n\r\n- There is no ability to treat directories as \"read-only\"/immutable\r\n\r\nThese second two points are required to implement the very useful concept of \"fallback\" folders (see https://github.com/NuGet/Home/wiki/%5BSpec%5D-Fallback-package-folders for NuGets spec on this topic).\r\n\r\n#### Backend #2: NuGet (Azure DevOps Artifacts, GitHub Packages, etc)\r\n\r\nThis backend packages binaries into a \"raw\" NuGet package (not suitable for direct import by MSBuild projects) and uploads them to supported NuGet servers such as Azure DevOps Artifacts and GitHub Packages. We believe this will best satisfy the CI scenarios  both CI -> CI as well as CI -> Developer by relying on powerful, centralized, managed hosting.\r\n\r\nThere is a difference in this case between the developer and CI scenarios. The developer generally wants to configure their remotes for the project and then be able to run vcpkg commands as normal, with packages automatically being downloaded and uploaded to optimize the experience. This is similar to File-Based Archives.\r\n\r\nWhile a CI system could use the same workflow as a developer, there are a few key differences. First, a CI system must use a stored secret for authentication, because it cannot interactively authenticate. Second, to enable more complex interactions with systems such as package signing and task-based restores, we must also support a 4-step workflow:\r\n\r\n1. Vcpkg computes hashes of any potentially required packages and writes them to a file\r\n\r\n2. An unspecified service/task/etc can parse this file and download any appropriate packages\r\n\r\n3. vcpkg is then invoked a second time, with any downloaded packages. This consumes the packages, performs any installations and builds, and potentially produces new packages to an output folder.\r\n\r\n4. Finally, another unspecified service/task/etc can take these output packages, sign them, and upload them.\r\n\r\nThis flow enables arbitrarily complex, user-defined authentication and signing schemes, such as the tasks provided by GitHub Actions and Azure DevOps Pipelines or manual signing as documented in the NuGet documentation: https://docs.microsoft.com/en-us/nuget/create-packages/sign-a-package.\r\n\r\n#### Configuration\r\n\r\nCurrently, our file-based backend is enabled by passing the undocumented `--binarycaching` flag to any Vcpkg command or setting the undocumented environment variable `VCPKG_FEATURE_FLAGS` to `binarycaching`. We will replace this feature flag with an on-by-default user-wide behavior, plus command line and environment-based configurability.\r\n\r\nThe on-by-default configuration will specify the file-based archive protocol on either `%LOCALAPPDATA%/vcpkg/archives` (Windows) or `$XDG_CACHE_HOME/vcpkg/archives` (Unix). If `XDG_CACHE_HOME` is not defined on Unix, we will fall back to `$HOME/.cache/vcpkg/archives` based on the [XDG Base Directory Specification][1]. This can be redirected with a symlink, or completely overridden with the command line or environment. In the future we can also consider having a user-wide configuration file, however we do not believe this is important for any of our key scenarios.\r\n\r\nOn the command line, a backend can be specified via `--binarysource=<config>`. Multiple backends can be specified by passing the option multiple times and the order of evaluation is determined by the order on the command line. Writes will be performed on all upload backends, but only for packages that were built as part of this build (the tool will not repackage/reupload binaries downloaded from other sources).\r\n\r\nThe environment variable `VCPKG_BINARY_SOURCES` can be set to a semicolon-delimited list of `<config>`. Empty `<config>` strings are valid and ignored, to support appending like `set VCPKG_BINARY_SOURCES=%VCPKG_BINARY_SOURCES%;foo` or `export VCPKG_BINARY_SOURCES=\"$VCPKG_BINARY_SOURCES;foo\"`\r\n\r\n`<config>` can be any of:\r\n\r\n- `clear` - ignore all lower priority sources (lowest priority is default, then env, then command line)\r\n\r\n- `default[,<readwrite>]` - Reintroduce the default ~/.vcpkg/packages (as read-only or with uploading)\r\n\r\n- `files,<path>[,<readwrite>]` - Add a file-based archive at `<path>`\r\n\r\n- `nuget,<url>[,<readwrite>]` - Add a nuget-based source at `<url>`. This url has a similar semantic as `nuget.exe restore -source <url>` for reads and `nuget.exe push -source <url>` for writes; notably it can also be a local path.\r\n\r\n- `nugetconfig,<path>[,<readwrite>]` - Add a nuget-based source using the NuGet.config file at `<path>`. This enables users to fully control NuGet's execution in combination with the documented NuGet environment variables. This has similar semantics to `nuget.exe push -ConfigFile <path>` and `nuget.exe restore -ConfigFile <path>`.\r\n\r\n- `interactive` - Enables interactive mode (such as manual credential entry) for all other configured backends.\r\n\r\n`<readwrite>` can be any of `read`, `write`, or `readwrite` to control whether packages will be consumed or published.\r\n\r\nBacktick (`) can be used as an escape character within config strings, with double backtick (``) inserting a single backtick. All paths must be absolute.\r\n\r\nFor all backends, noninteractive operation will be the default and the vcpkg tool will take a `--interactive` parameter to enable prompting for user credentials (if needed by the backend).\r\n\r\nTo enable the 4-step flow, `vcpkg install` will take a command `--write-nuget-packages-config=<path>` which can be used in combination with `--dry-run`. This path can be relative and will resolve with respect to the current working directory.\r\n\r\n[1]: https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html\r\n\r\n#### Example 4-step flow\r\n\r\n```\r\nPS> vcpkg install --dry-run pkg1 pkg2 pkg3 --write-nuget-packages-config=packages.config \r\n```\r\n\r\nAn unspecified process, such as `nuget.exe restore packages.config -packagedirectory $packages` or the [ADO task][2], restores the packages to `$packages`.\r\n\r\n```\r\nPS> vcpkg install pkg1 pkg2 pkg3 --binarysource=clear --binarysource=nuget,$outpkgs,upload --binarysource=nuget,$packages\r\n```\r\n\r\nAnother unspecified process such as `nuget.exe sign $outpkgs/*.nupkg` and `nuget.exe push $outpkgs/*.nupkg` or the ADO task uploads the packages for use in future CI runs.\r\n\r\n[2]: https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/package/nuget?view=azure-devops\r\n","Nav":"#"},{"Path":"/en/docs/specifications/export-command.html","Name":"Export-command","Source":"# Binary Export (Apr 28, 2017)\n\n**Note: this is the feature as it was initially specified and does not necessarily reflect the current behavior.**\n\n## 1. Motivation\n\n### A. Build once and share\n\nCustomers want to be able to build their set of required libraries once, and then distribute the resulting binaries to all members of the \"group\". This has been brought up in\n- Enterprise environments, in which there are dedicated teams to acquire libraries and then share them with other teams to consume them\n- Academic environments, in which the professor/teacher wants to build the required libraries and then provide them to all the students\n- CI Systems, in which developers want to quickly distribute their exact set of dependencies to a cloud-based farm of build machines\n\nBuilding once and sharing ensures that everyone gets exactly the same binaries, isolates the building effort to a small number of people and minimizes friction to obtain them. Therefore, there is value in enabling users to easily export ready-to-share binaries from `vcpkg`.\n\n### B. Very large libraries\n\nLibraries like [Qt][] can take a very long time to build (5+ hours). Therefore, having the ability to build them and then distribute the binaries can save a lot of time.\n\n### C. Flexibility and uses without `vcpkg`\n\n`vcpkg` currently handles cases where you have a `vcpkg` enlistment on your machine and use it for acquiring libraries and integrating into Visual Studio, CMake etc. However, users need the ability to build the libraries and then use them outside of and independently of `vcpkg`. For example:\n- Use `vcpkg` for the build, then host the binaries in a website (similarly to nuget)\n- Use `vcpkg` for the build, then put the binaries in an installer and distribute the installer\n\nConsuming the libraries outside of `vcpkg` forfeits the ability to install new libraries or update existing ones, but this can be:\n- not a concern, like in a short term project or assignment\n- explicitly desired, like in the development of a game where libraries and their versions are sealed for a particular release, never to be modified\n\n### D. Easy consumption in Visual Studio for NuGet users\n\nCustomers have requested C++ NuGet packages to integrate into their project. This has come from:\n- Customers than have used NuGet (e.g. in C#) and find it very convenient\n- Customers who are working on a C# project that has a few dependencies on C++ and just want those dependencies to be satisfied in the most automatic way possible\n\nProviding a way to create NuGet packages provides great value to those customers. In an enterprise environment which focuses on C#, the dedicated acquisition team can create the NuGet packages with `vcpkg` and provide them to the other developers. For the \"end-developer\", this makes the consumption of C++ libraries the same as C# ones.\n\n[Qt]: https://www.qt.io/\n\n## 2. Other design concerns\n\n- The `vcpkg` root may have a variety of packages built and many of them might be unrelated to the current task. Providing an easy way to export a subset of them will enhance user experience.\n- Since binary compatibility is not guaranteed, it is not safe to individually export packages. Therefore, when exporting a particular package, all of the dependencies that it was built against must also be present in the export format (e.g. zip file). When a `vcpkg export` command succeeds, there is a guarantee that all required headers/binaries are available in the target bundle.\n\n## 3. Proposed solution\n\nThis document proposes the `vcpkg export` command to pack the desired binaries in a convenient format. It is not the goal of this document to discuss binary distribution for C++ in a similar way that NuGet does for C#. It proposes exporting \"library sets\" instead of individual libraries as a solution to the C++ binary incompatibility problem.\n\nFrom a user experience perspective, the user expresses interest in exporting a particular library (e.g. `vcpkg export cpprestsdk`). `vcpkg export` should then make sure that the output contains `cpprestsdk` along with all dependencies it was actually built against.\n\n## 4. Proposed User experience\n\n### i. User knows what libraries he needs and wants to export them to an archive format (zip)\nDeveloper Bob needs gtest and cpprestsdk and has been manually building them and their dependencies, then using the binaries in his project via applocal deployment. Bob has been experimenting with `vcpkg` and wants to use `vcpkg` for the building part only.\n\nBob tries to export the libraries:\n```no-highlight\n> vcpkg export gtest cpprestsdk --zip\nThe following packages are already built and will be exported:\n  * boost:x86-windows\n  * bzip2:x86-windows\n    cpprestsdk:x86-windows\n  * openssl:x86-windows\n  * websocketpp:x86-windows\n  * zlib:x86-windows\nThe following packages need to be built:\n    gtest:x86-windows\nAdditional packages (*) need to be exported to complete this operation.\nThere are packages that have not been built.\nTo build them, run:\n    vcpkg install gtest:x86-windows\n```\n\nBob proceeds to install the missing libraries:\n```no-highlight\n> vcpkg install gtest:x86-windows\n// -- omitted build information -- //\nPackage gtest:x86-windows is installed.\n```\n\nBob then returns to export the libraries:\n```no-highlight\n> vcpkg export gtest cpprestsdk --zip\nThe following packages are already built and will be exported:\n  * boost:x86-windows\n  * bzip2:x86-windows\n    cpprestsdk:x86-windows\n    gtest:x86-windows\n  * openssl:x86-windows\n  * websocketpp:x86-windows\n  * zlib:x86-windows\nAdditional packages (*) need to be exported to complete this operation.\nExporting package zlib:x86-windows...\nExporting package zlib:x86-windows... done\nExporting package openssl:x86-windows...\nExporting package openssl:x86-windows... done\nExporting package bzip2:x86-windows...\nExporting package bzip2:x86-windows... done\nExporting package boost:x86-windows...\nExporting package boost:x86-windows... done\nExporting package websocketpp:x86-windows...\nExporting package websocketpp:x86-windows... done\nExporting package cpprestsdk:x86-windows...\nExporting package cpprestsdk:x86-windows... done\nExporting package gtest:x86-windows...\nExporting package gtest:x86-windows... done\nCreating zip archive...\nCreating zip archive... done\nzip archive exported at: C:/vcpkg/vcpkg-export-20170428-155351.zip\n```\n\nBob takes the zip file and extracts the contents next to his other dependencies. Bob can now proceed with building his own project as before.\n\n### ii. User has a vcpkg root that works and wants to share it\nDeveloper Alice has been using `vcpkg` and has a Visual Studio project that consumes libraries from it (via `vcpkg integrate`). The project is built for both 32-bit and 64-bit architectures. Alice wants to quickly share the dependencies with Bob so he can test the project.\n```no-highlight\n> vcpkg export gtest zlib gtest:x64-windows zlib:x64-windows --nuget\nThe following packages are already built and will be exported:\n    gtest:x86-windows\n    gtest:x64-windows\n    zlib:x86-windows\n    zlib:x64-windows\nExporting package zlib:x86-windows...\nExporting package zlib:x86-windows... done\nExporting package zlib:x64-windows...\nExporting package zlib:x64-windows... done\nExporting package gtest:x86-windows...\nExporting package gtest:x86-windows... done\nExporting package gtest:x64-windows...\nExporting package gtest:x64-windows... done\nCreating nuget package...\nCreating nuget package... done\nNuget package exported at: C:/vcpkg/scripts/buildsystems/tmp/vcpkg-export-20170428-164312.nupkg\n```\n\nAlice gives to Bob: a) The link to her project and b) The NuGet package \"vcpkg-export-20170428-164312.nupkg\". Bob clones the project and then installs the NuGet package. Bob is now ready to build Alice's project.\n\n### iii. User has a vcpkg root that works and wants to share it #2\nDeveloper Alice has been using `vcpkg` and has a CMake project that consumes libraries from it (via CMake toolchain file). Alice wants to quickly share the dependencies with Bob so he can test the project.\n```no-highlight\n> vcpkg export cpprestsdk zlib --zip\nThe following packages are already built and will be exported:\n  * boost:x86-windows\n  * bzip2:x86-windows\n    cpprestsdk:x86-windows\n  * openssl:x86-windows\n  * websocketpp:x86-windows\n    zlib:x86-windows\nAdditional packages (*) need to be exported to complete this operation.\nExporting package zlib:x86-windows...\nExporting package zlib:x86-windows... done\nExporting package openssl:x86-windows...\nExporting package openssl:x86-windows... done\nExporting package bzip2:x86-windows...\nExporting package bzip2:x86-windows... done\nExporting package boost:x86-windows...\nExporting package boost:x86-windows... done\nExporting package websocketpp:x86-windows...\nExporting package websocketpp:x86-windows... done\nExporting package cpprestsdk:x86-windows...\nExporting package cpprestsdk:x86-windows... done\nCreating zip archive...\nCreating zip archive... done\nzip archive exported at: C:/vcpkg/vcpkg-export-20170428-155351.zip\n```\n\nAlice gives to Bob: a) The links to her project and b) The zip file \"vcpkg-export-20170428-155351.zip\". Bob clones the project, extracts the zip file and uses the provided (in the zip) CMake toolchain file to make the dependencies available to CMake. Bob is now ready to build Alice's project.\n\n## 5. Technical model\n\n- Each exported library, must be accompanied with all of its dependencies, even if they are not explicitly specified in the `vcpkg export` command.\n- When exporting a library, a dependency graph will be built, similarly to install, to figure out which packages need to be exported.\n- It is allowed to have packages from different triplets, so users can include 32/64-bit and dynamic/static binaries in the same export.\n- The exported archives also include the files needed to integrate with MSBuild and/or CMake.","Nav":"#"},{"Path":"/en/docs/specifications/feature-packages.html","Name":"Feature-packages","Source":"# Proposal: Features / Feature packages (Feb 23 2017)\r\n\r\n**Note: this is the feature as it was initially specified and does not necessarily reflect the current behavior.**\r\n\r\n**Up-to-date documentation is available at [Selecting Library Features](../users/selecting-library-features.md).**\r\n\r\n## 1. Motivation\r\n\r\n### A. OpenCV + CUDA\r\n\r\n[OpenCV][] is a computer vision library that can optionally be built with CUDA support to massively accelerate certain tasks when using computers with NVidia GPUs. For users without NVidia GPUs, building with CUDA support provides no benefit. [CUDA][] is provided only via a 1.3 GB installer (at the time of this authoring), which requires administrator access to install and modifies the global system state.\r\n\r\nTherefore, there is significant value in enabling users to choose whether they find CUDA support valuable for their particular scenario.\r\n\r\n### B. OpenCV + OpenCV\\_contrib\r\n\r\nThe community around [OpenCV][] has built up a library of extensions called [OpenCV_contrib][]. However, these extensions are a source-level patch onto the main OpenCV codebase and therefore must be applied _during_ the core OpenCV build. Further confounding the problem, it is the author's understanding that these community extensions have only been developed with [CUDA][] enabled and cannot be built without that dependency.\r\n\r\nTherefore, if CUDA is disabled, OpenCV\\_contrib must also be disabled. Likewise, when a user requests OpenCV\\_contrib, CUDA must be enabled. It would be convenient, but not a requirement, to enable CUDA without enabling the community extensions.\r\n\r\nFinally, these extensions add additional exports and headers which could be depended upon by other libraries. For maintainers, there must be a way to specify this requirement such that `vcpkg install mylib-depends-ocv-contrib` will verify/build/rebuild OpenCV with the community extensions enabled.\r\n\r\n### C. C++ REST SDK + SignalR\r\n\r\nThe [C++ REST SDK][cpprestsdk] is a networking library that provides (among other features) HTTP and Websockets clients. To implement the HTTP client functionality on Windows Desktop, only the core Win32 platform APIs are needed (`zlib` is optional).\r\n\r\nHowever, the websockets client is based on [Websockets++][], which adds mandatory dependencies on `boost`, `openssl`, and `zlib`. Many users of the C++ REST SDK do not use the websockets component, so to minimize their overall dependency footprint it can be disabled at build time. Ideally, these kinds of options would be easily accessible to users in Vcpkg who are concerned about the final size or licensing of their deployment.\r\n\r\n[SignalR-Client-Cpp][SignalR] depends on the websockets functionality provided by the C++ REST SDK. Therefore, the maintainers of the `signalrclient` port would ideally like to express this dependency such that `cpprestsdk` will be automatically correctly built for their needs. Note that `signalrclient` does not _inherently_ care about `boost`, `websocketspp` or `openssl` -- it depends only on the public websocket client APIs provided by `cpprestsdk`. It would be much more maintainable to declare dependencies based on the public APIs rather than the dependencies themselves.\r\n\r\n[OpenCV]: http://opencv.org/\r\n[CUDA]: http://www.nvidia.com/object/cuda_home_new.html\r\n[OpenCV_contrib]: https://github.com/opencv/opencv_contrib\r\n[cpprestsdk]: https://github.com/Microsoft/cpprestsdk\r\n[Websockets++]: https://www.zaphoyd.com/websocketpp/\r\n[SignalR]: https://github.com/aspnet/SignalR-Client-Cpp\r\n\r\n## 2. Other design concerns\r\n\r\n- General-purpose Open Source projects must be able to easily and succinctly describe their build dependencies inside Vcpkg. This should be no more verbose than a single `vcpkg install` line and, when that command succeeds, there is a strong expectation that all required functionality/headers/imports are available.\r\n\r\n- The internal state of the Vcpkg enlistment must be either extremely transparent OR managed by version control (git). This enables larger projects to efficiently transfer the entire state of their customized Vcpkg system between machines (and onto build servers) by having the destination clone and then run a single `vcpkg install` line for the subset of dependencies required. The results of this operation should be as repeatable as reasonably achievable given the current limits of the underlying toolchain.\r\n\r\n## 3. Proposed solution\r\n\r\nA key summary of the above motivations is that they are all scenarios surrounding APIs that are not independently buildable from each other. We have an existing solution for APIs that are independently buildable: separate packages. Therefore, we seek to extend the user-facing notion of \"packages\" to include capabilities and contracts that cannot be made into independent builds.\r\n\r\nThis document proposes \"features\" (also called feature packages). These features are intended to model semi-independently toggleable API sets/contracts such that they can be sanely depended upon by other packages. It is not a goal to model exclusive alternatives (such as implementation choices that are not directly user-observable) through this mechanism.\r\n\r\n- Individual libraries within `boost` may be reasonably represented as features.\r\n- Whether a graphics library is built on DirectX xor OpenGL (where one but not both must be chosen) is not representable as a feature.\r\n\r\nFrom a user experience perspective (i.e. from `vcpkg install`) feature packages act as much as possible like completely independent packages. However, internally, any change to a package's features will result in a rebuild of the associated \"parent\" package. This will invoke a package rebuild experience similar to upgrading.\r\n\r\nWhen using `vcpkg install <package>`, some features will be enabled by default. These default features can be avoided by referring to the packages as `<package>[core]` and features can be added by supplying them on the same installation line.\r\n\r\n### A. Proposed User experience\r\n\r\n#### i. User with no preference about options\r\nInstall of a library with default features:\r\n```no-highlight\r\n> vcpkg install cpprestsdk\r\n// -- omitted build information -- //\r\nPackage cpprestsdk[core]:x86-windows is installed.\r\nPackage cpprestsdk[compression]:x86-windows is installed.\r\nPackage cpprestsdk[ws-client]:x86-windows is installed.\r\n```\r\n\r\nRemoval of that library:\r\n```no-highlight\r\n> vcpkg remove cpprestsdk\r\nThe following packages will be removed:\r\n    cpprestsdk:x86-windows\r\nRemoving package cpprestsdk:x86-windows...\r\nRemoving package cpprestsdk:x86-windows... done\r\nPurging package cpprestsdk:x86-windows...\r\nCleaned up D:\\src\\vcpkg\\packages\\cpprestsdk_x64-windows\r\nPurging package cpprestsdk:x86-windows... done\r\n```\r\n\r\nInstallation of a library with optional features:\r\n```no-highlight\r\n> vcpkg install opencv\r\n// -- omitted build information -- //\r\nPackage opencv[core]:x86-windows is installed.\r\n```\r\n\r\n#### ii. User desires CUDA support for OpenCV directly, and is unfamiliar with feature packages\r\nDeveloper Bob knows he wants OpenCV, so he guesses what the package is called\r\n```no-highlight\r\n> vcpkg install opencv\r\n// -- omitted build information -- //\r\nPackage opencv[core]:x86-windows is installed.\r\n```\r\n\r\nBob attempts to build his application against OpenCV (assuming CUDA), which fails at runtime or compile time indicating that OpenCV wasn't built with CUDA.\r\nBob comes back to vcpkg, not knowing about the \"feature packages\" feature. The primary inquiry tools for Vcpkg are `search` and `list`, so he runs `vcpkg search`:\r\n```no-highlight\r\n> vcpkg search opencv\r\nopencv               3.2.0            computer vision library\r\nopencv[cuda]                          support for NVidia CUDA\r\nopencv[contrib]                       community supported extensions for OpenCV\r\n\r\nIf your library is not listed, please open an issue at:\r\n    https://github.com/Microsoft/vcpkg/issues\r\n```\r\nHe isn't immediately sure what the lack of a version number means, but anything in `vcpkg search` can be applied to `vcpkg install`, so he runs:\r\n```no-highlight\r\n> vcpkg install opencv[cuda]\r\nThe following packages will be rebuilt:\r\n    opencv:x86-windows\r\n\r\nTo rebuild with this feature, use:\r\n    vcpkg remove opencv:x86-windows\r\n    vcpkg install opencv[core,cuda]:x86-windows\r\n```\r\nBob follows the instructions...\r\n```no-highlight\r\n> vcpkg remove opencv:x86-windows\r\n// -- omitted results as above -- //\r\n> vcpkg install opencv[core,cuda]:x86-windows\r\n// -- omitted build information -- //\r\nPackage opencv[core]:x86-windows is installed.\r\nPackage opencv[cuda]:x86-windows is installed.\r\n```\r\nand he can now use OpenCV's CUDA support in his application.\r\n\r\n#### iii. User is familiar with feature packages, and wants to opt-out of a feature\r\nDeveloper Alice has used `cpprestsdk`, built it from source, and she knows about the option to disable websockets. She uses `search` to find the complete list of features:\r\n```\r\n> vcpkg search cpprestsdk\r\ncpprestsdk                  2.9.0-2       C++11 JSON, REST, and OAuth library The C++ RES...\r\ncpprestsdk[compression]                   Gzip compression support in the HTTP client.\r\ncpprestsdk[ws-client]                     Websocket client support based on websocketspp.\r\n\r\nIf your library is not listed, please open an issue at:\r\n    https://github.com/Microsoft/vcpkg/issues\r\n```\r\n\r\nShe decided she only wants `cpprestsdk[compression]`, so she installs only that feature:\r\n```no-highlight\r\n> vcpkg install cpprestsdk[compression]\r\n// -- omitted build information -- //\r\nPackage cpprestsdk[core]:x86-windows is installed.\r\nPackage cpprestsdk[compression]:x86-windows is installed.\r\n```\r\nShe receives a quick recursive build that only depends on `zlib`.\r\n\r\nShe's now interested in some additional libraries built on top of cpprestsdk: `azure-storage-cpp` and `signalrclient`.\r\n```no-highlight\r\n> vcpkg install azure-storage-cpp\r\n// -- omitted build information -- //\r\nPackage azure-storage-cpp[core]:x86-windows is installed.\r\n\r\n> vcpkg install signalrclient\r\nPackage signalrclient:x86-windows depends on cpprestsdk[ws-client]:x86-windows.\r\n\r\nThe following packages will be rebuilt:\r\n  * azure-storage-cpp:x86-windows\r\n  * cpprestsdk:x86-windows\r\n\r\nTo rebuild the current package graph with this feature, use:\r\n    vcpkg remove cpprestsdk:x86-windows azure-storage-cpp:x86-windows\r\n    vcpkg install cpprestsdk[core,compression,ws-client]:x86-windows\r\n    vcpkg install azure-storage-cpp[core]:x86-windows\r\n    vcpkg install signalrclient[core]:x86-windows\r\n```\r\nShe follows the above script and can use both `azure-storage-cpp` and `signalrclient` in her code.\r\n\r\nSome time has passed, she decided not to use `signalrclient`, and she's interested in shipping her application. She wants to minimize her final install size, so she'd like to remove all unneeded packages like `boost` and `openssl`.\r\n```no-highlight\r\n> vcpkg remove boost openssl\r\nThe following packages and features will be removed:\r\n  * signalrclient[core]:x86-windows\r\n  * cpprestsdk[ws-client]:x86-windows\r\n    boost[core]:x86-windows\r\n    openssl[core]:x86-windows\r\n\r\nThe following packages will be rebuilt:\r\n  * azure-storage-cpp:x86-windows\r\n  * cpprestsdk:x86-windows\r\n\r\nRemoving features requires rebuilding packages.\r\nTo rebuild the current package graph without these features, use:\r\n    vcpkg remove cpprestsdk:x86-windows azure-storage-cpp:x86-windows signalrclient:x86-windows openssl:x86-windows boost:x86-windows\r\n    vcpkg install cpprestsdk[core,compression]:x86-windows\r\n    vcpkg install azure-storage-cpp[core]:x86-windows\r\n```\r\nIn the end, her final `vcpkg list` outputs:\r\n```no-highlight\r\n> vcpkg list\r\nzlib[core]:x86-windows              1.2.11          A compression library\r\nazure-storage-cpp[core]:x86-windows 2.6.0           Microsoft Azure Storage Client SDK for ...\r\ncpprestsdk[core]:x86-windows        2.9.0-2         C++11 JSON, REST, and OAuth library\r\ncpprestsdk[compression]:x86-windows                 Gzip compression support in the HTTP client.\r\n```\r\n\r\n### B. Technical model\r\n\r\n- Each package can have any number \"features\".\r\n- Features follow the same naming conventions as packages, but when referenced are always \"namespaced\" by the parent package.\r\n    - `cpprestsdk[ws-client]` is a completely orthogonal feature from `poco[ws-client]`.\r\n- Features are valid dependencies.\r\n    - `signalrclient` depends on `cpprestsdk[ws-client]`\r\n- Features can have dependencies (including other features).\r\n    - `cpprestsdk[ws-client]` depends on `boost`, `openssl`, and `websocketspp`\r\n    - `opencv[cuda]` depends on `cuda`\r\n    - `opencv[contrib]` depends on `opencv[cuda]`\r\n    - `boost[python]` depends on `libpython`\r\n- Every package has an implicit feature called `core`, which covers the core library with a minimum set of features. All features implicitly depend on the `core` feature of their parent package\r\n    - `azure-storage-cpp` depends on `cpprestsdk[core]`\r\n    - `cpprestsdk[ws-client]` implicitly depends on `cpprestsdk[core]`\r\n- Each package declares a list of default features that are enabled when the package is referred to by its raw name, and `core` is always a default feature.\r\n    - `cpprestsdk` declares `ws-client` and `compression` to be default features. Any unqualified reference `cpprestsdk` implicitly means `cpprestsdk[core]` _and_ `cpprestsdk[ws-client]` _and_ `cpprestsdk[compression]`.\r\n    - `opencv` does not declare `cuda` nor `contrib` to be default features.\r\n\r\nAs a conclusion of the above, it is expected that all packages will be buildable with all features disabled (just the `core` feature) and with all features enabled.\r\n\r\n### C. Proposed Control File Syntax\r\n\r\n#### OpenCV and CUDA\r\nTo add the feature CUDA to OpenCV, we will adopt the following syntax in the CONTROL file:\r\n```no-highlight\r\n# opencv/CONTROL\r\nSource: opencv\r\nVersion: 3.2.0-1\r\nBuild-Depends: zlib, libpng, libjpeg-turbo, tiff\r\nDescription: computer vision library\r\nDefault-Features:\r\n\r\nFeature: cuda\r\nBuild-Depends: cuda\r\nDescription: parallel computing platform\r\n\r\nFeature: contrib\r\nBuild-Depends: opencv[cuda]\r\nDescription: library of OpenCV Extensions\r\n```\r\n\r\n#### Signalrclient\r\n```no-highlight\r\n# signalrclient/CONTROL\r\nSource: signalrclient\r\nVersion: 1.0.0-beta1\r\nBuild-Depends: cpprestsdk[ws-client]\r\nDescription: C++ client for SignalR.\r\n```\r\n```no-highlight\r\n# cpprestsdk/CONTROL\r\nSource: cpprestsdk\r\nVersion: 2.9.0-2\r\nBuild-Depends: \r\nDescription: C++11 JSON, REST, and OAuth library ...\r\nDefault-Features: compression, ws-client\r\n\r\nFeature: compression\r\nBuild-Depends: zlib (windows)\r\nDescription: Gzip compression support in the HTTP client.\r\n\r\nFeature: ws-client\r\nBuild-Depends: boost (windows), openssl (windows), websocketpp (windows)\r\nDescription: Websocket client support based on websocketspp\r\n```\r\n\r\n### D. Additional Control File Technical Details\r\n\r\n- If any feature paragraphs exist, the field `Default-Features` must be present.\r\n\r\n## 4. Related Work\r\n\r\n### Cargo's Features (from Rust): <http://doc.crates.io/manifest.html#the-features-section>\r\nThe proposed feature packages are exceedingly similar to Cargo's Features, with the following changes:\r\n\r\n- We avoid any collision problems because features are always namespaced by the owning package\r\n- We do not have a concept of \"feature groups\", instead we allow dependencies from one feature to another within the same package (Note: This may be how \"feature groups\" are implemented internally to Cargo -- it was not clear from the documentation).\r\n- Because of the nature of C and C++, it is extremely commonplace that large software packages can have features disabled to remove their dependencies upon other libraries. Changing this configuration requires a rebuild of the package and potentially rippling ABI changes to any downstream dependencies. Therefore, we expect significantly more use of this feature to manage optional API contracts instead of the intended use in Cargo (curation).\r\n- We do not intend feature packages to be used to express the curation relationship, beyond the notion of a \"default\" set within a package.\r\n\r\n### Gentoo's USE flags: <https://wiki.gentoo.org/wiki/Handbook:X86/Working/USE>\r\nGentoo's USE flags can be shortly summarized as a global set of keywords that is used to make cross-cutting changes to the entire package graph's build configuration. This system standardizes many common settings such that they can be simultaneously toggled for the entire graph.\r\n\r\nThe most common example of this would be using KDE vs Gnome. A user who knows that, given the choice, they would prefer the KDE/Qt interface can manage the massive space of package configuration efficiently without learning the particular term that each package has decided to call \"build using Qt instead of GTK\".\r\n\r\nUSE flags can be customized hierarchically when needed, including at the per-package level. They can be depended upon by other packages, both positively and negatively. USE flags themselves can be used in any boolean expression to determine the complete set of package dependencies, including removing dependencies when flags are enabled.\r\n\r\nProblems with USE flags:\r\n\r\n- They require coordination from package maintainers to achieve the goal of \"portable\" flags. This increases the burden of adding a package -- to author a good package, I need to be aware of every uncommon USE flag and evaluate how those could map onto my local configuration space.\r\n- Based on research online, it seems extremely common that users need to tweak flags at a per-package level. This calls into question how valuable the cross-cutting power above is.\r\n- The vast majority of common USE flags are essentially a list of all the common packages and focus on giving the user a view of dependencies (which a package manager is designed to abstract when possible) instead of APIs (which is what users code against).\r\n- Dependency analysis with USE flags becomes a SAT problem with an enormous state space -- P*F bits -- which compounds with any versioning relations. This may work acceptably in practice via heuristics, but it implies that a) there is a looming performance wall which could suddenly create a poor user experience and b) the heuristics may incorrectly model the user's needs, causing a disconnect in desire vs practice, which again leads to a poor user experience.\r\n","Nav":"#"},{"Path":"/en/docs/specifications/manifests.html","Name":"Manifests","Source":"# Manifests -- `vcpkg.json`\n\n**Note: this is the feature as it was initially specified and does not necessarily reflect the current behavior.**\n\n**Up-to-date documentation is available at [Manifests](../users/manifests.md).**\n\nFor many other language package managers, there exists a way of writing one's dependencies in a declarative\nmanifest format; we want something similar for vcpkg. What follows is the specification of that feature;\nthis should mean that vcpkg becomes far more user and enterprise-friendly, and is additionally an important\nfirst step for versioning and package federation. Our primary concern, beyond implementability, is ease-of-use;\nit is important that using this feature is all of:\n\n* Easy for existing users\n* Easy for new users to set up\n* Easy to extend later for new features like versioning and federation\n* _Declarative_, not _Imperative_.\n\n## Reasoning\n\n### Why JSON?\n\nWe choose JSON for five main reasons:\n\n* Everybody knows JSON, and if one doesn't, it's really easy to learn\n* Every tool supports JSON in the standard library, or in a commonly used support library\n  * This means writing tooling should be trivial in any language one is comfortable with\n  * Most configuration formats don't have a COBOL implementation \n* Specified in an international standard\n  * There is _one_ right way to parse JSON\n  * There are no ambiguities of what the parse tree _should_ be\n* Simple and secure\n  * Unlike YAML, for example, there's no weird ACE issues\n  * Easy to write a parser -- important since we can't depend on external libraries\n* Schemas are almost a necessity\n\nSome have suggested allowing comments or commas in our parser; we chose to use JSON proper\nrather than JSON5 or JSON with comments because JSON is the everywhere-supported international\nstandard. That is not necessarily true of JSON with comments. Additionally, if one needs\nto write a comment, they can do so via `\"$reason\"` or `\"$comment\"` fields.\n\n## Specification\n\nA manifest file shall have the name `vcpkg.json`, and shall be in the root directory of a package.\nIt also replaces CONTROL files, though existing CONTROL files will still be\nsupported; there will be no difference between ports and packages, except\nthat packages do not need to supply portfile.cmake (eventually we would like\nto remove the requirement of portfile.cmake for ports that already use\nCMake).\n\nThe specification uses definitions from the [Definitions](#definitions) section in order\nto specify the shape of a value. Note that any object may contain any directives, written as\na field key that starts with a `$`; these directive shall be ignored by `vcpkg`. Common\ndirectives may include `\"$schema\"`, `\"$comment\"`, `\"$reason\"`.\n\nA manifest must be a top-level object, and must have at least:\n\n* `\"name\"`: a `<package-name>`\n* One (and only one) of the following version fields:\n  * `\"version-string\"`: A `string`. Has no semantic meaning.\n    Equivalent to `CONTROL`'s `Version:` field.\n  * Other version fields will be defined by the Versions RFC\n\nThe simplest vcpkg.json looks like this:\n\n```json\n{\n  \"name\": \"mypackage\",\n  \"version-string\": \"0.1.0-dev\"\n}\n```\n\nAdditionally, it may contain the following properties:\n* `\"port-version\"`: A non-negative integer. If this field doesn't exist, it's assumed to be `0`.\n  * Note that this is a change from existing CONTROL files, where versions were a part of the version string\n* `\"maintainers\"`: An array of `string`s which contain the authors of a package\n  * `\"maintainers\": [ \"Nicole Mazzuca <nicole@example.com>\", \"  <shalom@example.com>\" ]`\n* `\"description\"`: A string or array of strings containing the description of a package\n  * `\"description\": \"mypackage is a package of mine\"`\n* `\"homepage\"`: A url which points to the homepage of a package\n  * `\"homepage\": \"https://github.com/strega-nil/mypackage\"`\n* `\"documentation\"`: A url which points to the documentation of a package\n  * `\"documentation\": \"https://readthedocs.io/strega-nil/mypackage\"`\n* `\"license\"`: A `<license-string>`\n  * `\"license\": \"MIT\"`\n* `\"dependencies\"`: An array of `<dependency>`s\n* `\"dev-dependencies\"`: An array of `<dependency>`s which are required only for developers (testing and the like)\n* `\"features\"`: An array of `<feature>`s that the package supports\n* `\"default-features\"`: An array of `<identifier>`s that correspond to features, which will be used by default.\n* `\"supports\"`: A `<platform-expression>`\n  * `\"supports\": \"windows & !arm\"`\n\nAny properties which are not listed, and which do not start with a `$`,\nwill be warned against and are reserved for future use.\n\nThe following is an example of an existing port CONTROL file rewritten as a vcpkg.json file:\n\n```\nSource: pango\nVersion: 1.40.11-6\nHomepage: https://ftp.gnome.org/pub/GNOME/sources/pango/\nDescription: Text and font handling library.\nBuild-Depends: glib, gettext, cairo, fontconfig, freetype, harfbuzz[glib] (!(windows&static)&!osx)\n```\n\n```json\n{\n  \"name\": \"pango\",\n  \"version-string\": \"1.40.11\",\n  \"port-version\": 6,\n  \"homepage\": \"https://ftp.gnome.org/pub/GNOME/sources/pango/\",\n  \"description\": \"Text and font handling library.\",\n  \"dependencies\": [\n    \"glib\",\n    \"gettext\",\n    \"cairo\",\n    \"fontconfig\",\n    \"freetype\",\n    {\n      \"name\": \"harfbuzz\",\n      \"features\": [ \"glib\" ],\n      \"platform\": \"!(windows & static) & !osx\"\n    }\n  ]\n}\n```\n\n## Behavior of the Tool\n\nThere will be two \"modes\" for vcpkg from this point forward: \"classic\", and \"manifest\".\nThe former will act exactly like the existing vcpkg workflow, so as to avoid breaking\nanyone. The latter will be the mode only when the user either:\n\n* Passes `--manifest-root=<directory>` (initially, `x-manifest-root`)\n* Runs `vcpkg` in a directory that contains a file named `vcpkg.json`, or in a\n  child directory of a directory containing `vcpkg.json`.\n  * For this, initially vcpkg will warn that the behavior will change in the\n    future, and simply run in classic mode, unless the feature flag `manifests` is\n    passed via:\n    * The environment variable `VCPKG_FEATURE_FLAGS`\n    * The option `--feature-flags`\n      * (e.g., `--feature-flags=binarycaching,manifests`)\n    * If someone wants to use classic mode and silence the warning, they can add the\n      `-manifests` feature flag to disable the mode.\n\nWhen in \"manifest\" mode, the `installed` directory will be changed to\n`<manifest-root>/vcpkg_installed` (name up for bikeshedding).\nThe following commands will change behavior:\n\n* `vcpkg install` without any port arguments will install the dependencies listed in\n  the manifest file, and will remove any dependencies\n  which are no longer in the dependency tree implied by the manifest file.\n* `vcpkg install` with port arguments will give an error.\n\nThe following commands will not work in manifest mode, at least initially:\n\n* `vcpkg x-set-installed`: `vcpkg install` serves the same function\n* `vcpkg remove`\n* `vcpkg export`\n\nWe may add these features back for manifest mode once we understand how best to\nimplement them.\n\n### Behavior of the Toolchain\n\nMostly, the toolchain file stays the same; however, we shall add\ntwo public options:\n\n```cmake\nVCPKG_MANIFEST_MODE:BOOL=<we found a manifest>\nVCPKG_MANIFEST_INSTALL:BOOL=ON\n```\n\nThe first option either explicitly turns on, or off, manifest mode;\notherwise, we default to looking for a manifest file in the directory\ntree upwards from the source directory.\n\nThe `VCPKG_MANIFEST_INSTALL` option tells the toolchain whether to\ninstall the packages or not -- if you wish to install the manifest\ndependencies manually, you can set this to off, and we also turn it\noff for packages installed by vcpkg.\n\nAdditionally, if `-manifests` is set in the feature flags environment\nvariable, we turn off manifest mode in the toolchain, and we act like\nthe classic toolchain.\n\n### Example - CMake Integration\n\nAn example of using the new vcpkg manifests feature for a new\nproject follows:\n\nThe filesystem structure should look something like:\n\n```\nexample/\n  src/\n    main.cxx\n  CMakeLists.txt\n  vcpkg.json\n```\n\nThen, `main.cxx` might look like:\n\n```cpp\n#include <fmt/format.h>\n\nint main() {\n  fmt::print(\"Hello, {}!\", \"world\");\n}\n```\n\nTherefore, in `vcpkg.json`, we'll need to depend on `fmt`:\n\n```json\n{\n  \"name\": \"example\",\n  \"version-string\": \"0.0.1\",\n  \"dependencies\": [\n    \"fmt\"\n  ]\n}\n```\n\nThen, let's write our `CMakeLists.txt`:\n\n```cmake\ncmake_minimum_required(VERSION 3.14)\n\nproject(example CXX)\n\nadd_executable(example src/main.cxx)\n\nfind_package(fmt REQUIRED)\n\ntarget_link_libraries(example\n  PRIVATE\n    fmt::fmt)\n```\n\nAnd finally, to configure and build:\n\n```sh\n$ cd example\n$ cmake -B build -S . -DCMAKE_TOOLCHAIN_FILE=$VCPKG_ROOT/scripts/buildsystems/vcpkg.cmake\n... configuring and installing...\n$ cmake --build build\n```\n\nand we're done! `fmt` will get installed into\n`example/build/vcpkg_installed`, and we can run our executable with:\n\n```sh\n$ build/example\nHello, world!\n```\n\n## Definitions\n\n* `<identifier>`: A `string` which:\n  * Is entirely ASCII\n  * Contains only lowercase alphabetic characters, digits, and hyphen-minus\n  * Does not have multiple consecutive hyphens\n  * Does not begin nor end with a hyphen\n  * Is not a Windows filesystem reserved name\n  * Is not a vcpkg reserved name: \"default\" or \"core\".\n  * In other words, it must follow the regex `[a-z0-9]+(-[a-z0-9]+)*`, and must not be any of:\n    * `{ prn, aux, nul, con, lpt[1-9], com[1-9], core, default }`\n* `<package-name>`: A `string` consisting of a non-zero number of `<identifier>`s, separated by `.`.\n  * `a.b.c` is valid\n  * `a` is valid\n  * `a/b` is not valid\n  * `Boost.Beast` is not valid, but `boost.beast` is\n* `<dependency>`: Either a `<package-name>`, or an object:\n  * A dependency always contains the following:\n    * `\"name\"`: A `<package-name>`\n    * Optionally, `\"features\"`: an array of `<identifier>`s corresponding to features in the package.\n    * Optionally, `\"default-features\"`: a `boolean`. If this is false, then don't use the default features of the package; equivalent to core in existing CONTROL files. If this is true, do the default thing of including the default features.\n    * Optionally, `\"platform\"`: a `<platform-expression>`\n  * `<dependency.port>`: No extra fields are required.\n* `<license-string>`: An SPDX license expression at version 3.9.\n* `<platform-expression>`: A specification of a set of platforms; used in platform-specific dependencies and supports fields. A string that is parsed as follows:\n  * `<platform-expression>`:\n    * `<platform-expression.not>`\n    * `<platform-expression.and>`\n    * `<platform-expression.or>`\n  * `<platform-expression.simple>`:\n    * `( <platform-expression> )`\n    * `<platform-expression.identifier>`\n  * `<platform-expression.identifier>`:\n    * regex: `/^[a-z0-9]+$/`\n  * `<platform-expression.not>`:\n    * `<platform-expression.simple>`\n    * `! <platform-expression.simple>`\n  * `<platform-expression.and>`\n    * `<platform-expression.not>`\n    * `<platform-expression.and> & <platform-expression.not>`\n  * `<platform-expression.or>`\n    * `<platform-expression.not>`\n    * `<platform-expression.or> | <platform-expression.not>`\n* `<feature>`: An object containing the following:\n  * `\"name\"`: An `<identifier>`, the name of the feature\n  * `\"description\"`: A `string` or array of `string`s, the description of the feature\n  * Optionally, `\"dependencies\"`: An array of `<dependency>`s, the dependencies used by this feature\n","Nav":"#"},{"Path":"/en/docs/specifications/ports-overlay.html","Name":"Ports-overlay","Source":"# Ports Overlay (Jun 19, 2019)\r\n\r\n**Note: this is the feature as it was initially specified and does not necessarily reflect the current behavior.**\r\n\r\n## 1. Motivation\r\n\r\n### A. Allow users to override ports with alternate versions\r\n\r\nIt's a common scenario for `vcpkg` users to keep specific versions of libraries to use in their own projects. The current recommendation for users is to fork `vcpkg`'s repository and create tags for commits containing the specific versions of the ports they want to use.\r\n\r\nThis proposal adds an alternative to solve this problem. By allowing `vcpkg` users to specify additional locations in their file system containing ports for:\r\n\r\n  * older or newer versions of libraries,\r\n  * modified libraries, or\r\n  * libraries not available in `vcpkg`.\r\n\r\nThese locations will be searched when resolving port names during package installation, and override ports in `<vcpkg-root>/ports`.\r\n\r\n### B. Allow users to keep unmodified upstream ports\r\n\r\nUsers will be able to keep unmodified versions of the ports shipped with `vcpkg` and update them via `vcpkg update` and `vcpkg upgrade` without having to solve merge conflicts.\r\n\r\n\r\n## 2. Other design concerns\r\n\r\n* Allow a set of `vcpkg` commands to optionally accept additional paths to be used when searching for ports.\r\n* Additional paths must take precedence when resolving names of ports to install.\r\n* Allow users to specify multiple additional paths.\r\n* Provide a simple disambiguation mechanism to resolve ambiguous port names.\r\n* After resolving a port name, the installation process has to work the same as for ports shipped by `vcpkg`.\r\n* This **DOES NOT ENABLE MULTIPLE VERSIONS** of a same library to be **INSTALLED SIDE-BY-SIDE**.\r\n\r\n\r\n## 3. Proposed solution\r\n\r\nThis document proposes allowing additional locations to search for ports during package installation that will override and complement the set of ports provided by `vcpkg` (ports under the `<vcpkg_root>/ports` directory).`\r\n\r\nA new option `--overlay-ports` will be added to the `vcpkg install`, `vcpkg update`, `vcpkg upgrade`, `vcpkg export`, and `vcpkg depend-info` commands to specify additional paths containing ports. \r\n\r\nFrom a user experience perspective, a user expresses interest in adding additional lookup locations by passing the `--overlay-ports` option followed by a path to:\r\n\r\n* an individual port (directory containing a `CONTROL` file),\r\n  * `vcpkg install sqlite3 --overlay-ports=\"C:\\custom-ports\\sqlite3\"`\r\n\r\n* a directory containing ports,\r\n  * `vcpkg install sqlite3 --overlay-ports=\\\\share\\org\\custom-ports`\r\n\r\n* a file listing paths to the former two.\r\n  > NOTE: Reading paths from a text file is not available in the current implementation, some revisions to this part of the specification are being made and will be implemented in a future date.\r\n  \r\n  * `vcpkg install sqlite3 --overlay-ports=..\\port-repos.txt`\r\n\r\n    _port-repos.txt_\r\n    \r\n    ```\r\n    .\\experimental-ports\\sqlite3\r\n    C:\\custom-ports\r\n    \\\\share\\team\\custom-ports\r\n    \\\\share\\org\\custom-ports\r\n    ```\r\n    *Relative paths inside this file are resolved relatively to the file's location. In this case a `experimental-ports` directory should exist at the same level as the `port-repos.txt` file.*\r\n\r\n_NOTE: It is not the goal of this document to discuss library versioning or project dependency management solutions, which require the ability to install multiple versions of a same library side-by-side._ \r\n\r\n### Multiple additional paths \r\n\r\nUsers can provide multiple additional paths by repeating the `--overlay-ports` option.\r\n\r\n```\r\nvcpkg install sqlite3 \r\n    --overlay-ports=\"..\\experimental-ports\\sqlite3\" \r\n    --overlay-ports=\"C:\\custom-ports\" \r\n    --overlay-ports=\"\\\\share\\team\\custom-ports\r\n```\r\n\r\n### Overlaying ports\r\n\r\nPort name resolution follows the order in which additional paths are specified, with the first match being selected for installation, and falling back to `<vcpkg-root>/ports` if the port is not found in any of the additional paths.\r\n\r\nNo effort is made to compare version numbers inside the `CONTROL` files, or to determine which port contains newer or older files.\r\n\r\n### Examples\r\n\r\nGiven the following directory structure:\r\n\r\n  ```\r\n  team-ports/\r\n  |-- sqlite3/\r\n  |---- CONTROL\r\n  |-- rapidjson/\r\n  |---- CONTROL\r\n  |-- curl/\r\n  |---- CONTROL\r\n\r\n  my-ports/\r\n  |-- sqlite3/\r\n  |---- CONTROL\r\n  |-- rapidjson/\r\n  |---- CONTROL\r\n\r\n  vcpkg\r\n  |-- ports/\r\n  |---- <upstream ports>\r\n  |-- vcpkg.exe\r\n  |-- preferred-ports.txt\r\n  ```\r\n* #### Example #1:\r\n\r\n  Running:\r\n\r\n  ```\r\n  vcpkg/vcpkg.exe install sqlite3 --overlay-ports=my-ports --overlay-ports=team-ports\r\n  ```\r\n\r\n  Results in `my-ports/sqlite3` getting installed as that location appears first in the command line arguments.\r\n\r\n* #### Example #2:\r\n  \r\n  A specific version of a port can be given priority by adding its path first in the list of arguments:\r\n\r\n  ```\r\n  vcpkg/vcpkg.exe install sqlite3 rapidjson curl \r\n      --overlay-ports=my-ports/rapidjson \r\n      --overlay-ports=vcpkg/ports/curl\r\n      --overlay-ports=team-ports\r\n  ```\r\n\r\n  Installs:\r\n    * `sqlite3` from `team-ports/sqlite3`\r\n    * `rapidjson` from `my-ports/rapidjson`\r\n    * `curl` from `vcpkg/ports/curl`\r\n\r\n* #### Example #3:\r\n\r\n  > NOTE: Reading paths from a text file is not available in the current implementation, some revisions to this part of the specification are being made and will be implemented in a future date.\r\n  \r\n  Given the content of `preferred-ports.txt` as:\r\n\r\n  ```\r\n  ./ports/curl\r\n  /my-ports/rapidjson\r\n  /team-ports\r\n  ```\r\n\r\n  A location can be appended or prepended to those included in `preferred-ports.txt` via the command line, like this:\r\n\r\n  ```\r\n  vcpkg/vcpkg.exe install sqlite3 curl --overlay-ports=my-ports --overlay-ports=vcpkg/preferred-ports.txt\r\n  ```\r\n\r\n  Which results in `my-ports/sqlite3` and `vcpkg/ports/curl` getting installed.\r\n\r\n\r\n## 4. Proposed User experience\r\n\r\n### i. User wants to preserve an older version of a port\r\n\r\nDeveloper Alice and her team use `vcpkg` to acquire **OpenCV** and some other packages. She has even contributed many patches to add features to the **OpenCV 3** port in `vcpkg`. But, one day, she notices that a PR to update **OpenCV** to the next major version has been merged. \r\n\r\nAlice wants to update some packages available in `vcpkg`. Unfortunately, updating her project to use the latest **OpenCV** is not immediately possible. \r\n\r\nAlice creates a private GitHub repository and checks in the set of ports that she wants to preserve. Then provides her teammates with the link to clone her private ports repository.\r\n\r\n```\r\nmkdir vcpkg-custom-ports\r\ncd vcpkg-custom-ports\r\ngit init \r\ncp -r %VCPKG_ROOT%/ports/opencv .\r\ngit add .\r\ngit commit -m \"[opencv] Add OpenCV 3 port\"\r\ngit remote add origin https://github.com/<Alice's GitHub username>/vcpkg-custom-ports.git\r\ngit push -u origin master\r\n```\r\n\r\nNow her team is able to use: \r\n\r\n```\r\ngit clone https://github.com/<Alice's GitHub username>/vcpkg-custom-ports.git\r\nvcpkg update --overlay-ports=./vcpkg-custom-ports\r\nvcpkg upgrade --no-dry-run --overlay-ports=./vcpkg-custom-ports\r\n``` \r\n\r\nto upgrade their packages and preserve the old version of **OpenCV** they require.\r\n","Nav":"#"},{"Path":"/en/docs/specifications/prefab.html","Name":"Prefab","Source":"# Vcpkg: export Android prefab Archives (AAR files)\n\n**Note: this is the feature as it was initially specified and does not necessarily reflect the current behavior.**\n\nVcpkg can export android archives ([AAR files](https://developer.android.com/studio/projects/android-library)). Once an archive is created, it can imported in Android Studio as a native dependent.  The archive is automatically consumed using [android studio's prefab tool](https://github.com/google/prefab). \n\nFor more information on Prefab, refer to:\n* The [official prefab documentation](https://google.github.io/prefab).\n* a blog post from Android developers blog: [Native Dependencies in Android Studio 4.0](https://android-developers.googleblog.com/2020/02/native-dependencies-in-android-studio-40.html) \n\n_Note for Android Studio users: prefab packages are supported on Android Studio 4+_\n\n## Requirements\n\n1. `ndk <required>`\n\nSet environment variable `ANDROID_NDK_HOME` to your android ndk installation. For example:\n\n````\nexport ANDROID_NDK_HOME=/home/your-account/Android/Sdk/ndk-bundle\n````\n\n2. `7zip <required on windows>` or `zip <required on linux>`\n\n3. `maven <optional>`\n\n4. Android triplets\n\nSee [android.md](../users/android.md) for instructions on how to install the triplets.\n\n*Please note that in order to use \"prefab\" (see below), the four architectures are required. If any is missing the export will fail*\n\n\n## Example exporting [jsoncpp]\n\nFirst \"vcpkg install\" the 4 android architectures (it is mandatory to export all 4 of them)\n\n````\n./vcpkg install jsoncpp:arm-android  jsoncpp:arm64-android  jsoncpp:x64-android  jsoncpp:x86-android\n````\n\n\nThen, export the prefab:\n\nNote:\n* The `--prefab-maven` flag is optional. Call it if you maven is installed.\n* The `--prefab-debug` flag will output instructions on how to use the prefab archive via gradle.\n\n```\n./vcpkg export --triplet x64-android jsoncpp --prefab --prefab-maven --prefab-debug\n```\n\nYou will see an output like this:\n```\nThe following packages are already built and will be exported:\n    jsoncpp:arm64-android\n\nExporting package jsoncpp...\n[DEBUG] Found 4 triplets\n\tarm64-android\n\tx64-android\n\tx86-android\n\tarm-android\n\n...\n... Lots of output...\n...\n\n[INFO] Scanning for projects...\nDownloading from central: https://repo.maven.apache.org/maven2/org/apache/maven/plugins/maven-clean-plugin/2.5/maven-clean-plugin-2.5.pom\n\n...\n... Lots of output...\n...\n\n[INFO] BUILD SUCCESS\n[INFO] Total time:  2.207 s\n[INFO] Finished at: 2020-05-10T14:42:28+02:00\n\n\n...\n... Lots of output...\n...\n\n[DEBUG] Configuration properties in Android Studio\nIn app/build.gradle\n\n\tcom.vcpkg.ndk.support:jsoncpp:1.9.2\n\nAnd cmake flags\n\n    externalNativeBuild {\n                cmake {\n                    arguments '-DANDROID_STL=c++_shared'\n                    cppFlags \"-std=c++17\"\n                }\n            }\n\nIn gradle.properties\n\n    android.enablePrefab=true\n    android.enableParallelJsonGen=false\n    android.prefabVersion=${prefab.version}\n\nSuccessfully exported jsoncpp. Checkout .../vcpkg/prefab \n\n```\n\n#### The output directory after export\n\n````\nprefab\n jsoncpp/\n     aar/\n      AndroidManifest.xml\n      META-INF/\n       LICENSE\n      prefab/\n          modules/\n           jsoncpp/\n               libs/\n                android.arm64-v8a/\n                 abi.json\n                 include/\n                  json/\n                      json.h\n                      ....\n                 libjsoncpp.so\n                android.armeabi-v7a/\n                 abi.json\n                 include/\n                  json/\n                      json.h\n                      ....\n                 libjsoncpp.so\n                android.x86/\n                 abi.json\n                 include/\n                  json/\n                      json.h\n                      ....\n                 libjsoncpp.so\n                android.x86_64/\n                    abi.json\n                    include/\n                     json/\n                      json.h\n                      ....\n                    libjsoncpp.so\n               module.json\n          prefab.json\n     jsoncpp-1.9.2.aar\n     pom.xml\n````\n\n## Example consuming [jsoncpp] via vcpkg and prefab\n\nSee the example repo here:\n\nhttps://github.com/atkawa7/prefab-vpkg-integration-sample\n","Nav":"#"},{"Path":"/en/docs/specifications/registries-2.html","Name":"Registries-2","Source":"# Registries: Take 2 (including Git Registries)\n\n**Note: this is the feature as it was initially specified and does not necessarily reflect the current behavior.**\n\nOriginally, the design of registries was decided upon and written up in the [Registries RFC](registries.md).\nHowever, as we've gotten further into the design process of git registries and versioning,\nand discussed the interaction of versioning with registries,\nit's become clear that the existing design was lacking.\nWe need to have an on-disk port database that is not tied to the ports tree.\n\nThis RFC is a new design for registries, that includes this registry database.\nIt also includes the design for git registries,\nwhich are likely to be the predominant form of registries in the wild.\nThey are also what we will start to treat the default registry as,\nto allow for updating ports without updating the vcpkg executable\n(likely necessary for binary releases).\n\n## Design Considerations\n\nAfter internal discussions of the relationship between versioning and registries,\nit was clear that the existing design of registries does not play well with versioning.\nIt was also clear that it was necessary to have metadata about ports in a separate place from the ports tree;\nin fact, after discussion, it was clear that the ports tree should be considered an implementation detail;\na backing store for build process information (e.g., `portfile.cmake` and the patches) and the manifest.\n\nFrom this, it's clear that vcpkg needs to add a new set of metadata.\nThe versioning implementation has decided on `port_versions`, and thus that's what this RFC uses.\n\nSince we're replacing the existing ports directory with a new method of describing ports,\nthis means that the ports directory is no longer anything but a data store.\nThis also means that the existing rules around locations of ports is no longer required;\nhowever, it will still keep getting followed for the main repository,\nand it's recommended that other registries follow the same pattern to make contributing easier.\n\n## What does the registry database look like?\n\nWe don't wish to have the same problem as we do right now,\nwhere there are nearly 1500 entries in a single directory.\nWe solve this by placing each database entry into `port_versions/<first character of port name>-/<port name>.json`.\nFor example, the database entry for 7zip is in `port_versions/7-/7zip.json`.\n\nEach of these database entries contains all of the versions of the port throughout history,\nalong with versioning and feature metadata, so that we do not have to check out old manifests or CONTROL files\nto get at that information.\n\nEach database entry file must be a top-level array of port version objects, which contain the following entries:\n* A version field: `\"version-string\"`, `\"version\"`, etc. Same as in the manifest.\n* Optionally, `\"port-version\"`: Same as in the manifest.\n\nAnd also contain a description of where to find the build files for this port; the possibilities include:\n\n* `\"git-tree\"`: The [git object ID] of a tree object; this is only allowed for git registries.\n  Note that this ID must be an ID from the repository where the registry is located.\n* `\"path\"`: A path describing where to find the build files.\n  The first entry in this path should be `$`, which means \"this path starts at the root of the registry\".\n  No other kinds of paths are allowed.\n  * For example: `$/foo/bar` gives you `foo/bar` underneath the folder containing the `port_versions` directory.\n  * `/foo/bar` and `foo/bar` are both disallowed.\n\nUsing a `\"git-tree\"` as a backend in a non-git registry, and using a `\"path\"` in a git registry,\nis not permitted. Future extensions may include things like remote archives or git repositories,\nor may allow `\"path\"` in git registries.\n\nNote that a registry entry should _always_ be additive;\ndeleting existing entries is unsupported and may result in bad behavior.\nThe only modification to existing entries that is allowable is moving the backing store\nfor the build files, assuming that the new build files are equivalent to the old build files.\n(For example, a filesystem registry might have a new way of laying out where ports are).\n\nAdditionally, we'd like a new way of describing the set of ports that make up a \"baseline\".\nThis is currently done with the reference of the vcpkg git repository -\neach reference has a set of versions that are tested against each other,\nand this is a major feature of vcpkg.\nWe wish to have the same feature in the new versioning world,\nand so we'll have a set of baseline versions in the registry database.\n\nBaselines act differently between git registries or the builtin registry,\nand in filesystem registries.\nIn git registries and the builtin registry,\nsince there's a history that one can access,\na baseline is the `\"default\"` entry in the baseline at the reference specified.\nIn filesystem registries, since there is no accessible history,\nthe baseline identifiers are mapped directly to entries in the baseline file,\nwithout translation; by default, the `\"default\"` entry is used.\n\nThese baselines are placed in `port_versions/baseline.json`.\nThis is an object mapping baseline names to baseline objects,\nwhere baseline objects map port names to version objects.\nA version object contains `\"baseline\"`, which is un-schemed version,\nand optionally `\"port-version\"`.\n\n[git object ID]: https://git-scm.com/book/en/v2/Git-Internals-Git-Objects\n\n### Example of a baseline file\n\nThe following is a reasonable baseline.json for a filesystem registry that only has two ports:\n\n```json\n{\n  \"default\": {\n    \"abseil\": { \"baseline\": \"2020-03-03\" },\n    \"zlib\": { \"baseline\": \"1.2.11\", \"port-version\": 9 }\n  },\n  \"old\": {\n    \"abseil\": { \"baseline\": \"2019-02-11\" },\n    \"zlib\": { \"baseline\": \"1.2.11\", \"port-version\": 3 }\n  },\n  \"really-old\": {\n    \"zlib\": { \"baseline\": \"1.2.9\" }\n  }\n}\n```\n\n### Example of a registry database entry file\n\nNote: This file assumes that the versions RFC has been implemented,\nand thus that minimum versions are required;\nthe syntax may change in the time between now and finishing the implementation.\n\nThis example is of `ogre`, since this port has both features and dependencies;\nremember that this file would be `port_versions/o-/ogre.json`.\n\n```json\n[\n  {\n    \"version-string\": \"1.12.7\",\n    \"git-tree\": \"466e96fd2e17dd2453aa31dc0bc61bdcf53e7f61\",\n  },\n  {\n    \"version-string\": \"1.12.1\",\n    \"port-version\": 1,\n    \"git-tree\": \"0de81b4f7e0ec24966e929c2ea64e16c15e71d5e\",\n  },\n  ...\n]\n```\n\n#### Filesystem Registry Databases\n\nFilesystem registries are the simplest possible registry;\nthey have a `port_versions` directory at the top-level, which contains the registry database.\nIt's expected that the filesystem registry would have a filesystem backing store:\nsomething like the existing `ports` directory, except with separate versions.\nThere won't be a specific way to lay the ports tree out as mandated by the tool,\nas we are treating the ports tree as an implementation detail of the registry;\nit's simply a way to get the files for a port.\nAs an example, let's assume that the registry is laid out something like this:\n\n```\n<registry>/\n  port_versions/\n    baseline.json\n    a-/\n      abseil.json\n      asmjit.json\n    o-/\n      ogre.json\n  ports/\n    a-/\n      abseil/\n        2020-03-03_7/\n          vcpkg.json\n          portfile.cmake\n          ...\n        2020-03-03_8/\n          vcpkg.json\n          portfile.cmake\n          ...\n        ...\n      asmjit/\n        2020-05-08/\n          CONTROL\n          portfile.cmake\n          ...\n        2020-07-22/\n          vcpkg.json\n          portfile.cmake\n          ...\n    o-/\n      ogre/\n        1.12.7/\n          ...\n        1.12.1/\n          ...\n    ...\n  ...\n```\n\nThen, let's look at updating `asmjit` to latest.\n\nThe current manifest file, in `asmjit/2020-07-22/vcpkg.json` looks like:\n\n```json\n{\n  \"name\": \"asmjit\",\n  \"version-string\": \"2020-07-22\",\n  \"description\": \"Complete x86/x64 JIT and Remote Assembler for C++\",\n  \"homepage\": \"https://github.com/asmjit/asmjit\",\n  \"supports\": \"!arm\"\n}\n```\n\nwhile the current `port_versions/a-/asmjit.json` looks like:\n\n```json\n[\n  {\n    \"version-string\": \"2020-07-22\",\n    \"path\": \"$/ports/a-/asmjit/2020-07-22\"\n  },\n  {\n    \"version-string\": \"2020-05-08\",\n    \"path\": \"$/ports/a-/asmjit/2020-05-08\"\n  }\n]\n```\n\nwith `port_versions/baseline.json` looking like:\n\n```json\n{\n  \"default\": {\n    ...,\n    \"asmjit\": { \"baseline\": \"2020-07-22\" },\n    ...\n  }\n}\n```\n\nand we'd like to update to `2020-10-08`.\nWe should first copy the existing implementation to a new folder:\n\n```sh\n$ cp -r ports/a-/asmjit/2020-07-22 ports/a-/asmjit/2020-10-08\n```\n\nthen, we'll make the edits required to `ports/a-/asmjit/2020-10-08` to update to latest.\nWe should then update `port_versions/a-/asmjit.json`:\n\n```json\n[\n  {\n    \"version-string\": \"2020-10-08\",\n    \"path\": \"$/ports/a-/asmjit/2020-10-08\"\n  },\n  {\n    \"version-string\": \"2020-07-22\",\n    \"path\": \"$/ports/a-/asmjit/2020-07-22\"\n  },\n  {\n    \"version-string\": \"2020-05-08\",\n    \"path\": \"$/ports/a-/asmjit/2020-05-08\"\n  }\n]\n```\n\nand update `port_versions/baseline.json`:\n\n```json\n{\n  \"default\": {\n    ...,\n    \"asmjit\": { \"baseline\": \"2020-10-08\" },\n    ...\n  }\n}\n```\n\nand we're done .\n\n#### Git Registry Databases\n\nGit registries are not quite as simple as filesystem registries,\nbut they're still pretty simple, and are likely to be the most common:\nthe default registry is a git registry, for example.\nThere is not a specific way the tool requires one to lay out the backing store,\nas long as it's possible to get an object hash that corresponds to a checked-in git tree\nof the build information.\nThis allows, for example, the current vcpkg default registry way of laying out ports,\nwhere the latest version of a port `<P>` is at `ports/<P>`,\nand it also allows for any number of other designs.\nOne interesting design, for example,\nis having an `old-ports` branch which is updated whenever someone want to backfill versions;\nthen, one could push the old version to the `old-ports` branch,\nand then update the HEAD branch with the git tree of the old version in `port_versions/p-/<P>`.\n\nAs above, we want to update `asmjit` to latest; let's assume we're working in the default vcpkg registry\n(the <https://github.com/microsoft/vcpkg> repository):\n\nThe current manifest file for `asmjit` looks like:\n\n```json\n{\n  \"name\": \"asmjit\",\n  \"version-string\": \"2020-07-22\",\n  \"description\": \"Complete x86/x64 JIT and Remote Assembler for C++\",\n  \"homepage\": \"https://github.com/asmjit/asmjit\",\n  \"supports\": \"!arm\"\n}\n```\n\nand the current `port_versions/a-/asmjit.json` looks like:\n\n```json\n[\n  {\n    \"version-string\": \"2020-07-22\",\n    \"git-tree\": \"fa0c36ba15b48959ab5a2df3463299e1d2473b6f\"\n  }\n]\n```\n\nNow, let's update it to the latest version:\n\n```json\n{\n  \"name\": \"asmjit\",\n  \"version-string\": \"2020-10-08\",\n  \"description\": \"Complete x86/x64 JIT and Remote Assembler for C++\",\n  \"homepage\": \"https://github.com/asmjit/asmjit\",\n  \"supports\": \"!arm\"\n}\n```\n\nand make the proper edits to the portfile.cmake. Then, let's commit the changes:\n\n```cmd\n> git add ./ports/asmjit\n> git commit -m \"[asmjit] update asmjit to 2020-10-08\"\n```\n\nIn `git-tree` mode, one needs to commit the new version of the port to get the git tree hash;\nwe use `git rev-parse` to do so:\n\n```cmd\n> git rev-parse HEAD:ports/asmjit\n2bb51d8ec8b43bb9b21032185ca8123da10ecc6c\n```\n\nand then modify `port_versions/a-/asmjit.json` as follows:\n\n```json\n[\n  {\n    \"version-string\": \"2020-10-08\",\n    \"git-tree\": \"2bb51d8ec8b43bb9b21032185ca8123da10ecc6c\"\n  },\n  {\n    \"version-string\": \"2020-07-22\",\n    \"git-tree\": \"fa0c36ba15b48959ab5a2df3463299e1d2473b6f\"\n  }\n]\n```\n\nThen we can commit and push this new database with:\n\n```sh\n$ git add port_versions\n$ git commit --amend --no-edit\n$ git push\n```\n\n## Consuming Registries\n\nThe `vcpkg-configuration.json` file from the [first registries RFC](registries.md)\nis still the same, except that the registries have a slightly different layout.\nA `<configuration>` is still an object with the following fields:\n* Optionally, `\"default-registry\"`: A `<registry-implementation>` or `null`\n* Optionally, `\"registries\"`: An array of `<registry>`s\n\nAdditionally, `<registry>` is still the same;\na `<registry-implementation>` object, plus the following properties:\n* Optionally, `\"baseline\"`: A named baseline. Defaults to `\"default\"`.\n* Optionally, `\"packages\"`: An array of `<package-name>`s\n\nhowever, `<registry-implementation>`s are now slightly different:\n* `<registry-implementation.builtin>`:\n  * `\"kind\"`: The string `\"builtin\"`\n* `<registry-implementation.filesystem>`:\n  * `\"kind\"`: The string `\"filesystem\"`\n  * `\"path\"`: A path\n* `<registry-implementation.git>`:\n  * `\"kind\"`: The string `\"git\"`\n  * `\"repository\"`: A URI\n\nThe `\"packages\"` field of distinct registries must be disjoint,\nand each `<registry>` must have at the `\"packages\"` property,\nsince otherwise there's no point.\n\nAs an example, a package which uses a different default registry, and a different registry for boost,\nmight look like the following:\n\n```json\n{\n  \"default-registry\": {\n    \"kind\": \"filesystem\",\n    \"path\": \"vcpkg-ports\"\n  },\n  \"registries\": [\n    {\n      \"kind\": \"builtin\",\n      \"packages\": [ \"cppitertools\" ]\n    }\n  ]\n}\n```\n\nThis will install `fmt` from `<directory-of-vcpkg-configuration.json>/vcpkg-ports`,\nand `cppitertools` and the `boost` ports from the registry that ships with vcpkg.\nNotably, this does not replace behavior up the tree -- only the `vcpkg-configuration.json`s\nfor the current invocation do anything.\n\n### Filesystem Registries\n\nA filesystem registry takes on the form:\n\n* `\"kind\"`: The string `\"filesystem\"`\n* `\"path\"`: The path to the filesystem registry's root, i.e. the directory containing the `port_versions` directory.\n\n```json\n{\n  \"kind\": \"filesystem\",\n  \"path\": \"vcpkg-registry\"\n}\n```\n\nUnlike git registries, where there's quite a bit of interesting stuff going on,\nthere isn't much stuff to do with filesystem registries.\nWe simply use the registry database at `<registry root>/port_versions` to get information about ports.\n\n### Git Registries\n\nA git registry takes on the form:\n\n* `\"kind\"`: The string `\"git\"`\n* `\"repository\"`: The URL at which the git repository lives. May be any kind of URL that git understands\n\n```json\n{\n  \"kind\": \"git\",\n  \"repository\": \"https://github.com/microsoft/vcpkg\"\n}\n```\n\nWhenever the first vcpkg command is run with a git registry,\nvcpkg notes down the exact commit that HEAD points to at the time of the run in the `vcpkg-lock.json` file.\nThis will be used as the commit which vcpkg takes the `\"default\"` baseline from,\nand vcpkg will only update that commit when `vcpkg update` is run.\n\nSince the `\"versions\"` field is strictly additive, we don't consider older refs than `HEAD`.\nWe update the repository on some reasonable clip.\nLikely, whenever a command is run that will change the set of installed ports.\n\n#### `vcpkg-lock.json`\n\nThis file will contain metadata that we need to save across runs,\nto allow us to keep a \"state-of-the-world\" that doesn't change unless one explicitly asks for it to change.\nThis means that, even across different machines, the same registries will be used.\nWe will also be able to write down version resolution in this file as soon as that feature is added.\n\nIt is recommended that one adds this `vcpkg-lock.json` to one's version control.\nThis file is machine generated, and it is not specified how it's laid out;\nhowever, for purposes of this RFC, we will define how it relates to git registries.\n\nIn `vcpkg-lock.json`, in the top level object,\nthere will be a `\"registries\"` property that is an object.\nThis object will contain a `\"git\"` field, which is an array of git-registry objects,\nthat contain:\n\n* `\"repository\"`: The `\"repository\"` field from the git registry object\n* `\"baseline\"`: The name of the baseline that we've used\n* `\"baseline-ref\"`: The ref which we've gotten the specific baseline from.\n\nFor example, a `vcpkg-lock.json` might look like:\n\n```json\n{\n  \"registries\": {\n    \"git\": [\n      {\n        \"repository\": \"https://github.com/microsoft/vcpkg\",\n        \"baseline\": \"default\",\n        \"baseline-ref\": \"6185aa76504a5025f36754324abf307cc776f3da\"\n      }\n    ]\n  }\n}\n```\n\n#### `vcpkg update`\n\nYou'll notice that once the repository is added the first time,\nthere is only one way to update the repository to the tag at a later date - deleting the lock file.\nWe additionally want to add support for the user updating the registry by themselves -\nthey will be able to do this via the `vcpkg update` command.\nThe `vcpkg update` command will, for each git registry,\nupdate the registry and repoint the `\"commit\"` field in `vcpkg-lock.json` to the latest `HEAD`.\n\nThere is no way to update only one git registry to a later date, since versions are strictly additive.\n\n## Git Registries: Implementation on Disk\n\nThere are two implementations on disk to consider here: the implementation of the registry database,\nand once we have the database entries for the ports, accessing the port data from the git tree object.\n\nBoth of these implementations are placed in the vcpkg cache home (shared by binary caching archives).\nOn unix, this is located at `$XDG_CACHE_HOME/vcpkg` if the environment variable exists,\notherwise `$HOME/.cache/vcpkg`; on Windows, it's located at `%LOCALAPPDATA%\\vcpkg`.\nIn this document, we use the variable `$CACHE_ROOT` to refer to this folder.\nWe will add a new folder, `$CACHE_ROOT/registries`, which will contain all the data we need.\n\nFirst, we'll discuss the registry database.\n\n### Registry Database\n\nAt `$CACHE_ROOT/registries/git`,\nwe'll create a new git repository root which contains all information from all git registries,\nsince the hashes should be unique, and this allows for deduplication\nacross repositories which have the same commits (e.g., for mirrors).\nIn order to get the data from git registries, we simply `fetch` the URL of the git registry.\n\nIn order to grab a specific database entry from a git registry, `git show` is used to grab the\nfile from the right commit: `git show <commit id> -- port_versions/<first character>-/<portname>.json`.\n\nOne unfortunate thing about having one directory being used for all vcpkg instances on a machine is\nthat it's possible to have an issue with concurrency - for example, after `fetch`ing the latest HEAD\nof `https://github.com/microsoft/vcpkg`, another vcpkg process might fetch the latest HEAD of\n`https://github.com/meow/vcpkg` before the first vcpkg process has the chance to `git rev-parse FETCH_HEAD`.\nSince the first vcpkg process will run `git rev-parse` after the second fetch is done,\ninstead of getting the `HEAD` of `microsoft/vcpkg`, they instead get the `HEAD` of `meow/vcpkg`.\nWe will solve this by having a mutex file in `$CACHE_ROOT/registries/git`\nthat vcpkg locks before any fetches (and unlocks after `rev-parse`ing).\n\n### Accessing Port Data from `git-tree`s\n\nOnce we've done version resolution and everything with the database,\nwe then need to access the port data from the git history.\nWe will add a new folder, `$CACHE_ROOT/registries/git-trees`, into which we'll check out the port data.\n\nIn this `git-trees` directory, we will have all of the trees we check out, at their hashes.\nFor example, the asmjit port data from above will be located at\n`git-trees/2bb51d8ec8b43bb9b21032185ca8123da10ecc6c`.\nWe will add a mutex file in this `git-trees` directory as well which is taken whenever\nwe are checking out a new git tree.\nWe wish to allow multiple vcpkg instances to read port data at a time,\nand thus we do the check outs semi-atomically - if `git-trees/<hash>` exists,\nthen the `<hash>` must be completely checked out.\nvcpkg does this by first checking out to a temporary directory,\nand then renaming to the actual hash.\n\n## Future Extensions\n\nThe way forward for this is to allow the `\"builtin\"` registry to be a git registry,\nin order to support packaging and shipping vcpkg as a binary.\nThis is currently our plan, although it definitely is still a ways out.\nGit registries _are_ an important step on that road,\nbut are also a good way to support both enterprise,\nand experimentation by our users.\nThey allow us a lot more flexibility than we've had in the past.","Nav":"#"},{"Path":"/en/docs/specifications/registries.html","Name":"Registries","Source":"# Package Federation: Custom Registries\n\n**Note: this is the feature as it was initially specified and does not necessarily reflect the current behavior.**\n\nAs it is now, vcpkg has over 1400 ports in the default registry (the `/ports` directory).\nFor the majority of users, this repository of packages is enough. However, many enterprises\nneed to more closely control their dependencies for one reason or another, and this document\nlays out a method which we will build into vcpkg for exactly that reason.\n\n## Background\n\nA registry is simply a set of packages. In fact, there is already a registry in vcpkg: the default one.\nPackage federation, implemented via custom registries, allows one to add new packages,\nedit existing packages, and have as much or as little control as one likes over the dependencies that one uses.\nIt gives the control over dependencies that an enterprise requires.\n\n### How Does the Current Default Registry Work?\n\nOf course, the existing vcpkg tool does have packages in the official,\ndefault registry. The way we describe these packages is in the ports tree \nat the base of the vcpkg install directory, there is a directory named ports,\nwhich contains on the order of 1300 directories, one for each package. Then,\nin each package directory, there are at least two files: a CONTROL or\nvcpkg.json file, which contains the name, version, description, and features\nof the package; and a portfile.cmake file which contains the information on\nhow to download and build the package. There may be other files in this\nregistry, like patches or usage instructions, but only those two files are\nneeded.\n\n### Existing vcpkg Registry-like Features\n\nThere are some existing features in vcpkg that act somewhat like a custom\nregistry. The most obvious feature that we have is overlay ports  this\nfeature allows you to specify any number of directories as \"overlays\", which\neither contain a package definition directly, or which contain some number of\npackage directories; these overlays will be used instead of the ports tree\nfor packages that exist in both places, and are specified exclusively on the\ncommand line. Additionally, unfortunately, if one installs a package from\noverlay ports that does not exist in the ports tree, one must pass these\noverlays to every vcpkg installation command.\n\nThere is also the less obvious \"feature\" which works by virtue of the ports\ntree being user-editable: one can always edit the ports tree on their own\nmachine, and can even fork vcpkg and publish their own ports tree.\nUnfortunately, this then means that any updates to the source tree require\nmerges, as opposed to being able to fast-forward to the newest sources.\n\n### Why Registries?\n\nThere are many reasons to want custom registries; however, the most important reasons are:\n\n* Legal requirements  a company like Microsoft or Google\n  needs the ability to strictly control the code that goes into their products,\n  making certain that they are following the licenses strictly.\n  * There have been examples in the past where a library which is licensed under certain terms contains code\n    which is not legally allowed to be licensed under those terms (see [this example][legal-example],\n    where a person tried to merge Microsoft-owned, Apache-licensed code into the GPL-licensed libstdc++).\n* Technical requirements  a company may wish to run their own tests on the packages they ship,\n  such as [fuzzing].\n* Other requirements  an organization may wish to strictly control its dependencies for a myriad of other reasons.\n* Newer versions  vcpkg may not necessarily always be up to date for all libraries in our registry,\n  and an organization may require a newer version than we ship;\n  they can very easily update this package and have the version that they want.\n* Port modifications  vcpkg has somewhat strict policies on port modifications,\n  and an organization may wish to make different modifications than we do.\n  It may allow that organization to make certain that the package works on triplets\n  that our team does not test as extensively.\n* Testing  just like port modifications, if a team wants to do specific testing on triplets they care about,\n  they can do so via their custom registry.\n\nThen, there is the question of why vcpkg needs a new solution for custom registries,\nbeyond the existing overlay ports feature. There are two big reasons \nthe first is to allow a project to define the registries that they use for their dependencies,\nand the second is the clear advantage in the user experience of the vcpkg tool.\nIf a project requires specific packages to come from specific registries,\nthey can do so without worrying that a user accidentally misses the overlay ports part of a command.\nAdditionally, beyond a feature which makes overlay ports easier to use,\ncustom registries allow for more complex and useful infrastructure around registries.\nIn the initial custom registry implementation, we will allow overlay ports style paths,\nas well as git repositories, which means that people can run and use custom registries\nwithout writing their own infrastructure around getting people that registry.\n\nIt is the intention of vcpkg to be the most user-friendly package manager for C++,\nand this allows us to fulfill on that intention even further.\nAs opposed to having to write `--overlay-ports=path/to/overlay` for every command one runs,\nor adding an environment variable `VCPKG_OVERLAY_PORTS`,\none can simply write vcpkg install and the registries will be taken care of for you.\nAs opposed to having to use git submodules, or custom registry code for every project,\none can write and run the infrastructure in one place,\nand every project that uses that registry requires only a few lines of JSON.\n\n[legal-example]: https://gcc.gnu.org/legacy-ml/libstdc++/2019-09/msg00054.html\n[fuzzing]: https://en.wikipedia.org/wiki/Fuzzing\n\n## Specification\n\nWe will be adding a new file that vcpkg understands - `vcpkg-configuration.json`.\nThe way that vcpkg will find this file is different depending on what mode vcpkg is in:\nin classic mode, vcpkg finds this file alongside the vcpkg binary, in the root directory.\nIn manifest mode, vcpkg finds this file alongside the manifest. For the initial implementation,\nthis is all vcpkg will look for; however, in the future, vcpkg will walk the tree and include\nconfiguration all along the way: this allows for overriding defaults.\nThe specific algorithm for applying this is not yet defined, since currently only one\n`vcpkg-configuration.json` is allowed.\n\nThe only thing allowed in a `vcpkg-configuration.json` is a `<configuration>` object.\n\nA `<configuration>` is an object:\n* Optionally, `\"default-registry\"`: A `<registry-implementation>` or `null`\n* Optionally, `\"registries\"`: An array of `<registry>`s\n\nSince this is the first RFC that adds anything to this field,\nas of now the only properties that can live in that object will be\nthese.\n\nA `<registry-implementation>` is an object matching one of the following:\n* `<registry-implementation.builtin>`:\n  * `\"kind\"`: The string `\"builtin\"`\n* `<registry-implementation.directory>`:\n  * `\"kind\"`: The string `\"directory\"`\n  * `\"path\"`: A path\n* `<registry-implementation.git>`:\n  * `\"kind\"`: The string `\"git\"`\n  * `\"repository\"`: A URI\n  * Optionally, `\"path\"`: An absolute path into the git repository\n  * Optionally, `\"ref\"`: A git reference\n\nA `<registry>` is a `<registry-implementation>` object, plus the following properties:\n* Optionally, `\"scopes\"`: An array of `<package-name>`s\n* Optionally, `\"packages\"`: An array of `<package-name>`s\n\nThe `\"packages\"` and `\"scopes\"` fields of distinct registries must be disjoint,\nand each `<registry>` must have at least one of the `\"scopes\"` and `\"packages\"` property,\nsince otherwise there's no point.\n\nAs an example, a package which uses a different default registry, and a different registry for boost,\nmight look like the following:\n\n```json\n{\n  \"default-registry\": {\n    \"kind\": \"directory\",\n    \"path\": \"vcpkg-ports\"\n  },\n  \"registries\": [\n    {\n      \"kind\": \"git\",\n      \"repository\": \"https://github.com/boostorg/vcpkg-ports\",\n      \"ref\": \"v1.73.0\",\n      \"scopes\": [ \"boost\" ]\n    },\n    {\n      \"kind\": \"builtin\",\n      \"packages\": [ \"cppitertools\" ]\n    }\n  ]\n}\n```\n\nThis will install `fmt` from `<directory-of-vcpkg.json>/vcpkg-ports`,\n`cppitertools` from the registry that ships with vcpkg,\nand any `boost` dependencies from `https://github.com/boostorg/vcpkg-ports`.\nNotably, this does not replace behavior up the tree -- only the `vcpkg-configuration.json`s\nfor the current invocation do anything.\n\n### Behavior\n\nWhen a vcpkg command requires the installation of dependencies,\nit will generate the initial list of dependencies from the package,\nand then run the following algorithm on each dependency:\n\n1. Figure out which registry the package should come from by doing the following:\n    1. If there is a registry in the registry set which contains the dependency name in the `\"packages\"` array,\n      then use that registry.\n    2. For every scope, in order from most specific to least,\n      if there is a registry in the registry set which contains that scope in the `\"scopes\"` array,\n      then use that registry.\n      (For example, for `\"cat.meow.cute\"`, check first for `\"cat.meow.cute\"`, then `\"cat.meow\"`, then `\"cat\"`).\n    3. If the default registry is not `null`, use that registry.\n    4. Else, error.\n2. Then, add that package's dependencies to the list of packages to find, and repeat for the next dependency.\n\nvcpkg will also rerun this algorithm whenever an install is run with different configuration.\n\n### How Registries are Laid Out\n\nThere are three kinds of registries, but they only differ in how the registry gets onto one's filesystem.\nOnce the registry is there, package lookup runs the same, with each kind having it's own way of defining its\nown root.\n\nIn order to find a port `meow` in a registry with root `R`, vcpkg first sees if `R/meow` exists;\nif it does, then the port root is `R/meow`. Otherwise, see if `R/m-` exists; if it does,\nthen the port root is `R/m-/meow`. (note: this algorithm may be extended further in the future).\n\nFor example, given the following port root:\n\n```\nR/\n  abseil/...\n  b-/\n    boost/...\n    boost-build/...\n    banana/...\n  banana/...\n```\n\nThe port root for `abseil` is `R/abseil`; the port root for `boost` is `R/b-/boost`;\nthe port root for `banana` is `R/banana` (although this duplication is not recommended).\n\nThe reason we are making this change to allow more levels in the ports tree is that ~1300\nports are hard to look through in a tree view, and this allows us to see only the ports we're\ninterested in. Additionally, no port name may end in a `-`, so this means that these port subdirectories\nwill never intersect with actual ports. Additionally, since we use only ASCII for port names,\nwe don't have to worry about graphemes vs. code units vs. code points -- in ASCII, they are equivalent.\n\nLet's now look at how different registry kinds work:\n\n#### `<registry.builtin>`\n\nFor a `<registry.builtin>`, there is no configuration required.\nThe registry root is simply `<vcpkg-root>/ports`.\n\n#### `<registry.directory>`\n\nFor a `<registry.directory>`, it is again fairly simple.\nGiven `$path` the value of the `\"path\"` property, the registry root is either:\n\n* If `$path` is absolute, then the registry root is `$path`.\n* If `$path` is drive-relative (only important on Windows), the registry root is\n  `(drive of vcpkg.json)/$path`\n* If `$path` is relative, the registry root is `(directory of vcpkg.json)/$path`\n\nNote that the path to vcpkg.json is _not_ canonicalized; it is used exactly as it is seen by vcpkg.\n\n#### `<registry.git>`\n\nThis registry is the most complex. We would like to cache existing registries,\nbut we don't want to ignore new updates to the registry.\nIt is the opinion of the author that we want to find more updates than not,\nso we will update the registry whenever the `vcpkg.json` or `vcpkg-configuration.json`\nis modified. We will do so by keeping a sha512 of the `vcpkg.json` and `vcpkg-configuration.json`\ninside the `vcpkg-installed` directory.\n\nWe will download the specific ref of the repository to a central location (and update as needed),\nand the root will be either: `<path to repository>`, if the `\"path\"` property is not defined,\nor else `<path to repository>/<path property>` if it is defined.\nThe `\"path\"` property must be absolute, without a drive, and will be treated as relative to\nthe path to the repository. For example:\n\n```json\n{\n  \"kind\": \"git\",\n  \"repository\": \"https://github.com/microsoft/vcpkg\",\n  \"path\": \"/ports\"\n}\n```\n\nis the correct way to refer to the registry built in to vcpkg, at the latest version.\n\nThe following are all incorrect:\n\n```json\n{\n  \"$reason\": \"path can't be drive-absolute\",\n  \"kind\": \"git\",\n  \"repository\": \"https://github.com/microsoft/vcpkg\",\n  \"path\": \"F:/ports\"\n}\n```\n\n```json\n{\n  \"$reason\": \"path can't be relative\",\n  \"kind\": \"git\",\n  \"repository\": \"https://github.com/microsoft/vcpkg\",\n  \"path\": \"ports\"\n}\n```\n\n```json\n{\n  \"$reason\": \"path _really_ can't be relative like that\",\n  \"kind\": \"git\",\n  \"repository\": \"https://github.com/microsoft/vcpkg\",\n  \"path\": \"../../meow/ports\"\n}\n```\n","Nav":"#"},{"Path":"/en/docs/specifications/scripts-extraction.html","Name":"Scripts-extraction","Source":"# Scripts Tree Extraction\r\n\r\n**Note: this is the feature as it was initially specified and does not necessarily reflect the current behavior.**\r\n\r\n## Background\r\n\r\nWe extracted vcpkg-tool as part of a future wherein Registries are the primary mechanism for interacting with the ports tree, which would allow the vcpkg tool and associated artifacts to be deployed and figure the rest out on their own. Unfortunately, we have concurrently edited things in the so called \"scripts\" tree which lives in support of ports but really probably belongs in the vcpkg-tool repo.\r\n\r\nMoreover, as part of stabilizing registries, the interface exposed by the scripts tree becomes contractual rather than something we can change in concert with ports, since we can no longer see the universe of ports to validate that changes are correct.\r\n\r\nTo that end we are auditing the contents of the scripts tree to make sure it is a solid foundation for future work.\r\n\r\nThe work list is contained in [Issue #16188].\r\n\r\n[Issue #16188]: https://github.com/microsoft/vcpkg/issues/16188\r\n\r\n## Audit Points\r\n\r\nThe following are assertions we want to be able to make about the contents of the scripts tree. Note that this does *not* refer to `vcpkg.cmake` since that needs to work with older versions of cmake.\r\n\r\nThese are design ideals that we may break in some limited cases where that makes sense.\r\n\r\n- We always use `cmake_parse_arguments` rather than function parameters, or referring to `${ARG<N>}`.\r\n  - Exception: there are exclusively positional parameters. This should be _very rare_.\r\n    - In this case, positional parameters should be put in the function declaration\r\n      (rather than using `${ARG<N>}`), and should be named according to local rules\r\n      (i.e. `snake_case`).\r\n    - Exception: positional parameters that are optional should be given a name via\r\n      `set(argument_name \"${ARG<N>}\") after checking `${ARGC}`.\r\n  - Note: in cases where there are positional parameters along with non-positional parameters, positional parameters should be referred to by `arg_UNPARSED_ARGUMENTS`.\r\n- All `cmake_parse_arguments` use `PARSE_ARGV` for resistance to embedded semicolons.\r\n- All `foreach` loops use `IN LISTS` for resistance to embedded semicolons.\r\n- The variable `${ARGV}` is unreferenced.\r\n- We use functions, not macros or top level code.\r\n- Scripts in the scripts tree should not be expected to need changes as part of normal operation. (For example, `vcpkg_acquire_msys` has hard coded specific packages and versions thereof used which we believe is unacceptable)\r\n- All non-splat variable expansions are in quotes \"\".\r\n- There are no \"pointer\" parameters (where a user passes a variable name rather than the contents) except for out parameters.\r\n- Undefined names are not referenced.\r\n- Out parameters only set `PARENT_SCOPE`.\r\n- `CACHE` variables are not used.\r\n- `include()`s are removed and fixes to `port.cmake` et al. are made as necessary to avoid this.\r\n- `foreach(RANGE)`'s arguments _must always be_ natural numbers, and `<start>` _must always be_ less than or equal to `<stop>`.\r\n  - This should be checked.\r\n\r\n### Naming Variables\r\n\r\n- `cmake_parse_arguments`: set prefix to `\"arg\"`\r\n- local variables are named `snake_case`\r\n- Internal global variable names are named `Z_VCPKG_`.\r\n- External experimental global variable names are named `X_VCPKG_`.\r\n- Internal functions are named `z_vcpkg_*`\r\n  - Functions which are internal to a single function (i.e., helper functions)\r\n    are named `[z_]<func>_<name>`, where `<func>` is the name of the function they are\r\n    a helper to, and `<name>` is what the helper function does.\r\n    - `z_` should be added to the front if `<func>` doesn't have a `z_`,\r\n      but don't name a helper function `z_z_foo_bar`.\r\n- Public global variables are named `VCPKG_`.\r\n\r\n## Prognosis\r\n\r\nNot everything should remain in the scripts tree. As part of this audit, each helper will be dealt with in one of several ways:\r\n\r\n- Stay in scripts tree\r\n- Deleted outright\r\n- Moved to a tool port\r\n- Deprecated\r\n","Nav":"#"},{"Path":"/en/docs/specifications/versioning.html","Name":"Versioning","Source":"# Versioning Specification \r\n\r\n**Note: this is the feature as it was initially specified and does not necessarily reflect the current behavior.**\r\n\r\n**Up-to-date documentation is available at [Versioning](../users/versioning.md).**\r\n\r\n## Glossary\r\nSome of the terms used in this document have similar meaning when discussed by the community, and because of that, they can cause confusion and ambiguity. To solve this issue, we will assign specific meaning to these terms and try to keep a consistent usage through the document.\r\n\r\n**Library**: A piece of software (source code, binary files, documentation, license, etc.) that is intended to be reused by other software.\r\n\r\n**Package**: A package can contain a library, collection of libraries, build scripts, software tools, or other components necessary for their use. The goal of vcpkg is to facilitate the installation of these packages in the user's environment.\r\n\r\n**Port**: A vcpkg specific term, a port contains:\r\n\r\n* Metadata about a package: package version, supported features, dependencies, etc.\r\n* Instructions to acquire, build if necessary, and install the package.\r\n\r\n## 1 Enabling package versioning\r\nOn launch, the versioning feature will be disabled by default. Users can enable this feature by setting the `versions` feature flag.\r\n\r\nExample:\r\n```\r\nvcpkg --feature-flags=versions install\r\n```\r\n\r\n### 1.1 Proposed experience\r\nThis feature requires the use of manifests to declare project dependencies. To allow versioning, the following features are added to manifests:\r\n\r\n* Ability to declare a package's versioning scheme.\r\n* Ability to declare version constraints on dependencies.\r\n* Ability for a top-level manifest to override all other version constraints.\r\n* Ability to declare a baseline for all versions.\r\n\r\nExample: A manifest (`vcpkg.json`) using versioning features.\r\n```json\r\n{\r\n  \"name\": \"versions-test\",\r\n  \"version\": \"1.0.0\",\r\n  \"dependencies\": [\"fmt\", {\"name\": \"zlib\", \"version>=\": \"1.2.11\"}],\r\n  \"$x-default-baseline\": \"9fd3bd594f41afb8747e20f6ac9619f26f333cbe\"\r\n}\r\n```\r\n\r\nThe example above shows some new manifest properties:\r\n* `\"version\"`: Declares a version using a dot-separated versioning scheme (`1.0.0`).\r\n* `\"version>=\"`: Declares a minimum version constraint on package `zlib`.\r\n* `\"$x-default-baseline\"`: Declares a baseline version for all packages.\r\n\r\nAll these new features are described in more detail in this document.\r\n\r\n## 2 Specifying package versions\r\nThrough the years, C++ software authors have adopted multiple versioning schemes and practices that sometimes conflict between each other. On vcpkg, the most recurrent versioning schemes found are:\r\n*\tSemantic versions\r\n*\tDates\r\n*\tRepository commits\r\n*\tArbitrary strings\r\n\r\nFor vcpkg to achieve wide adoption and compatibility with existing projects, it is important that we respect the versioning schemes used by each of the packages contained in our ports catalog.\r\n\r\n### 2.1 Port versions\r\nPackage versioning information is divided in two parts: a version string and a port version. \r\nPort versions are a concept exclusive to vcpkg, they do not form part of a packages upstream. But allow for versioning of the vcpkg ports themselves. \r\n\r\nPackages can also include the port version as part of a version constraint by using the port-version property on their dependencies.\r\n\r\n#### `port-version`\r\n\r\nAn integer value that increases each time a vcpkg-specific change is made to the port.  \r\n\r\nThe rules for port versions are:\r\n* Start at 0 for the original version of the port,\r\n* increase by 1 each time a vcpkg-specific change is made to the port that does not increase the version of the package,\r\n* and reset to 0 each time the version of the package is updated.\r\n\r\nDefaults to 0 if omitted.\r\n\r\n### 2.2 Package versions\r\nVersions are an important part of a packages upstream metadata. Ports in vcpkg should attempt to follow the versioning conventions used by the packages authors. For that reason, when declaring a packages version the appropriate scheme should be used.\r\n\r\nEach versioning scheme defines their own rules on what is a valid version string and more importantly the rules for how to sort versions using the same scheme.\r\n\r\nThe versioning schemes understood by vcpkg are:\r\n\r\nManifest property | Versioning scheme\r\n------------------|------------------------------------\r\n`version`         | For dot-separated numeric versions\r\n`version-semver`  | For SemVer compliant versions\r\n`version-date`    | For dates in the format YYYY-MM-DD\r\n`version-string`  | For arbitrary strings\r\n\r\nA manifest must contain only one version declaration.\r\n\r\n#### `version`\r\nAccepts version strings that follow a relaxed, dot-separated-, semver-like scheme.\r\n\r\nThe version is logically composed of dot-separated (`.`) numeric sections. Each section must contain an integer positive number with no leading zeroes.\r\n\r\nThe regex pattern for this versioning scheme is: `(0|[1-9]\\d*)(\\.(0|[1-9]\\d*))*`\r\n\r\n_Sorting behavior_: When comparing two versions, each section is compared from left to right by their numeric value, until the first difference is found. A version with the smallest set of sections takes precedence over another with a larger set of sections, given that all their preceding sections compare equally.\r\n\r\nExample:  \r\n`0` < `0.1` < `0.1.0` < `1` < `1.0.0` < `1.0.1` < `1.1`< `2.0.0`\r\n\r\n#### `version-semver`\r\nAccepts version strings that follow semantic versioning conventions as described in the [semantic versioning specification](https://semver.org/#semantic-versioning-specification-semver).\r\n\r\n_Sorting behavior_: Strings are sorted following the rules described in the semantic versioning specification.\r\n\r\nExample: \r\n`1.0.0-1` < `1.0.0-alpha` < `1.0.0-beta` < `1.0.0` < `1.0.1` < `1.1.0`\r\n\r\n#### `version-date`\r\n\r\nAccepts version strings that can be parsed to a date following the ISO-8601 format `YYYY-MM-DD`. Disambiguation identifiers are allowed in the form of dot-separated-, positive-, integer-numbers with no leading zeroes.\r\n\r\nThe regex pattern for this versioning scheme is: `\\d{4}-\\d{2}-\\d{2}(\\.(0|[1-9]\\d*))*`.\r\n\r\n_Sorting behavior_: Strings are sorted first by their date part, then by numeric comparison of their disambiguation identifiers. Disambiguation identifiers follow the rules of the relaxed (version) scheme.\r\n\r\nExamples:\r\n`2020-01-01` < `2020-01-01.1` < `2020-02-01.1.2` < `2020-02-01.1.3` < `2020-02-01`\r\n\r\n#### `version-string`\r\nFor packages using version strings that do not fit any of the other schemes, it accepts most arbitrary strings, but some special characters like `#` are disallowed.\r\n\r\n_Sorting behavior_: No sorting is attempted on the version string itself. However, if the strings match exactly, the port versions can be compared and sorted.\r\n\r\nExamples: \r\n`apple` <> `orange` <> `orange.2` <> `orange2`  \r\n`watermelon` (`port-version`: 0) < `watermelon` (`port-version`: 1)\r\n\r\n##### Example: Manifests using different versioning schemes\r\n```json\r\n{\r\n    \"name\": \"openssl\",\r\n    \"version\": \"1.1.1\",\r\n    \"port-version\": 0\r\n}\r\n```\r\n```json\r\n{\r\n    \"name\": \"bzip2\",\r\n    \"version-semver\": \"1.0.8\",\r\n}\r\n```\r\n```json\r\n{\r\n    \"name\": \"abseil\",\r\n    \"version-date\": \"2020-03-03\",\r\n    \"port-version\": 8\r\n}\r\n```\r\n```json\r\n{\r\n    \"name\": \"d3dx12\",\r\n    \"version-string\": \"may2020\",\r\n    \"port-version\": 0\r\n}\r\n```\r\n\r\n## 3 Specifying dependency versions\r\n\r\n### 3.1 On manifest files\r\nManifest files help users specify complex versioned dependency graphs in a declarative manner. In this document we define a top-level manifest as the manifest file written by a user to declare their projects dependencies. This is opposed to a ports manifest file, which is used by ports to declare the dependencies of the package it contains.\r\n\r\nThere are three mechanisms you can use in your manifest files to control which versions of your packages are installed: **version constraints, registry baselines and overrides**.\r\n\r\n#### Version constraints\r\nSpecifying a version constraint is the most direct way to control which version of a package is installed, in vcpkg you can declare minimum version constraints using the syntax `\"version>=\": \"1.0.0\"`.\r\n\r\n#### Registry baseline\r\nBaselines are used to set lower boundaries on package versions. A baseline effectively adds a minimum version constraint on all the packages declared in it.\r\n\r\nBut what is a baseline?\r\n\r\nIn the main registry, the baseline is a file located in `${VCPKG_ROOT}/versions/baseline.json`. This file contains a version declaration for each package in vcpkg. The format of this file is the following:\r\n\r\n```json\r\n{\r\n    \"default\": [\r\n      {\r\n        ...\r\n        \"fmt\": { \"version-semver\": \"7.1.2\", \"port-version\": 0},\r\n        ...\r\n      }\r\n    ]\r\n}\r\n```\r\n\r\nThe baseline file is tracked under source control. For any given revision of the registry, the versions declared in the baseline file must match the current versions of the ports in the registry at that revision.\r\n\r\nOld revisions of vcpkg that do not contain a baseline file can still work with versioning. As a fallback, if no baseline is available at a given revision, vcpkg will use its local baseline file. If a local baseline file does not exist, the local version of the port will be used as the baseline version.\r\n\r\nBaselines define a minimum version constraint an all packages contained in it.\r\n\r\nFor example, if the baseline contains the entry:\r\n```\r\nfmt: { version-semver: 7.1.2, port-version: 0 }\r\n```\r\n\r\nA minimum version constraint will be added to `fmt` so that vcpkg wont install a version lower than `7.1.2` with port version `0`.\r\n\r\n#### Overrides\r\nDeclaring an override forces vcpkg to ignore all other constraints, both top-level and transitive constraints, and use the version specified in the override. This is useful for pinning exact versions and for resolving version conflicts.\r\n\r\n## 4 Version constraints\r\n\r\n### 4.1 Declaring a baseline\r\nFor the initial implementation, the method to declare a baseline is to set the `$x-default-baseline` property.\r\n\r\nThe use of `$x-default-baseline` is temporary and will very likely change in the future, as we work on implementing custom registries. \r\n\r\n#### `$x-default-baseline`\r\nAccepts a Git commit ID. Vcpkg will try to find a baseline file in the given commit ID and use that to set the baseline versions (lower bound versions) of all declared dependencies.\r\n\r\nWhen resolving version constraints for a package, vcpkg will look for a baseline version:\r\n* First by looking at the baseline file in the given commit ID.\r\n* If the given commit ID does not contain a baseline file, vcpkg will fallback to use the local baseline file instead.\r\n* If theres no local baseline file, vcpkg will use the version currently available in the ports directory.\r\n\r\n_NOTE: If a baseline file is found, but it does not contain an entry for the package, the vcpkg invocation will fail._\r\n\r\nExample:\r\n```json\r\n{\r\n  \"name\": \"project\", \r\n  \"version\": \"1.0.0\",\r\n  \"dependencies\": [\"zlib\", \"fmt\"],\r\n  \"$x-default-baseline\":\"9fd3bd594f41afb8747e20f6ac9619f26f333cbe\"\r\n}\r\n```\r\n\r\nBaselines can be used without any other version constraints to obtain behavior close to using classic mode. \r\n\r\n### 4.2 Declaring minimum version constraints\r\nA minimum version requirement puts a lower boundary on the versions that can be used to satisfy a dependency. This means that any version that is newer than the requirement is valid (including major version changes).\r\n\r\nVcpkg will use the oldest identified version that can satisfy all the version requirements in a build graph. Using a minimum version approach has the following advantages:\r\n* Is predictable and easy to understand.\r\n* User controls when upgrades happen, as in, no upgrades are performed automatically when a new version is released.\r\n* Avoids using a SAT solver.\r\n\r\nMinimum version requirements are expressed by using the `\"version>=\"` property in the dependencies list.\r\n\r\nExample:\r\n```json\r\n{\r\n  \"name\": \"project\",\r\n  \"version-semver\": \"1.0.0\",\r\n  \"dependencies\": [\r\n    { \"name\": \"zlib\", \"version>=\": \"1.2\" },\r\n    { \"name\": \"rapidjson\", \"version>=\": \"2020-02-01\" }\r\n  ]\r\n}\r\n```\r\n\r\n### 4.3 Declaring port version constraints\r\nTo be consistent with the minimum version approach, vcpkg uses the lowest available port version that matches the package version. There are many scenarios where a higher port version is desirable, e.g.: support for new platforms, fixing installation issues, among others.\r\n\r\nAs part of the dependency object a port version can be specified. An error will be emitted if a non-existent port-version for the given package version is requested.\r\n\r\nExample:\r\n```json\r\n{\r\n  \"name\": \"project\",\r\n  \"version-semver\": \"1.0.0\",\r\n  \"dependencies\": [\r\n    { \"name\": \"zlib\", \"version>=\": \"1.2\" },\r\n    { \"name\": \"rapidjson\", \"version=\": \"2020-02-01\", \"port-version\": 2 }\r\n  ]\r\n}\r\n```\r\n\r\n### 4.4 Declaring overrides\r\nOverrides are declared as an array of package version declarations.\r\n\r\nFor an override to take effect, the overridden package must form part of the dependency graph. That means that a dependency must be declared either by the top-level manifest or be part of a transitive dependency.\r\n\r\nExample:\r\n```json\r\n{\r\n  \"name\": \"project\", \r\n  \"version\": \"1.0.0\",\r\n  \"dependencies\": [\"cpprestsdk\"],\r\n  \"overrides\": [{\"name\":\"zlib\", \"version-semver\":\"1.2.10\"}],\r\n  \"$x-default-baseline\":\"9fd3bd594f41afb8747e20f6ac9619f26f333cbe\"\r\n}\r\n```\r\n\r\nIn the previous example, `zlib` is not a direct dependency of the project but it is a dependency for `cpprestsdk`, so the override takes effect forcing `zlib` to version `1.2.10`.\r\n\r\n## 5 Design considerations\r\n\r\n### 5.1 Constraint resolution\r\nGiven a manifest with a set of versioned dependencies, vcpkg will attempt to calculate a package installation plan that satisfies all the constraints. Constraints can be declared in the top-level manifest but can also be added transitively by indirect dependencies. \r\n\r\nVcpkg roughly follows the steps below to compute an installation plan, the installation plan will either contain a valid set of package versions, or a list of version conflicts.\r\n\r\n* Add all top-level constraints to the plan.\r\n* Recursively add transitive constraints to the plan.\r\n* Each time a constraint is added for a package, also add its baseline version as a minimum constraint.\r\n* Each time a constraint is added:\r\n  * If an override exists for the package, select the version in the override.\r\n  * Otherwise:\r\n    * If there is no previous version selected. \r\n      * Select the minimal version that satisfies the constraint.\r\n    * If there is a previous version selected:\r\n      * If the versioning scheme of the new constraint does not match that of the previously selected version:\r\n        * Add a version conflict.\r\n      * If the constraints version is not comparable to the previously selected version. For example, comparing version-string: apple to version-string: orange:\r\n        * Add a version conflict.\r\n    * If the constraints version is higher than the previously selected version:\r\n      * Select the highest version.\r\n      * Otherwise, keep the previous selection.\r\n*\tReview the plan:\r\n  * If there are no conflicts, install the selected packages.\r\n  * Otherwise, report the conflicts to the user.\r\n\r\n### 5.2 Acquiring port versions\r\nAlthough the concept of package versions has always been present in vcpkg, the concept of version constraints has been not. \r\n\r\nWith the introduction of versioning constraints, it is now possible that a package depends on a port version that does not match the one available locally.  This raises a problem as vcpkg needs to know how to acquire the port files for the requested version.\r\n\r\nTo solve this problem, a new set of metadata needs to be introduced. This specification proposes a that a new \"versions\" folder is added as part of a registry. In the main vcpkg registry, this means a new root level versions directory. \r\n\r\nThe versions directory, from here on referred as the versions database, will contain JSON files for each one of the ports available in the registry. Each file will list all the versions available for a package and contain a Git tree-ish object that vcpkg can check out to obtain that versions portfiles. \r\n\r\nAs part of the versioning implementation, a generator for these database files will be implemented. The generator will extract from our repositorys Git history, all the versions of each port that had been available at any moment in time and compile them into these database files. \r\n\r\nExample: generated `zlib.json`\r\n```json\r\n{\r\n  \"versions\": [\r\n    {\r\n      \"git-tree\": \"2dfc991c739ab9f2605c2ad91a58a7982eb15687\",\r\n      \"version-string\": \"1.2.11\",\r\n      \"port-version\": 9\r\n    },\r\n    { $truncated for brevity },\r\n    {\r\n      \"git-tree\": \"a516e5ee220c8250f21821077d0e3dd517f02631\",\r\n      \"version-string\": \"1.2.10\",\r\n      \"port-version\": 0\r\n    },\r\n    {\r\n      \"git-tree\": \"3309ec82cd96d752ff890c441cb20ef49b52bf94\",\r\n      \"version-string\": \"1.2.8\",\r\n      \"port-version\": 0\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\nFor each port, its corresponding versions file should be located in  `versions/{first letter of port name}-/{port name}.json`. For example, zlibs version file will be located in `versions/z-/zlib.json`.\r\nAside from port version files, the current baseline file is located in `versions/baseline.json`. \r\n","Nav":"#"},{"Path":"/en/docs/users/android.html","Name":"Android","Source":"# Vcpkg and Android\n\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/users/android.md).**\n\nAndroid is not officially supported, and there are no official android triplets at the moment.\n\nHowever, some packages can compile to Android, and the situation is improving: see the list of [PR related to Android](https://github.com/Microsoft/vcpkg/pulls?q=+android+).\n\n\n## Android build requirements\n\n1. Download the [android ndk](https://developer.android.com/ndk/downloads/)\n\n2. Set environment variable `ANDROID_NDK_HOME` to your android ndk installation. \n   For example:\n\n````bash\nexport ANDROID_NDK_HOME=/home/your-account/Android/Sdk/ndk-bundle\n````\n\nOr:\n````bash\nexport ANDROID_NDK_HOME=/home/your-account/Android/android-ndk-r21b\n````\n\n3. Install [vcpkg](https://github.com/microsoft/vcpkg)\n\n4. Set environment variable `VCPKG_ROOT` to your vcpkg installation.\n````bash\nexport VCPKG_ROOT=/path/to/vcpkg\n````\n\n## Create the android triplets\n\n\n### Android ABI and corresponding vcpkg triplets\n\nThere are four different Android ABI, each of which maps to \na vcpkg triplet. The following table outlines the mapping from vcpkg architectures to android architectures\n\n|VCPKG_TARGET_TRIPLET       | ANDROID_ABI          |\n|---------------------------|----------------------|\n|arm64-android              | arm64-v8a            |\n|arm-android                | armeabi-v7a          |\n|x64-android                | x86_64               |\n|x86-android                | x86                  |\n\n### Create the android triplets\nYou can copy-paste the script below to populate them, and adjust them to your needs if required.\n\n````bash\ncd $VCPKG_ROOT\n\necho \"\nset(VCPKG_TARGET_ARCHITECTURE arm)\nset(VCPKG_CRT_LINKAGE dynamic)\nset(VCPKG_LIBRARY_LINKAGE dynamic)\nset(VCPKG_CMAKE_SYSTEM_NAME Android)\n\" > triplets/community/arm-android.cmake\n\necho \"\nset(VCPKG_TARGET_ARCHITECTURE arm64)\nset(VCPKG_CRT_LINKAGE dynamic)\nset(VCPKG_LIBRARY_LINKAGE dynamic)\nset(VCPKG_CMAKE_SYSTEM_NAME Android)\n\" > triplets/community/arm64-android.cmake\n \necho \"\nset(VCPKG_TARGET_ARCHITECTURE x86)\nset(VCPKG_CRT_LINKAGE dynamic)\nset(VCPKG_LIBRARY_LINKAGE dynamic)\nset(VCPKG_CMAKE_SYSTEM_NAME Android)\n\" > triplets/community/x86-android.cmake\n\necho \"\nset(VCPKG_TARGET_ARCHITECTURE x64)\nset(VCPKG_CRT_LINKAGE dynamic)\nset(VCPKG_LIBRARY_LINKAGE dynamic)\nset(VCPKG_CMAKE_SYSTEM_NAME Android)\n\" > triplets/community/x64-android.cmake\n````\n\n## Install libraries for Android using vcpkg\n\nExample for jsoncpp:\n\n````bash\ncd $VCPKG_ROOT\n\n# specify the triplet like this\n./vcpkg install jsoncpp --triplet arm-android   \n# or like this\n./vcpkg install jsoncpp:arm64-android           \n./vcpkg install jsoncpp:x86-android\n./vcpkg install jsoncpp:x64-android\n````\n\n### Using Vulkan SDK\n\nVcpkg has a [`vulkan` package](https://github.com/microsoft/vcpkg/blob/master/ports/vulkan/portfile.cmake) which allows you to `find_package(Vulkan)`. To use it you have to provide `VULKAN_SDK` environment variable.\n\n```bash\nexport VULKAN_SDK=/usr/local\n./vcpkg install vulkan\n```\n\nNDK already contains [Vulkan](https://developer.android.com/ndk/guides/graphics/getting-started) headers and `libvulkan.so` binaries for each of its architecture.  \nTo expose them to VcPkg, you can consider `export VULKAN_SDK=...` for each installation.  \nBut by placing `set(ENV{VULKAN_SDK} ...)` in the triplet files, you can skip the tedious work.\n\nIf you are using NDK 21.3.6528147 or earlier version, it will be like the following.\n\n```cmake\n# In android triplets... (e.g. arm64-android.cmake)\nset(VCPKG_CMAKE_SYSTEM_NAME Android)\n# ...\n# If your API level is 30, libvulkan.so is at $ENV{ANDROID_NDK_HOME}/platforms/android-30/arch-arm64/usr/lib\nset(ENV{VULKAN_SDK} $ENV{ANDROID_NDK_HOME}/sysroot/usr)\n```\n\nNotice that **the location of the sysroot has changed since NDK 22**. (see https://github.com/android/ndk/issues/1407)  \nIf you prefer using [the latest version](https://developer.android.com/studio/projects/install-ndk#default-ndk-per-agp), check the [BuildSystemMaintainers.md of the NDK document](https://android.googlesource.com/platform/ndk/+/master/docs/BuildSystemMaintainers.md#sysroot) and then put appropriate path for your system.\n\nFor example, Mac OS users will use the path like this.\n\n```cmake\n# In android triplets... (e.g. arm64-android.cmake)\nset(VCPKG_CMAKE_SYSTEM_NAME Android)\n# ...\n# If your API level is 30, libvulkan.so is at $ENV{ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/lib/aarch64-linux-android/30\nset(ENV{VULKAN_SDK} $ENV{ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr)\n```\n\nBy doing this for all android triplets, you can install `vulkan` and the packages that require it. (e.g. `vulkan-hpp`)\n\n<details>\n  <summary markdown=\"span\">`vcpkg install vulkan-hpp:arm64-android`</summary>\n\n```console\nuser@host$ ./vcpkg install vulkan-hpp:arm64-android\nComputing installation plan...\nThe following packages will be built and installed:\n  * vulkan[core]:arm64-android -> 1.1.82.1-1\n    vulkan-hpp[core]:arm64-android -> 2019-05-11-1\nAdditional packages (*) will be modified to complete this operation.\nDetecting compiler hash for triplet arm64-android...\n...\nStarting package 1/2: vulkan:arm64-android\nBuilding package vulkan[core]:arm64-android...\n-- Using community triplet arm64-android. This triplet configuration is not guaranteed to succeed.\n-- [COMMUNITY] Loading triplet configuration from: /.../vcpkg/triplets/community/arm64-android.cmake\n-- Querying VULKAN_SDK Environment variable\n-- Searching /.../Library/Android/sdk/ndk/22.1.7171670/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/vulkan/ for vulkan.h\n-- Found vulkan.h\n-- Performing post-build validation\n-- Performing post-build validation done\n...\nBuilding package vulkan[core]:arm64-android... done\nInstalling package vulkan[core]:arm64-android...\nInstalling package vulkan[core]:arm64-android... done\nElapsed time for package vulkan:arm64-android: 35.9 ms\nStarting package 2/2: vulkan-hpp:arm64-android\nBuilding package vulkan-hpp[core]:arm64-android...\n-- Using community triplet arm64-android. This triplet configuration is not guaranteed to succeed.\n-- [COMMUNITY] Loading triplet configuration from: /.../vcpkg/triplets/community/arm64-android.cmake\n-- Using cached /.../vcpkg/downloads/KhronosGroup-Vulkan-Hpp-5ce8ae7fd0d9c0543d02f33cfa8a66e6a43e2150.tar.gz\n-- Cleaning sources at /.../vcpkg/buildtrees/vulkan-hpp/src/e6a43e2150-4f344cd911.clean. Use --editable to skip cleaning for the packages you specify.\n-- Extracting source /.../vcpkg/downloads/KhronosGroup-Vulkan-Hpp-5ce8ae7fd0d9c0543d02f33cfa8a66e6a43e2150.tar.gz\n-- Using source at /.../vcpkg/buildtrees/vulkan-hpp/src/e6a43e2150-4f344cd911.clean\n-- Performing post-build validation\n-- Performing post-build validation done\n...\nBuilding package vulkan-hpp[core]:arm64-android... done\nInstalling package vulkan-hpp[core]:arm64-android...\nInstalling package vulkan-hpp[core]:arm64-android... done\nElapsed time for package vulkan-hpp:arm64-android: 144.5 ms\n\nTotal elapsed time: 1.013 s\n\nThe package vulkan-hpp:arm64-android is header only and can be used from CMake via:\n\n    find_path(VULKAN_HPP_INCLUDE_DIRS \"vulkan/vulkan.hpp\")\n    target_include_directories(main PRIVATE ${VULKAN_HPP_INCLUDE_DIRS})\n\n```\n\n</details>\n\n\n## Consume libraries using vpckg, cmake and the android toolchain\n\n1. Combine vcpkg and Android toolchains\n\nvcpkg and android both provide dedicated toolchains:\n````bash\nvcpkg_toolchain_file=$VCPKG_ROOT/scripts/buildsystems/vcpkg.cmake\nandroid_toolchain_file=$ANDROID_NDK_HOME/build/cmake/android.toolchain.cmake\n````\n\nWhen using vcpkg, the vcpkg toolchain shall be specified first. \n\nHowever, vcpkg provides a way to preload and additional toolchain, with the VCPKG_CHAINLOAD_TOOLCHAIN_FILE option. \n\n````bash\ncmake \\\n  -DCMAKE_TOOLCHAIN_FILE=$vcpkg_toolchain_file \\\n  -DVCPKG_CHAINLOAD_TOOLCHAIN_FILE=$android_toolchain_file \\\n  ...\n````\n\n2. Specify the android abi and vcpkg triplet\n\nWhen compiling for android, you need to select a matching \"android abi\" / \"vcpkg triplet\" pair.\n\nFor example:\n\n````bash\nandroid_abi=armeabi-v7a\nvcpkg_target_triplet=arm-android\n\ncmake \n  ...\n  -DVCPKG_TARGET_TRIPLET=$vcpkg_target_triplet \\\n  -DANDROID_ABI=$android_abi\n````\n\n### Test on an example\n\nThe folder [docs/examples/vcpkg_android_example_cmake](../examples/vcpkg_android_example_cmake) provides a working example, with an android library that consumes the jsoncpp library:\n\n*Details*\n\n* The [CMakeLists](../examples/vcpkg_android_example_cmake/CMakeLists.txt) simply uses `find_package` and `target_link_library`\n\n* The [compile.sh](../examples/vcpkg_android_example_cmake/compile.sh) script enables you to select any matching pair of \"android abi\" /  \"vcpkg triplet\" and to test the compilation\n\n* The dummy [my_lib.cpp](../examples/vcpkg_android_example_cmake/my_lib.cpp) file uses the jsoncpp library\n\n*Note*: this example only compiles an Android library, as the compilation of a full fledged Android App is beyond the scope of this document.\n\n### Test on an example, using [vcpkg_android.cmake](../examples/vcpkg_android_example_cmake_script/cmake/vcpkg_android.cmake)\n\nThe folder [docs/examples/vcpkg_android_example_cmake_script](../examples/vcpkg_android_example_cmake_script) provides the same example, and uses a cmake script in order to simplify the usage.\n\n*Details*\n\n* The main [CMakeLists](../examples/vcpkg_android_example_cmake_script/CMakeLists.txt) loads [vcpkg_android.cmake](../examples/vcpkg_android_example_cmake_script/cmake/vcpkg_android.cmake) if the flag `VCPKG_TARGET_ANDROID` is set:\n````cmake\nif (VCPKG_TARGET_ANDROID)\n    include(\"cmake/vcpkg_android.cmake\")\nendif()\n````\n*Important: place these lines before calling project() !*\n\n* The [compile.sh](../examples/vcpkg_android_example_cmake_script/compile.sh) script shows that it is then possible to compile for android using a simple cmake invocation, for example:\n````bash\ncmake .. -DVCPKG_TARGET_ANDROID=ON -DANDROID_ABI=armeabi-v7a\n````\n\n## Consume libraries using vpckg, and Android prefab Archives (AAR files)\n\nSee [prefab.md](../specifications/prefab.md)\n","Nav":"#"},{"Path":"/en/docs/users/assetcaching.html","Name":"Assetcaching","Source":"# Asset Caching\n\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/users/assetcaching.md).**\n\n**Experimental feature: this may change or be removed at any time**\n\nVcpkg can utilize mirrors to cache downloaded assets, ensuring continued operation even if the original source changes\nor disappears.\n\nIn-tool help is available via `vcpkg help assetcaching`.\n\n## Configuration\n\nAsset caching can be configured by setting the environment variable `X_VCPKG_ASSET_SOURCES` to a semicolon-delimited\nlist of source strings. Characters can be escaped using backtick (\\`).\n\n### Valid source strings\n\nThe `<rw>` optional parameter for certain strings controls how they will be accessed. It can be specified as `read`,\n`write`, or `readwrite` and defaults to `read`.\n\n#### `clear`\n\nSyntax: `clear`\n\nRemoves all previous sources\n\n#### `x-azurl`\n\nSyntax: `x-azurl,<url>[,<sas>[,<rw>]]`\n\nAdds an Azure Blob Storage source, optionally using Shared Access Signature validation. URL should include the container\npath and be terminated with a trailing `/`. SAS, if defined, should be prefixed with a `?`. Non-Azure servers will also\nwork if they respond to GET and PUT requests of the form: `<url><sha512><sas>`.\n\nSee also the [binary caching documentation for Azure Blob Storage](binarycaching.md#azure-blob-storage-experimental) for\nmore information on how to set up an `x-azurl` source.\n\n#### `x-block-origin`\n\nSyntax: `x-block-origin`\n\nDisables use of the original URLs in case the mirror does not have the file available.\n","Nav":"#"},{"Path":"/en/docs/users/binarycaching.html","Name":"Binarycaching","Source":"# Binary Caching\n\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/users/binarycaching.md).**\n\nLibraries installed with vcpkg can always be built from source. However, that can duplicate work and waste time when working across multiple projects.\n\nBinary caching is a vcpkg feature that saves copies of library binaries in a shared location that can be accessed by vcpkg for future installs. This means that, as a user, you should only need to build dependencies from source once. If vcpkg is asked to install the same library with the same build configuration in the future, it will just copy the built binaries from the cache and finish the operation in seconds.\n\nBinary caching is especially effective when using Continuous Integration, since local developers can reuse the binaries produced during a CI run. It also greatly enhances the performance of \"ephemeral\" or \"hosted\" build agents, since all local changes are otherwise lost between runs. By using binary caching backed by a cloud service, such as GitHub, Azure, or many others, you can ensure your CI runs at maximum speed and only rebuilds your dependencies when they've changed.\n\nCaches can be hosted in a variety of environments. The most basic examples are a folder on the local machine or a network file share. Caches can also be stored in any NuGet feed (such as GitHub or Azure DevOps Artifacts), Azure Blob Storage*, or Google Cloud Storage*.\n\n\\* (experimental) \n\nIf your CI provider offers a native \"caching\" function, we recommend using both vcpkg binary caching and the native method for the most performant results.\n\nIn-tool help is available via `vcpkg help binarycaching`.\n\nTable of Contents\n - [Configuration](#configuration)\n - [CI Examples](#ci-examples)\n   - [GitHub Packages](#github-packages)\n   - [Azure DevOps Artifacts](#azure-devops-artifacts)\n   - [Azure Blob Storage](#azure-blob-storage-experimental)\n   - [Google Cloud Storage](#google-cloud-storage-experimental)\n - [NuGet Provider Configuration](#nuget-provider-configuration)\n - [Implementation Notes](#implementation-notes-internal-details-subject-to-change-without-notice)\n\n\n## Configuration\n\nBinary caching is configured via a combination of defaults, the environment variable `VCPKG_BINARY_SOURCES` (set to `<source>;<source>;...`), and the command line option `--binarysource=<source>`. Source options are evaluated in order of defaults, then environment, then command line. Binary caching can be completely disabled by passing `--binarysource=clear` as the last command line option.\n\nBy default, zip-based archives will be cached at the first valid location of:\n\n**Windows**\n1. `%VCPKG_DEFAULT_BINARY_CACHE%`\n2. `%LOCALAPPDATA%\\vcpkg\\archives`\n3. `%APPDATA%\\vcpkg\\archives`\n\n**Non-Windows**\n1. `$VCPKG_DEFAULT_BINARY_CACHE`\n2. `$XDG_CACHE_HOME/vcpkg/archives`\n3. `$HOME/.cache/vcpkg/archives`\n\n### Valid source strings (`<source>`)\n\n| form                        | description\n|-----------------------------|---------------\n| `clear`                     | Removes all previous sources (including the default)\n| `default[,<rw>]`            | Adds the default file-based location\n| `files,<absolute path>[,<rw>]`       | Adds a custom file-based location\n| `nuget,<uri>[,<rw>]`        | Adds a NuGet-based source; equivalent to the `-Source` parameter of the NuGet CLI\n| `nugetconfig,<path>[,<rw>]` | Adds a NuGet-config-file-based source; equivalent to the `-Config` parameter of the NuGet CLI. This config should specify `defaultPushSource` for uploads.\n| `nugettimeout,<seconds>`    | Specifies a timeout for NuGet network operations; equivalent to the `-Timeout` parameter of the NuGet CLI.\n| `x-azblob,<baseuri>,<sas>[,<rw>]`    | **Experimental: will change or be removed without warning**<br> Adds an Azure Blob Storage source. Uses Shared Access Signature validation. URL should include the container path.\n| `interactive`               | Enables interactive credential management for NuGet (for debugging; requires `--debug` on the command line)\n\nThe `<rw>` optional parameter for certain sources controls whether they will be consulted for\ndownloading binaries (`read`)(default), whether on-demand builds will be uploaded to that remote (`write`), or both (`readwrite`).\n\nAdditional configuration details for NuGet-based providers can be found below in [NuGet Provider Configuration](#nuget-provider-configuration).\n\n## CI Examples\n\nIf your CI system of choice is not listed, we welcome PRs to add them!\n\n### GitHub Packages\n\nTo use vcpkg with GitHub Packages, we recommend using the `NuGet` backend.\n\n>**NOTE 2020-09-21**: GitHub's hosted agents come with an older, pre-installed copy of vcpkg on the path that does not support the latest binary caching. This means that direct calls to `bootstrap-vcpkg` or `vcpkg` without a path prefix may call an unintended vcpkg instance. We recommend taking the following two steps to avoid issues if you want to use your own copy of vcpkg:\n> 1. Run the equivalent of `rm -rf \"$VCPKG_INSTALLATION_ROOT\"` using `shell: 'bash'`\n> 2. Always call `vcpkg` and `bootstrap-vcpkg` with a path prefix, such as `./vcpkg`, `vcpkg/vcpkg`, `.\\bootstrap-vcpkg.bat`, etc\n\n```yaml\n# actions.yaml\n#\n# In this example, vcpkg has been added as a submodule (`git submodule add https://github.com/Microsoft/vcpkg`).\nenv:\n  VCPKG_BINARY_SOURCES: 'clear;nuget,GitHub,readwrite'\n\nmatrix:\n  os: ['windows-2019', 'ubuntu-20.04']\n  include:\n    - os: 'windows-2019'\n      triplet: 'x86-windows'\n      mono: ''\n    - os: 'ubuntu-20.04'\n      triplet: 'x64-linux'\n      # To run `nuget.exe` on non-Windows platforms, we must use `mono`.\n      mono: 'mono'\n\nsteps:\n  # This step assumes `vcpkg` has been bootstrapped (run `./vcpkg/bootstrap-vcpkg`)\n  - name: 'Setup NuGet Credentials'\n    shell: 'bash'\n    # Replace <OWNER> with your organization name\n    run: >\n      ${{ matrix.mono }} `./vcpkg/vcpkg fetch nuget | tail -n 1`\n      sources add\n      -source \"https://nuget.pkg.github.com/<OWNER>/index.json\"\n      -storepasswordincleartext\n      -name \"GitHub\"\n      -username \"<OWNER>\"\n      -password \"${{ secrets.GITHUB_TOKEN }}\"\n\n  # Omit this step if you're using manifests\n  - name: 'vcpkg package restore'\n    shell: 'bash'\n    run: >\n      ./vcpkg/vcpkg install sqlite3 cpprestsdk --triplet ${{ matrix.triplet }}\n```\n\nIf you're using [manifests](../specifications/manifests.md), you can omit the `vcpkg package restore` step: it will be run automatically as part of your build.\n\nMore information about GitHub Packages' NuGet support is available on [GitHub Docs][github-nuget].\n\n[github-nuget]: https://docs.github.com/en/packages/using-github-packages-with-your-projects-ecosystem/configuring-dotnet-cli-for-use-with-github-packages\n\n### Azure DevOps Artifacts\n\nTo use vcpkg with Azure DevOps Artifacts, we recommend using the `NuGet` backend.\n\nFirst, you need to ensure Artifacts has been enabled on your DevOps instance; this can be done by an Administrator through `Project Settings > General > Overview > Azure DevOps Services > Artifacts`.\n\nNext, you will need to create a feed for your project; see the [Azure DevOps Artifacts Documentation][devops-nuget] for more information. Your feed URL will be an `https://` link ending with `/nuget/v3/index.json`.\n\n```yaml\n# azure-pipelines.yaml\nvariables:\n- name: VCPKG_BINARY_SOURCES\n  value: 'clear;nuget,<FEED_URL>,readwrite'\n  \nsteps:\n# Remember to add this task to allow vcpkg to upload archives via NuGet\n- task: NuGetAuthenticate@0\n```\n\nIf you are using custom agents with a non-Windows OS, you will need to install Mono to run `nuget.exe` (`apt install mono-complete`, `brew install mono`, etc).\n\nMore information about Azure DevOps Artifacts' NuGet support is available in the [Azure DevOps Artifacts Documentation][devops-nuget].\n\n[devops-nuget]: https://docs.microsoft.com/en-us/azure/devops/artifacts/get-started-nuget?view=azure-devops\n\n### Azure Blob Storage (experimental)\n\n> Note: This is an experimental feature and may change or be removed at any time\n\nVcpkg supports interfacing with Azure Blob Storage via the `x-azblob` source type.\n\n```\nx-azblob,<baseuri>,<sas>[,<rw>]\n```\n\nFirst, you need to create an Azure Storage Account as well as a container ([Quick Start Documentation](https://docs.microsoft.com/en-us/azure/storage/blobs/storage-quickstart-blobs-portal)].\n\nNext, you will need to create a Shared Access Signature, which can be done from the storage account under Settings -> Shared access signature. This SAS will need:\n- Allowed services: Blob\n- Allowed resource types: Object\n- Allowed permissions: Read, Create (if using `write` or `readwrite`)\n\nThe blob endpoint plus the container must be passed as the `<baseuri>` and the generated SAS without the `?` prefix must be passed as the `<sas>`.\n\nExample:\n```\nx-azblob,https://<storagename>.blob.core.windows.net/<containername>,sv=2019-12-12&ss=b&srt=o&sp=rcx&se=2020-12-31T06:20:36Z&st=2020-12-30T22:20:36Z&spr=https&sig=abcd,readwrite\n```\n\nVcpkg will attempt to avoid revealing the SAS during normal operations, however:\n1. It will be printed in full if `--debug` is passed\n2. It will be passed as a command line parameter to subprocesses, such as `curl.exe`\n\n### Google Cloud Storage (experimental)\n\n> Note: This is an experimental feature and may change or be removed at any time\n\nVcpkg supports interfacing with Google Cloud Storage (GCS) via the `x-gcs` source type.\n\n```\nx-gcs,<prefix>[,<rw>]\n```\n\nFirst, you need to create an Google Cloud Platform Account as well as a storage bucket ([GCS Quick Start](https://cloud.google.com/storage/docs/quickstart-gsutil)].\n\nAs part of this quickstart you would have configured the `gsutil` command-line tool to authenticate with Google Cloud.\nVcpkg will use this command-line tool, make sure it is in your search path for executables.\n\nExample 1 (using a bucket without a common prefix for the objects):\n\n```\nx-gcs,gs://<bucket-name>/,readwrite\n```\n\nExample 2 (using a bucket and a prefix for the objects):\n\n```\nx-gcs,gs://<bucket-name>/my-vcpkg-cache/maybe/with/many/slashes/,readwrite\nx-gcs,gs://<bucket-name>/my-vcpkg-cache/maybe/with`,commas/too!/,readwrite\n```\n\nCommas (`,`) are valid as part of a object prefix in GCS, just remember to escape them in the vcpkg configuration, as\nshown in the previous example. Note that GCS does not have folders (some of the GCS tools simulate folders), it is not\nnecessary to create or otherwise manipulate the prefix used by your vcpkg cache.\n\n## NuGet Provider Configuration\n\n### Credentials\n\nMany NuGet servers require additional credentials to access. The most flexible way to supply credentials is via the `nugetconfig` provider with a custom `nuget.config` file. See https://docs.microsoft.com/en-us/nuget/consume-packages/consuming-packages-authenticated-feeds for more information on authenticating via `nuget.config`.\n\nHowever, it is still possible to authenticate against many servers using NuGet's built-in credential providers or via customizing your environment's default `nuget.config`. The default config can be extended via nuget client calls such as\n```\nnuget sources add -Name MyRemote -Source https://... -Username $user -Password $pass\n```\nand then passed to vcpkg via `--binarysource=nuget,MyRemote,readwrite`. You can get a path to the precise copy of NuGet used by vcpkg by running `vcpkg fetch nuget`, which will report something like:\n```\n$ vcpkg fetch nuget\n/vcpkg/downloads/tools/nuget-5.5.1-linux/nuget.exe\n```\nNon-Windows users will need to call this through mono via `mono /path/to/nuget.exe sources add ...`.\n\n##### Credential Example for Azure Dev Ops\n```bash\n# On Linux or OSX\n$ mono `vcpkg fetch nuget | tail -n1` sources add \\\n  -name ADO \\\n  -Source https://pkgs.dev.azure.com/$ORG/_packaging/$FEEDNAME/nuget/v3/index.json \\\n  -Username $USERNAME \\\n  -Password $PAT\n$ export VCPKG_BINARY_SOURCES=\"nuget,ADO,readwrite\"\n```\n```powershell\n# On Windows Powershell\nPS> & $(vcpkg fetch nuget | select -last 1) sources add `\n  -name ADO `\n  -Source https://pkgs.dev.azure.com/$ORG/_packaging/$FEEDNAME/nuget/v3/index.json `\n  -Username $USERNAME `\n  -Password $PAT\nPS> $env:VCPKG_BINARY_SOURCES=\"nuget,ADO,readwrite\"\n```\n\nWe recommend using a Personal Access Token (PAT) as the password for maximum security. You can generate a PAT in User Settings -> Personal Access Tokens or `https://dev.azure.com/$ORG/_usersSettings/tokens`.\n\n#### `metadata.repository`\n\nThe `nuget` and `nugetconfig` source providers additionally respect certain environment variables while generating nuget packages. The `metadata.repository` field of any packages will be generated as:\n```\n    <repository type=\"git\" url=\"${VCPKG_NUGET_REPOSITORY}\"/>\n```\nor\n```\n    <repository type=\"git\"\n                url=\"${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}.git\"\n                branch=\"${GITHUB_REF}\"\n                commit=\"${GITHUB_SHA}\"/>\n```\nif the appropriate environment variables are defined and non-empty. This is specifically used to associate packages in GitHub Packages with the _building_ project and not intended to associate with the original package sources.\n\n#### NuGet's cache\n\nNuGet's cache is not used by default. To use it for every nuget-based source, set the [environment variable](config-environment.md) `VCPKG_USE_NUGET_CACHE` to `true` (case-insensitive) or `1`.\n\n## Implementation Notes (internal details subject to change without notice)\n\nBinary caching relies on hashing everything that contributes to a particular package build. This includes:\n\n- Every file in the port directory\n- The triplet file and name\n- The C++ compiler executable\n- The C compiler executable\n- The set of features selected\n- Every dependency's package hash (note: this is that package's input hash, not contents)\n- All helper scripts referenced by `portfile.cmake` (heuristic)\n- The version of CMake used\n- The contents of any environment variables listed in `VCPKG_ENV_PASSTHROUGH`\n- The hash of the toolchain file (builtin or `VCPKG_CHAINLOAD_TOOLCHAIN_FILE`)\n\nDespite this extensive list, it is possible to defeat the cache and introduce nondeterminism. If you have additional details that you'd like to be tracked, the easiest resolution is to generate a triplet file with your additional information in a comment. That additional information will be included in the package's input set and ensure a unique universe of binaries.\n\nThe hashes used are stored in the package and in the current installed directory at `/share/<port>/vcpkg_abi_info.txt`.\n\nThe original specification for binary caching is available [here](../specifications/binarycaching.md).\n","Nav":"#"},{"Path":"/en/docs/users/config-environment.html","Name":"Config-environment","Source":"## Environment and Configuration\r\n\r\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/users/config-environment.md).**\r\n\r\n### Environment Variables\r\n\r\n#### VCPKG_DOWNLOADS\r\n\r\nThis environment variable can be set to an existing directory to use for storing downloads instead of the internal\r\n`downloads/` directory. It should always be set to an absolute path.\r\n\r\n#### VCPKG_FEATURE_FLAGS\r\n\r\nThis environment variable can be set to a comma-separated list of off-by-default features in vcpkg. These features are\r\nsubject to change without notice and should be considered highly unstable.\r\n\r\nNon-exhaustive list of off-by-default features:\r\n\r\n- `manifest`\r\n\r\n#### EDITOR\r\n\r\nThis environment variable can be set to the full path of an executable to be used for `vcpkg edit`. Please see\r\n`vcpkg help edit` for command-specific help.\r\n\r\n#### VCPKG_ROOT\r\n\r\nThis environment variable can be set to a directory to use as the root of the vcpkg instance. Note that mixing vcpkg\r\nrepo versions and executable versions can cause issues.\r\n\r\n#### VCPKG_VISUAL_STUDIO_PATH\r\n\r\nThis environment variable can be set to the full path to a Visual Studio instance on the machine. This Visual Studio instance\r\nwill be used if the triplet does not override it via the [`VCPKG_VISUAL_STUDIO_PATH`](triplets.md#VCPKG_VISUAL_STUDIO_PATH) triplet setting.\r\n\r\nExample: `D:\\2017`\r\n\r\n#### VCPKG_DEFAULT_TRIPLET\r\n\r\nThis environment variable can be set to a triplet name which will be used for unqualified triplet references in command lines.\r\n\r\n#### VCPKG_DEFAULT_HOST_TRIPLET\r\n\r\nThis environment variable can be set to a triplet name which will be used for unqualified host port references in command lines and all host port references in dependency lists. See [the host-dependencies documentation](host-dependencies.md) for more information.\r\n\r\n#### VCPKG_OVERLAY_PORTS\r\n\r\nThis environment variable allows users to override ports with alternate versions according to the\r\n[ports overlay](../specifications/ports-overlay.md) specification. List paths to overlays using\r\nthe platform dependent PATH separator (Windows `;` | others `:`)\r\n\r\nExample (Windows): `C:\\custom-ports\\boost;C:\\custom-ports\\sqlite3`\r\n\r\n#### VCPKG_OVERLAY_TRIPLETS\r\n\r\nThis environment variable allows users to add directories to search for triplets.\r\n[Example: overlay triplets](../examples/overlay-triplets-linux-dynamic.md).\r\nList paths to overlays using the platform dependent PATH separator (Windows `;`, others `:`)\r\n\r\n#### VCPKG_FORCE_SYSTEM_BINARIES\r\n\r\nThis environment variable, if set, suppresses the downloading of CMake and Ninja and forces the use of the system binaries.\r\n\r\n#### VCPKG_KEEP_ENV_VARS\r\n\r\nThis environment variable can be set to a list of environment variables, separated by `;`, which will be propagated to\r\nthe build environment.\r\n\r\nExample: `FOO_SDK_DIR;BAR_SDK_DIR`\r\n\r\n#### VCPKG_MAX_CONCURRENCY\r\n\r\nThis environment variables limits the amount of concurrency requested by underlying buildsystems. If unspecified, this defaults to logical cores + 1.\r\n\r\n#### VCPKG_DEFAULT_BINARY_CACHE\r\n\r\nThis environment variable redirects the default location to store binary packages. See [Binary Caching](binarycaching.md#Configuration) for more details.\r\n\r\n#### VCPKG_BINARY_SOURCES\r\n\r\nThis environment variable adds or removes binary sources. See [Binary Caching](binarycaching.md#Configuration) for more details.\r\n\r\n#### VCPKG_NUGET_REPOSITORY\r\n\r\nThis environment variable changes the metadata of produced NuGet packages. See [Binary Caching](binarycaching.md#Configuration) for more details.\r\n\r\n#### VCPKG_USE_NUGET_CACHE\r\n\r\nThis environment variable allows using NuGet's cache for every nuget-based binary source. See [Binary Caching](binarycaching.md#NuGets-cache) for more details.\r\n\r\n#### X_VCPKG_ASSET_SOURCES\r\n\r\n> Note: This is an experimental feature and may change or be removed at any time\r\n\r\nThis environment variable allows using a private mirror for all SHA512-tagged assets. See [Asset Caching](assetcaching.md) for more details.\r\n","Nav":"#"},{"Path":"/en/docs/users/host-dependencies.html","Name":"Host-dependencies","Source":"# Host Dependencies\n\nTools used at build time by other ports to generate code or implement a custom build system can be packaged inside vcpkg.\n\n## Consuming\n\nWhen consuming a port as a tool, you must set the dependency's `\"host\"` field to true. For example:\n```json\n{\n    \"name\": \"contoso-http-library\",\n    \"version-string\": \"1.0.0\",\n    \"description\": \"Contoso's http runtime library\",\n    \"dependencies\": [\n        \"contoso-core-library\",\n        {\n            \"name\": \"contoso-code-generator\",\n            \"host\": true\n        },\n        {\n            \"name\": \"contoso-build-system\",\n            \"host\": true\n        }\n    ]\n}\n```\nIn this case, the `contoso-code-generator` and `contoso-build-system` (including any transitive dependencies) will be built and installed for the host triplet before `contoso-http-library` is built.\n\n>Note: Consumers must use `vcpkg.json` instead of `CONTROL` as their metadata format. You can easily convert an existing `CONTROL` file using `vcpkg format-manifest /path/to/CONTROL`.\n\nThen, within the portfile of the consumer (`contoso-http-library` in the example), the CMake variable `CURRENT_HOST_INSTALLED_DIR` will be defined to `installed/<host-triplet>` and should be used to locate any required assets. In the example, `contoso-code-generator` might have installed `tools/contoso-code-generator/ccg.exe` which the consumer would add to its local path via\n```cmake\n# ports/contoso-http-library/portfile.cmake\nvcpkg_add_to_path(${CURRENT_HOST_INSTALLED_DIR}/tools/contoso-code-generator)\n```\n\n## Specifying the Host Triplet\n\nThe default host triplets are chosen based on the host architecture and operating system, for example `x64-windows`, `x64-linux`, or `x64-osx`. They can be overridden via:\n\n1. In CMake-based manifest mode, calling `set(VCPKG_HOST_TRIPLET \"<triplet>\" CACHE STRING \"\")` before the first `project()` directive\n2. In MSBuild-based manifest mode, setting the `VcpkgHostTriplet` property\n3. On the command line, via the flag `--host-triplet=...`\n4. The `VCPKG_DEFAULT_HOST_TRIPLET` environment variable\n\n## Producing\n\nProducing a tool has no special requirements; tools should be authored as a standard port, following all the normal policies and practices. Notably, they should build against `TARGET_TRIPLET`, not `HOST_TRIPLET` within the context of their portfile.\n\nSometimes, it can be useful to determine whether the current context is a cross-compiling one or not. This should be done by comparing the strings `TARGET_TRIPLET` and `HOST_TRIPLET`. For example:\n\n```cmake\nstring(COMPARE EQUAL \"${TARGET_TRIPLET}\" \"${HOST_TRIPLET}\" I_AM_NOT_CROSSCOMPILING)\n\nif(TARGET_TRIPLET STREQUAL HOST_TRIPLET)\n    # This is a native build\nelse()\n    # This is a cross build\nendif()\n```\n\n## Host-only ports\n\nSome ports are host-only: script ports and tool ports are common examples.\nIn this case, you can use the `\"native\"` supports expression to describe this.\nThis supports expression is true when `TARGET_TRIPLET == HOST_TRIPLET`.\n","Nav":"#"},{"Path":"/en/docs/users/integration.html","Name":"Integration","Source":"## Buildsystem Integration\n\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/users/integration.md).**\n\nVcpkg offers many ways to integrate into your build so you can do what's right for your project. There are two main categories of integration:\n\n- [`integrate` command](#integrate)\n- [`export` command](#export)\n\nEach integration style has heuristics to deduce the correct [triplet][]. This can be overridden using [a common method](#triplet-selection) based on your buildsystem.\n\n<a name=\"integrate-command\"></a>\n### Integrate Command\n\nThese link your project(s) to a specific copy of Vcpkg on your machine so any updates or new package installations will be instantly available for the next build of your project.\n\n<a name=\"user-wide-msbuild\"></a>\n#### User-wide for MSBuild (Recommended for Open Source MSBuild projects)\n```no-highlight\nvcpkg integrate install\n```\nThis will implicitly add Include Directories, Link Directories, and Link Libraries for all packages installed with Vcpkg to all VS2015, VS2017 and VS2019 MSBuild projects. We also add a post-build action for executable projects that will analyze and copy any DLLs you need to the output folder, enabling a seamless F5 experience.\n\nFor the vast majority of libraries, this is all you need to do -- just File -> New Project and write code! However, some libraries perform conflicting behaviors such as redefining `main()`. Since you need to choose per-project which of these conflicting options you want, you will need to add those libraries to your linker inputs manually.\n\nHere are some examples, though this is not an exhaustive list:\n\n- Gtest provides `gtest`, `gmock`, `gtest_main`, and `gmock_main`\n- SDL2 provides `SDL2main`\n- SFML provides `sfml-main`\n- Boost.Test provides `boost_test_exec_monitor`\n\nTo get a full list for all your installed packages, run `vcpkg owns manual-link`.\n\n<a name=\"cmake\"></a>\n#### CMake toolchain file (Recommended for Open Source CMake projects)\n```no-highlight\ncmake ../my/project -DCMAKE_TOOLCHAIN_FILE=C:\\vcpkg\\scripts\\buildsystems\\vcpkg.cmake\n```\nProjects configured with the Vcpkg toolchain file will have the appropriate Vcpkg folders added to the cmake search paths. This makes all libraries available to be found through `find_package()`, `find_path()`, and `find_library()`.\n\nSee [Installing and Using Packages Example: sqlite](../examples/installing-and-using-packages.md) for a fully worked example using our CMake toolchain.\n\nNote that we do not automatically add ourselves to your compiler include paths. To use a header-only library, simply use `find_path()`, which will correctly work on all platforms:\n```cmake\n# To find and use catch\nfind_path(CATCH_INCLUDE_DIR NAMES catch.hpp PATH_SUFFIXES catch2)\ninclude_directories(${CATCH_INCLUDE_DIR})\n```\n\n##### Using an environment variable instead of a command line option\n\nThe `CMAKE_TOOLCHAIN_FILE` setting simply must be set before the `project()` directive is first called. This means that you can easily read from an environment variable to avoid passing it on the configure line:\n\n```cmake\nif(DEFINED ENV{VCPKG_ROOT} AND NOT DEFINED CMAKE_TOOLCHAIN_FILE)\n  set(CMAKE_TOOLCHAIN_FILE \"$ENV{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake\"\n      CACHE STRING \"\")\nendif()\n\nproject(myproject CXX)\n```\n\n##### Using multiple toolchain files\n\nTo use an external toolchain file with a project using vcpkg, you can set the cmake variable `VCPKG_CHAINLOAD_TOOLCHAIN_FILE` on the configure line:\n```no-highlight\ncmake ../my/project \\\n   -DCMAKE_TOOLCHAIN_FILE=C:/vcpkg/scripts/buildsystems/vcpkg.cmake \\\n   -DVCPKG_CHAINLOAD_TOOLCHAIN_FILE=../my/project/compiler-settings-toolchain.cmake\n```\n\n#### Linking NuGet file\n\nWe also provide individual VS project integration through a NuGet package. This will modify the project file, so we do not recommend this approach for open source projects.\n```no-highlight\nPS D:\\src\\vcpkg> .\\vcpkg integrate project\nCreated nupkg: D:\\src\\vcpkg\\scripts\\buildsystems\\vcpkg.D.src.vcpkg.1.0.0.nupkg\n\nWith a project open, go to Tools->NuGet Package Manager->Package Manager Console and paste:\n    Install-Package vcpkg.D.src.vcpkg -Source \"D:/src/vcpkg/scripts/buildsystems\"\n```\n*Note: The generated NuGet package does not contain the actual libraries. It instead acts like a shortcut (or symlink) to the vcpkg install and will \"automatically\" update with any changes (install/remove) to the libraries. You do not need to regenerate or update the NuGet package.*\n\n#### Manual compiler settings\n\nLibraries are installed into the `installed\\` subfolder, partitioned by architecture (e.g. x86-windows):\n\n* The header files are installed to `installed\\x86-windows\\include`\n* Release `.lib` files are installed to `installed\\x86-windows\\lib` or `installed\\x86-windows\\lib\\manual-link`\n* Release `.dll` files are installed to `installed\\x86-windows\\bin`\n* Debug `.lib` files are installed to `installed\\x86-windows\\debug\\lib` or `installed\\x86-windows\\debug\\lib\\manual-link`\n* Debug `.dll` files are installed to `installed\\x86-windows\\debug\\bin`\n\nSee your build system specific documentation for how to use prebuilt binaries.\n\nGenerally, to run any produced executables you will also need to either copy the needed DLL files to the same folder as your executable or *prepend* the correct `bin\\` directory to your path.\n\n<a name=\"export-command\"></a>\n### Export Command\nThis command creates a shrinkwrapped archive containing a specific set of libraries (and their dependencies) that can be quickly and reliably shared with build servers or other users in your organization.\n\n- `--nuget`: NuGet package (Recommended for MSBuild projects)\n- `--zip`: Zip archive\n- `--7zip`: 7Zip archive (Recommended for CMake projects)\n- `--raw`: Raw, uncompressed folder\n\nEach of these have the same layout, which mimics the layout of a full vcpkg:\n\n- `installed\\` contains the installed package files\n- `scripts\\buildsystems\\vcpkg.cmake` is a toolchain file suitable for use with CMake\n\nAdditionally, NuGet packages will contain a `build\\native\\vcpkg.targets` that integrates with MSBuild projects.\n\nPlease also see our [blog post](https://blogs.msdn.microsoft.com/vcblog/2017/05/03/vcpkg-introducing-export-command/) for additional examples.\n\n<a name=\"triplet-selection\"></a>\n### Triplet selection\nEvery integration mechanism besides manually adding the folders will deduce a [triplet][] for your project as one of:\n\n- x86-windows\n- x64-windows\n- x86-uwp\n- x64-uwp\n- arm-uwp\n\n#### With MSBuild\nYou can see the automatically deduced triplet by setting your MSBuild verbosity to Normal or higher:\n\n> *Shortcut: Ctrl+Q \"build and run\"*\n>\n> Tools -> Options -> Projects and Solutions -> Build and Run -> MSBuild project build output verbosity\n\nTo override the automatically chosen [triplet][], you can specify the MSBuild property `VcpkgTriplet` in your `.vcxproj`. We recommend adding this to the `Globals` PropertyGroup.\n```xml\n<PropertyGroup Label=\"Globals\">\n  <!-- .... -->\n  <VcpkgTriplet Condition=\"'$(Platform)'=='Win32'\">x86-windows-static</VcpkgTriplet>\n  <VcpkgTriplet Condition=\"'$(Platform)'=='x64'\">x64-windows-static</VcpkgTriplet>\n</PropertyGroup>\n```\n\n#### With CMake\nYou can set `VCPKG_TARGET_TRIPLET` on the configure line:\n```no-highlight\ncmake ../my/project -DVCPKG_TARGET_TRIPLET=x64-windows-static -DCMAKE_TOOLCHAIN_FILE=...\n```\nIf you use `VCPKG_DEFAULT_TRIPLET` [environment variable](config-environment.md) to control the unqualified triplet in vcpkg command lines you can default `VCPKG_TARGET_TRIPLET` in CMake like [Using an environment variable instead of a command line option](#using-an-environment-variable-instead-of-a-command-line-option):\n\n```cmake\nif(DEFINED ENV{VCPKG_DEFAULT_TRIPLET} AND NOT DEFINED VCPKG_TARGET_TRIPLET)\n  set(VCPKG_TARGET_TRIPLET \"$ENV{VCPKG_DEFAULT_TRIPLET}\" CACHE STRING \"\")\nendif()\n```\n\n[triplet]: triplets.md\n","Nav":"#"},{"Path":"/en/docs/users/manifests.html","Name":"Manifests","Source":"# Manifest Mode\n\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/users/manifests.md).**\n\nvcpkg has two modes of consuming dependencies - classic mode and manifest mode.\n\nIn classic mode, vcpkg produces an \"installed\" tree, whose contents are changed by explicit calls to `vcpkg install` or\n`vcpkg remove`. The installed tree is intended for consumption by any number of projects: for example, installing a\nbunch of libraries and then using those libraries from Visual Studio, without additional configuration. Because the\ninstalled tree is not associated with an individual project, it's similar to tools like `brew` or `apt`, except that the\ninstalled tree is vcpkg-installation-local, rather than global to a system or user.\n\nIn manifest mode, an installed tree is associated with a particular project rather than the vcpkg installation. The set\nof installed ports is controlled by editing the project's \"manifest file\", and the installed tree is placed in the\nproject directory or build directory. This mode acts more similarly to language package managers like Cargo, or npm. We\nrecommend using this manifest mode whenever possible, because it allows one to encode a project's dependencies\nexplicitly in a project file, rather than in the documentation, making your project much easier to consume.\n\nManifest mode is in beta, but it can be used from the CMake or MSBuild integration, which will be stable when used via\nthings like `find_package`. This is the recommended way to use manifest mode.\n\nCheck out the [manifest cmake example](../examples/manifest-mode-cmake.md) for an example project using CMake and\nmanifest mode.\n\n## Table of Contents\n\n- [Simple Example Manifest](#simple-example-manifest)\n- [Manifest Syntax Reference](#manifest-syntax-reference)\n- [Command Line Interface](#command-line-interface)\n- [CMake Integration](#cmake-integration)\n- [MSBuild Integration](#msbuild-integration)\n\nSee also [the original specification](../specifications/manifests.md) for more low-level details.\n\n## Simple Example Manifest\n\n```json\n{\n  \"$schema\": \"https://raw.githubusercontent.com/microsoft/vcpkg/master/scripts/vcpkg.schema.json\",\n  \"name\": \"my-application\",\n  \"version\": \"0.15.2\",\n  \"dependencies\": [\n    \"boost-system\",\n    {\n      \"name\": \"cpprestsdk\",\n      \"default-features\": false\n    },\n    \"libxml2\",\n    \"yajl\"\n  ]\n}\n```\n\n## Manifest Syntax Reference\n\nA manifest is a JSON-formatted file named `vcpkg.json` which lies at the root of your project.\nIt contains all the information a person needs to know to get dependencies for your project,\nas well as all the metadata about your project that a person who depends on you might be interested in.\n\nManifests follow strict JSON: they can't contain C++-style comments (`//`) nor trailing commas. However\nyou can use field names that start with `$` to write your comments in any object that has a well-defined set of keys.\nThese comment fields are not allowed in any objects which permit user-defined keys (such as `\"features\"`).\n\nEach manifest contains a top level object with the fields documented below; the most important ones are\n[`\"name\"`](#name), the [version fields](#version-fields), and [`\"dependencies\"`](#dependencies):\n\n### `\"name\"`\n\nThis is the name of your project! It must be formatted in a way that vcpkg understands - in other words,\nit must be lowercase alphabetic characters, digits, and hyphens, and it must not start nor end with a hyphen.\nFor example, `Boost.Asio` might be given the name `boost-asio`.\n\nThis is a required field.\n\n### Version fields\n\nThere is, at this point, only one version field - `\"version-string\"`. However, more will be added in the future.\nYou must have one (and only one) version field. There are different reasons to use each version field:\n\n* `\"version-string\"` - used for packages that don't have orderable versions. This is pretty uncommon,\n  but since we don't have any versioning constraints yet, this is the only one that you can use.\n\nAdditionally, the `\"port-version\"` field is used by registries of packages,\nas a way to version \"the package gotten from `vcpkg install`\" differently from the upstream package version.\nYou shouldn't need to worry about this at all.\n\n#### Additional version fields\n\n**Experimental behind the `versions` feature flag**\n\nSee [versioning](versioning.md#version-schemes) for additional version types.\n\n### `\"description\"`\n\nThis is where you describe your project. Give it a good description to help in searching for it!\nThis can be a single string, or it can be an array of strings;\nin the latter case, the first string is treated as a summary,\nwhile the remaining strings are treated as the full description.\n\n### `\"builtin-baseline\"`\n\n**Experimental behind the `versions` feature flag**\n\nThis field indicates the commit of vcpkg which provides global minimum version information for your manifest. It is required for top-level manifest files using versioning.\n\nSee also [versioning](versioning.md#builtin-baseline) for more semantic details.\n\n### `\"dependencies\"`\n\nThis field lists all the dependencies you'll need to build your library (as well as any your dependents might need,\nif they were to use you). It's an array of strings and objects:\n\n* A string dependency (e.g., `\"dependencies\": [ \"zlib\" ]`) is the simplest way one can depend on a library;\n  it means you don't depend on a single version, and don't need to write down any more information.\n* On the other hand, an object dependency (e.g., `\"dependencies\": [ { \"name\": \"zlib\" } ]`)\n  allows you to add that extra information.\n\n#### Example:\n\n```json\n\"dependencies\": [\n  {\n    \"name\": \"arrow\",\n    \"default-features\": false,\n    \"features\": [ \"json\" ]\n  },\n  \"boost-asio\",\n  \"openssl\",\n  {\n    \"name\": \"picosha2\",\n    \"platform\": \"!windows\"\n  }\n]\n```\n\n#### `\"name\"` Field\n\nThe name of the dependency. This follows the same restrictions as the [`\"name\"`](#name) property for a project.\n\n#### `\"features\"` and `\"default-features\"` Fields\n\n`\"features\"` is an array of feature names which tell you the set of features that the\ndependencies need to have at a minimum,\nwhile `\"default-features\"` is a boolean that tells vcpkg whether or not to\ninstall the features the package author thinks should be \"most common for most people to use\".\n\nFor example, `ffmpeg` is a library which supports many, many audio and video codecs;\nhowever, for your specific project, you may only need mp3 encoding.\nThen, you might just ask for:\n\n```json\n{\n  \"name\": \"ffmpeg\",\n  \"default-features\": false,\n  \"features\": [ \"mp3lame\" ]\n}\n```\n\n#### `\"platform\"` Field\n\nThe `\"platform\"` field defines the platforms where the dependency should be installed - for example,\nyou might need to use sha256, and so you use platform primitives on Windows, but `picosha2` on non-Windows platforms.\n\n```json\n{\n  \"name\": \"picosha2\",\n  \"platform\": \"!windows\"\n}\n```\n\nThis is a string field which takes boolean expressions of the form `<identifier>`,\n`!expression`, `expression { & expression & expression...}`, and `expression { | expression | expression...}`,\nalong with parentheses to denote precedence.\nFor example, a dependency that's only installed on the Windows OS, for the ARM64 architecture,\nand on Linux on x64, would be written `(windows & arm64) | (linux & x64)`.\n\nThe common identifiers are:\n\n- The operating system: `windows`, `uwp`, `linux`, `osx` (includes macOS), `android`, `emscripten`\n- The architecture: `x86`, `x64`, `wasm32`, `arm64`, `arm` (includes both arm32 and arm64 due to backwards compatibility)\n\nalthough one can define their own.\n\n#### `\"version>=\"` Field\n\n**Experimental behind the `versions` feature flag**\n\nA minimum version constraint on the dependency.\n\nThis field specifies the minimum version of the dependency using a '#' suffix to denote port-version if non-zero.\n\nSee also [versioning](versioning.md#version-1) for more semantic details.\n\n### `\"overrides\"`\n\n**Experimental behind the `versions` feature flag**\n\nThis field enables version resolution to be ignored for certain dependencies and to use specific versions instead.\n\nSee also [versioning](versioning.md#overrides) for more semantic details.\n\n#### Example:\n\n```json\n  \"overrides\": [\n    {\n      \"name\": \"arrow\", \"version\": \"1.2.3\", \"port-version\": 7\n    }\n  ]\n```\n\n### `\"supports\"`\n\nIf your project doesn't support common platforms, you can tell your users this with the `\"supports\"` field.\nIt uses the same platform expressions as [`\"platform\"`](#platform), from dependencies, as well as the\n`\"supports\"` field of features.\nFor example, if your library doesn't support linux, you might write `{ \"supports\": \"!linux\" }`.\n\n\n### `\"features\"` and `\"default-features\"`\n\nThe `\"features\"` field defines _your_ project's optional features, that others may either depend on or not.\nIt's an object, where the keys are the names of the features, and the values are objects describing the feature.\n`\"description\"` is required,\nand acts exactly like the [`\"description\"`](#description) field on the global package,\nand `\"dependencies\"` are optional,\nand again act exactly like the [`\"dependencies\"`](#dependencies) field on the global package.\nThere's also the `\"supports\"` field,\nwhich again acts exactly like the [`\"supports\"`](#supports) field on the global package.\n\nYou also have control over which features are default, if a person doesn't ask for anything specific,\nand that's the `\"default-features\"` field, which is an array of feature names.\n\n#### Example:\n\n```json\n{\n  \"name\": \"libdb\",\n  \"version\": \"1.0.0\",\n  \"description\": [\n    \"An example database library.\",\n    \"Optionally can build with CBOR, JSON, or CSV as backends.\"\n  ],\n  \"$default-features-explanation\": \"Users using this library transitively will get all backends automatically\",\n  \"default-features\": [ \"cbor\", \"csv\", \"json\" ],\n  \"features\": {\n    \"cbor\": {\n      \"description\": \"The CBOR backend\",\n      \"dependencies\": [\n        {\n          \"$explanation\": [\n            \"This is how you tell vcpkg that the cbor feature depends on the json feature of this package\"\n          ],\n          \"name\": \"libdb\",\n          \"default-features\": false,\n          \"features\": [ \"json\" ]\n        }\n      ]\n    },\n    \"csv\": {\n      \"description\": \"The CSV backend\",\n      \"dependencies\": [\n        \"fast-cpp-csv-parser\"\n      ]\n    },\n    \"json\": {\n      \"description\": \"The JSON backend\",\n      \"dependencies\": [\n        \"jsoncons\"\n      ]\n    }\n  }\n}\n```\n\n## Command Line Interface\n\n**Experimental behind the `manifests` feature flag**\n\nWhen invoked from any subdirectory of the directory containing `vcpkg.json`, `vcpkg install` with no package arguments\nwill install all manifest dependencies into `<directory containing vcpkg.json>/vcpkg_installed/`. Most of `vcpkg\ninstall`'s classic mode parameters function the same in manifest mode.\n\n### `--x-install-root=<path>`\n\n**Experimental and may change or be removed at any time**\n\nSpecifies an alternate install location than `<directory containing vcpkg.json>/vcpkg_installed/`.\n\n### `--triplet=<triplet>`\n\nSpecify the triplet to be used for installation.\n\nDefaults to the same default triplet as in classic mode.\n\n### `--x-feature=<feature>`\n\n**Experimental and may change or be removed at any time**\n\nSpecify an additional feature from the `vcpkg.json` to install dependencies from.\n\n### `--x-no-default-features`\n\n**Experimental and may change or be removed at any time**\n\nDisables automatic activation of all default features listed in the `vcpkg.json`.\n\n### `--x-manifest-root=<path>`\n\n**Experimental and may change or be removed at any time**\n\nSpecifies the directory containing `vcpkg.json`.\n\nDefaults to searching upwards from the current working directory.\n\n## CMake Integration\n\nOur [CMake Integration](integration.md#cmake) will automatically detect a `vcpkg.json` manifest file in the same\ndirectory as the top-level `CMakeLists.txt` (`${CMAKE_SOURCE_DIR}/vcpkg.json`) and activate manifest mode. Vcpkg will be\nautomatically bootstrapped if missing and invoked to install your dependencies into your local build directory\n(`${CMAKE_BINARY_DIR}/vcpkg_installed`).\n\n### Configuration\n\nAll vcpkg-affecting variables must be defined before the first `project()` directive, such as via the command line or\n`set()` statements.\n\n#### `VCPKG_TARGET_TRIPLET`\n\nThis variable controls which triplet dependencies will be installed for.\n\nIf unset, vcpkg will automatically detect an appropriate default triplet given the current compiler settings.\n\n#### `VCPKG_HOST_TRIPLET`\n\nThis variable controls which triplet host dependencies will be installed for.\n\nIf unset, vcpkg will automatically detect an appropriate native triplet (x64-windows, x64-osx, x64-linux).\n\nSee also [Host Dependencies](host-dependencies.md).\n\n#### `VCPKG_MANIFEST_MODE`\n\nThis variable controls whether vcpkg operates in manifest mode or in classic mode. To disable manifest mode even with a\n`vcpkg.json`, set this to `OFF`.\n\nDefaults to `ON` when `VCPKG_MANIFEST_DIR` is non-empty or `${CMAKE_SOURCE_DIR}/vcpkg.json` exists.\n\n#### `VCPKG_MANIFEST_DIR`\n\nThis variable can be defined to specify an alternate folder containing your `vcpkg.json` manifest.\n\nDefaults to `${CMAKE_SOURCE_DIR}` if `${CMAKE_SOURCE_DIR}/vcpkg.json` exists.\n\n#### `VCPKG_MANIFEST_INSTALL`\n\nThis variable controls whether vcpkg will be automatically run to install your dependencies during your configure step.\n\nDefaults to `ON` if `VCPKG_MANIFEST_MODE` is `ON`.\n\n#### `VCPKG_BOOTSTRAP_OPTIONS`\n\nThis variable can be set to additional command parameters to pass to `./bootstrap-vcpkg` (run in automatic restore mode\nif the vcpkg tool does not exist).\n\n#### `VCPKG_OVERLAY_TRIPLETS`\n\nThis variable can be set to a list of paths to be passed on the command line as `--overlay-triplets=...`\n\n#### `VCPKG_OVERLAY_PORTS`\n\nThis variable can be set to a list of paths to be passed on the command line as `--overlay-ports=...`\n\n#### `VCPKG_MANIFEST_FEATURES`\n\nThis variable can be set to a list of features to treat as active when installing from your manifest.\n\nFor example, Features can be used by projects to control building with additional dependencies to enable tests or\nsamples:\n\n```json\n{\n  \"name\": \"mylibrary\",\n  \"version\": \"1.0\",\n  \"dependencies\": [ \"curl\" ],\n  \"features\": {\n    \"samples\": {\n      \"description\": \"Build Samples\",\n      \"dependencies\": [ \"fltk\" ]\n    },\n    \"tests\": {\n      \"description\": \"Build Tests\",\n      \"dependencies\": [ \"gtest\" ]\n    }\n  }\n}\n```\n```cmake\n# CMakeLists.txt\n\noption(BUILD_TESTING \"Build tests\" OFF)\nif(BUILD_TESTING)\n  list(APPEND VCPKG_MANIFEST_FEATURES \"tests\")\nendif()\n\noption(BUILD_SAMPLES \"Build samples\" OFF)\nif(BUILD_SAMPLES)\n  list(APPEND VCPKG_MANIFEST_FEATURES \"samples\")\nendif()\n\nproject(myapp)\n\n# ...\n```\n\n#### `VCPKG_MANIFEST_NO_DEFAULT_FEATURES`\n\nThis variable controls whether to automatically activate all default features in addition to those listed in\n`VCPKG_MANIFEST_FEATURES`. If set to `ON`, default features will not be automatically activated.\n\nDefaults to `OFF`.\n\n#### `VCPKG_INSTALL_OPTIONS`\n\nThis variable can be set to a list of additional command line parameters to pass to the vcpkg tool during automatic\ninstallation.\n\n#### `VCPKG_PREFER_SYSTEM_LIBS`\n\nThis variable controls whether vcpkg will appends instead of prepends its paths to `CMAKE_PREFIX_PATH`, `CMAKE_LIBRARY_PATH` and `CMAKE_FIND_ROOT_PATH` so that vcpkg libraries/packages are found after toolchain/system libraries/packages.\n\nDefaults to `OFF`.\n\n#### `VCPKG_FEATURE_FLAGS`\n\nThis variable can be set to a list of feature flags to pass to the vcpkg tool during automatic installation to opt-in to\nexperimental behavior.\n\nSee the `--feature-flags=` command line option for more information.\n\n## MSBuild Integration\n\nTo use manifests with MSBuild, first you need to use an [existing integration method](integration.md#with-msbuild).\nThen, simply add a vcpkg.json above your project file (such as in the root of your source repository) and set the\nproperty `VcpkgEnableManifest` to `true`. You can set this property via the IDE in `Project Properties -> Vcpkg -> Use\nVcpkg Manifest`.\n\nAs part of your project's build, vcpkg automatically be run and install any listed dependencies to `vcpkg_installed/`\nadjacent to the `vcpkg.json` file; these files will then automatically be included in and linked to your MSBuild\nprojects.\n\nNote: It is critical that all project files in a single build consuming the same `vcpkg.json` use the same triplet; if\nyou need to use different triplets for different projects in your solution, they must consume from different\n`vcpkg.json` files.\n\n### MSBuild Properties\n\nThese properties can be defined via the VS GUI under `Project Properties -> Vcpkg` or via a common `.props` file.\n\n#### `VcpkgEnabled` (Use Vcpkg)\n\nThis can be set to \"false\" to explicitly disable vcpkg integration for the project\n\n#### `VcpkgTriplet` (Triplet)\n\nThis can be set to a custom triplet to use for integration (such as x64-windows-static)\n\n#### `VcpkgHostTriplet` (Host Triplet)\n\nThis can be set to a custom triplet to use for resolving host dependencies.\n\nIf unset, this will default to the \"native\" triplet (x64-windows, x64-osx, x64-linux).\n\nSee also [Host Dependencies](host-dependencies.md).\n\n#### `VcpkgAdditionalInstallOptions` (Additional Options)\n\nWhen using a manifest, this option specifies additional command line flags to pass to the underlying vcpkg tool\ninvocation. This can be used to access features that have not yet been exposed through another option.\n\n#### `VcpkgConfiguration` (Vcpkg Configuration)\n\nIf your configuration names are too complex for vcpkg to guess correctly, you can assign this property to `Release` or\n`Debug` to explicitly tell vcpkg what variant of libraries you want to consume.\n\n#### `VcpkgEnableManifest` (Use Vcpkg Manifest)\n\nThis property must be set to true in order to consume from a local vcpkg.json file. If set to false, any local\nvcpkg.json files will be ignored. This will default to true in the future.\n\n#### `VcpkgManifestInstall` (Install Vcpkg Dependencies)\n\n*(Requires `Use Vcpkg Manifest` set to `true`)*\n\nThis property can be set to \"false\" to disable automatic dependency restoration on project build. Dependencies can be\nmanually restored via the vcpkg command line.\n\n#### `VcpkgInstalledDirectory` (Installed Directory)\n\nThis property defines the location where headers and binaries are consumed from. In manifest mode, this directory is\ncreated and populated based on your manifest.\n","Nav":"#"},{"Path":"/en/docs/users/mingw.html","Name":"Mingw","Source":"# Vcpkg and Mingw-w64\n\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/users/mingw.md).**\n\n*MinGW is community-supported and not tested as part of vcpkg repository's CI process.*\n\n## Table of Contents\n\n - [Mingw-w64 community triplets](#Mingw-w64-community-triplets)\n - [Using Mingw-w64 natively on Windows](#Using-Mingw-w64-natively-on-Windows)\n   - [How to avoid mixing different installations](#How-to-avoid-mixing-different-installations)\n - [Using Mingw-w64 to build Windows programs on other systems](#Using-Mingw-w64-to-build-Windows-programs-on-other-systems)\n\n## Mingw-w64 community triplets\n\nVcpkg includes\n[x64, x86, arm64 and arm community triplets](https://github.com/microsoft/vcpkg/tree/master/triplets/community)\nfor [Mingw-w64](http://mingw-w64.org/). They don't depend on Visual Studio and\ncan be used natively on Windows as well as for cross-compiling on\nother operating systems. There are two variants of each triplet,\nselecting between static and dynamic linking. The actual tools\n(g++ etc.) are expected to be named with particular prefixes.\n\n| architecture | vcpkg community triplets                | tool name prefix     |\n|--------------|-----------------------------------------|----------------------|\n| x64          | x64-mingw-dynamic, x64-mingw-static     | x86_64-w64-mingw32-  |\n| x86          | x86-mingw-dynamic, x86-mingw-static     | i686-w64-mingw32-    |\n| arm64        | arm64-mingw-dynamic, arm64-mingw-static | aarch64-w64-mingw32- |\n| arm          | arm-mingw-dynamic, arm-mingw-static     | armv7-w64-mingw32-   |\n\nThese triplets are not tested by continuous integration, so many ports\ndo not build, and even existing ports may break on port updates.\nBecause of this, community involvement is paramount!\n\n- [Discussions](https://github.com/microsoft/vcpkg/discussions?discussions_q=mingw)\n- [Open issues](https://github.com/microsoft/vcpkg/issues?q=is%3Aissue+is%3Aopen+mingw)\n- [Open pull requests](https://github.com/microsoft/vcpkg/pulls?q=is%3Apr+is%3Aopen+mingw)\n\n## Using Mingw-w64 natively on Windows\n\nWith [MSYS2](https://www.msys2.org/), it is possible to easily create\na full environment for building ports with Mingw-w64 on a Windows PC.\n\nNote that for building software for native windows environments, you\nmust use a mingw subsystem of MSYS2, and install some packages \n(with a specific prefix) for this subsystem.\n\n| architecture | vcpkg triplets                      | subsystem | package prefix    |\n|--------------|-------------------------------------|-----------|-------------------|\n| x64          | x64-mingw-dynamic, x64-mingw-static | mingw64   | mingw-w64-x86_64- |\n| x86          | x86-mingw-dynamic, x86-mingw-static | mingw32   | mingw-w64-i686-   |\n\nAfter the basic installation of MSYS2, you will need to install a few\nadditional packages for software development, e.g. for x64:\n\n```bash\npacman -S --needed git base-devel mingw-w64-x86_64-toolchain\n```\n\nThe active subsystem is selected by running the MSYS2 MinGW app, or\nchanged in a running terminal by\n\n```bash\nsource shell mingw64   # for x64, or \"mingw32\" for x86\n```\n\nThe bootstrapping of vcpkg shall be done by running bootstrap-vcpkg.bat.\nThis will download the official vcpkg.exe.\n\n```bash\ngit clone https://github.com/microsoft/vcpkg.git\ncd vcpkg\n./bootstrap-vcpkg.bat\n```\n\nFor building packages, you need to tell vcpkg that you want to use the\nmingw triplet. This can be done in different ways. When Visual Studio\nis not installed, you must also set the host triplet to mingw. This is\nneeded to resolve host dependencies. For convenience, you can use\nenvironment variables to set both triplets:\n\n```bash\nexport VCPKG_DEFAULT_TRIPLET=x64-mingw-dynamic\nexport VCPKG_DEFAULT_HOST_TRIPLET=x64-mingw-dynamic\n```\n\nNow you can test your setup:\n\n```bash\n./vcpkg install zlib\n```\n\n### How to avoid mixing different installations\n\n[The MSYS2 project explicitly warns](https://www.msys2.org/wiki/MSYS2-introduction/#path)\nthat \"mixing in programs from other MSYS2 installations, Cygwin installations,\ncompiler toolchains or even various other programs is not supported and will\nprobably break things in unexpected ways.\" For example, the proper passing of\ncommand line arguments with quoting and escaping may fail.\n\nBut Vcpkg ports implicitly create MSYS2 installations, e.g. for `pkg-config`\nand for various other build tools needed to deal with packages based on\nautoconf. In particular, when ports prepend the directory of tools to the\n`PATH` environment variable, this may change which tool with a particular\nname is actually invoked, and how arguments are passed between tools.\n\nTo mitigate such issues when working with a full MSYS2 installation,\ntry to keep the directories of the msys subsystem (`/usr/bin`, `bin`)\nout of the `PATH` environment variable as found by vcpkg. In bash, you\nmay modify the `PATH` just for a single call of vcpkg:\n\n```bash\nPATH=\"${PATH/:\\/usr\\/bin:\\/bin:/:}\" ./vcpkg install libpq\n```\n\nAlternatively, you may run vcpkg from a regular Command Prompt, after\nadding *only* the desired mingw directory (e.g. `C:\\msys64\\mingw64\\bin`)\nto the `PATH`.\n\nWhen using vcpkg for CI with standard images on Azure Pipelines, Github Actions\nor similar, note that the default `PATH` might contain more directories\nwhich create a mix of MSYS2 programs from different installations. You may\nwant to set the desired `PATH` manually, or remove directories which contain\n`sh.exe`, `bash.exe`, `msys-2.0.dll` or `cygwin1.dll`.\n\n## Using Mingw-w64 to build Windows programs on other systems\n\nYou can use the vcpkg mingw community triplets with toolchains on\nnon-Windows computers to cross-compile software to be run on Windows.\nMany Linux distributions offer such toolchains in optional packages\nwith a mingw-w64 [suffix](https://repology.org/projects/?search=-mingw-w64)\nor [prefix](https://repology.org/projects/?search=mingw-w64-).\nAs an example, for Debian-based distributions, you would start with\nthis installation command for the x64 toolchain:\n\n```\nsudo apt-get install gcc-mingw-w64-x86-64 g++-mingw-w64-x86-64\n```\n\nNote that the packaged versions of Mingw-w64 toolchains on Linux distributions\nmight be older releases which lack some useful features or bug fixes.\nAn alternative independent toolchain is offered by [MXE](https://mxe.cc/).\n\nFor vcpkg bootstrapping, clone the github repository and run the\n`bootstrap-vcpkg.sh` script:\n\n```bash\ngit clone https://github.com/microsoft/vcpkg.git\ncd vcpkg\n./bootstrap-vcpkg.sh\n./vcpkg install zlib:x64-mingw-dynamic\n```\n\n","Nav":"#"},{"Path":"/en/docs/users/registries.html","Name":"Registries","Source":"# Using Registries\n\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/users/registries.md).**\n\nThere are two parts to using registries; this documents the use side of the\nrelationship. In order to learn more about creating registries for others to\nuse, please read [this documentation](../maintainers/registries.md).\n\n## Table of Contents\n\n- [Using Registries](#using-registries)\n  - [Table of Contents](#table-of-contents)\n  - [`vcpkg-configuration.json`](#vcpkg-configurationjson)\n    - [Registry Objects](#registry-objects)\n      - [Registry Objects: `\"kind\"`](#registry-objects-kind)\n      - [Registry Objects: `\"baseline\"`](#registry-objects-baseline)\n      - [Registry Objects: `\"repository\"`](#registry-objects-repository)\n      - [Registry Objects: `\"path\"`](#registry-objects-path)\n    - [Configuration: `\"default-registry\"`](#configuration-default-registry)\n    - [Configuration: `\"registries\"`](#configuration-registries)\n    - [Example Configuration File](#example-configuration-file)\n  - [Package Name Resolution](#package-name-resolution)\n    - [Versioning Support](#versioning-support)\n\n## `vcpkg-configuration.json`\n\nFrom a high level perspective, everything that a project needs to define\nabout registries is contained in the vcpkg configuration file. In classic\nmode, the configuration file lies in the vcpkg root; for manifest mode,\nthe file must exist next to the project's `vcpkg.json` file.\nThis file is named `vcpkg-configuration.json`, and it's a simple top-level\nobject file.\n\n### Registry Objects\n\nRegistries are defined in JSON as objects. They must contain at least the\n`\"kind\"` and `\"baseline\"` fields, and additionally the different kinds of\nregistry will have their own way of defining where the registry can be found:\n\n- git registries require the `\"repository\"` field\n- filesystem registries require the `\"path\"` field\n- built-in registries do not require a field, since there is only one\n  built-in registry.\n\n#### Registry Objects: `\"kind\"`\n\nThe `\"kind\"` field must be a string:\n\n- For git registries: `\"git\"`\n- For filesystem registries: `\"filesystem\"`\n- For the builtin registry: `\"builtin\"`\n\n#### Registry Objects: `\"baseline\"`\n\nThe `\"baseline\"` field must be a string. For git registries and for the \nbuilt-in registry, it should be a 40-character commit ID.\nFor filesystem registries, it can be any string that the registry defines.\n\n#### Registry Objects: `\"repository\"`\n\nThis should be a string, of any repository format that git understands:\n\n- `\"https://github.com/microsoft/vcpkg\"`\n- `\"git@github.com:microsoft/vcpkg\"`\n- `\"/dev/vcpkg-registry\"`\n\n#### Registry Objects: `\"path\"`\n\nThis should be a path; it can be either absolute or relative; relative paths\nwill be based at the directory the `vcpkg-configuration.json` lives in.\n\n### Configuration: `\"default-registry\"`\n\nThe `\"default-registry\"` field should be a registry object. It defines\nthe registry that is used for all packages that are not claimed by any\npackage registries. It may also be `null`, in which case no packages that\nare not claimed by package registries may be installed.\n\n### Configuration: `\"registries\"`\n\nThe `\"registries\"` field should be an array of registry objects, each of\nwhich additionally contain a `\"packages\"` field, which should be an array of\npackage names. These define the package registries, which are used for \nthe specific packages named by the `\"packages\"` field.\n\nThe `\"packages\"` fields of all the package registries must be disjoint.\n\n### Example Configuration File\n\nLet's assume that you have mirrored <https://github.com/microsoft/vcpkg> at\n<https://git.example.com/vcpkg>: this will be your default registry.\nAdditionally, you want to use North Wind Trader's registry for their\nbeison and beicode libraries. The following `vcpkg-configuration.json`\nwill work:\n\n```json\n{\n  \"default-registry\": {\n    \"kind\": \"git\",\n    \"repository\": \"https://git.example.com/vcpkg\",\n    \"baseline\": \"eefee7408133f3a0fef711ef9c6a3677b7e06fd7\"\n  },\n  \"registries\": [\n    {\n      \"kind\": \"git\",\n      \"repository\": \"https://github.com/northwindtraders/vcpkg-registry\",\n      \"baseline\": \"dacf4de488094a384ca2c202b923ccc097956e0c\",\n      \"packages\": [ \"beicode\", \"beison\" ]\n    }\n  ]\n}\n```\n\n## Package Name Resolution\n\nThe way package name resolution works in vcpkg is fairly distinct from many\npackage managers. It is very carefully designed to _never_ implicitly choose\nthe registry that a package is fetched from. Just from\n`vcpkg-configuration.json`, one can tell exactly from which registry a\npackage definition will be fetched from.\n\nThe name resolution algorithm is as follows:\n\n- If there is a package registry that claims the package name,\n  use that registry; otherwise\n- If there is a default registry defined, use that registry; otherwise\n- If the default registry is set to `null`, error out; otherwise\n- use the built-in registry.\n\n### Versioning Support\n\nVersioning with custom registries works exactly as it does in the built-in\nregistry. You can read more about that in the [versioning documentation].\n\n[versioning documentation]: versioning.md","Nav":"#"},{"Path":"/en/docs/users/selecting-library-features.html","Name":"Selecting-library-features","Source":"# Selecting Library Features\n\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/users/selecting-library-features.md).**\n\n## Installing a library\n\nWe will look at [llvm](https://llvm.org/) as an example. You could install it using:\n\n```powershell\n> vcpkg install llvm\n```\nor via a manifest with\n```json\n{\n  \"dependencies\": [\"llvm\"]\n}\n```\n\nWith llvm now installed, we can execute:\n\n```powershell\n> installed\\x86-windows\\bin\\llc.exe --version\n```\n\nwe see:\n\n```powershell\n  Registered Targets:\n    x86    - 32-bit X86: Pentium-Pro and above\n    x86-64 - 64-bit X86: EM64T and AMD64\n```\n\n## Installing additional features\n\nBut [llvm supports many more targets](https://llvm.org/docs/GettingStarted.html#local-llvm-configuration), from ARM to SPARC to SystemZ.\nHowever, clearly our current installation doesn't include ARM as a target;\nthus, we need to learn how vcpkg allows us to install other LLVM targets.\nThe llvm port allows this via the \"target-*\" features.\n\nIf we do:\n\n```powershell\n> vcpkg search llvm\n```\n\nWe can see:\n\n```\nllvm                 10.0.0#6         The LLVM Compiler Infrastructure\nllvm[clang]                           Build C Language Family Front-end.\nllvm[clang-tools-extra]               Build Clang tools.\n...\nllvm[target-all]                      Build with all backends.\nllvm[target-amdgpu]                   Build with AMDGPU backend.\nllvm[target-arm]                      Build with ARM backend.\n...\n```\n\nWe can install any of these targets by using the install-feature syntax:\n\n```powershell\n> vcpkg install llvm[target-arm] # Installs LLVM with the ARM target\n```\n```json\n{\n  \"dependencies\": [{ \"name\": \"llvm\", \"features\": [\"target-arm\"] }]\n}\n```\n\n## Opting out of default features\n\nThe llvm port includes a few default features that you as a user may not want: for example,\nthe `clang` feature is default, which means that `vcpkg install llvm` will also build and install clang.\nIf you are writing a compiler that uses LLVM as a backend,\nyou're likely not interested in installing clang as well,\nand we can do that by disabling default features with the special `core` \"feature\":\n```powershell\n> vcpkg install llvm[core,target-arm] # removing the default-feature with \"core\" also removes all of the default targets you get\n```\nor in manifest files:\n```json\n{\n  \"dependencies\": [{\n    \"name\": \"llvm\",\n    \"default-features\": false,\n    \"features\": [\"target-arm\"]\n  }]\n}\n```\n\n# Further reading\n- The [Feature Packages](../specifications/feature-packages.md) specification was the initial design for features.\n","Nav":"#"},{"Path":"/en/docs/users/triplets.html","Name":"Triplets","Source":"# Triplet Files\n\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/users/triplets.md).**\n\nTriplet is a standard term used in cross compiling as a way to completely capture the target environment (cpu, os, compiler, runtime, etc) in a single convenient name.\n\nIn Vcpkg, we use triplets to describe an imaginary \"target configuration set\" for every library. Within a triplet, libraries are generally built with the same configuration, but it is not a requirement. For example, you could have one triplet that builds `openssl` statically and `zlib` dynamically, one that builds them both statically, and one that builds them both dynamically (all for the same target OS and architecture). A single build will consume files from a single triplet.\n\nWe currently provide many triplets by default (run `vcpkg help triplet`). However, you can easily customize or add your own by copying a built-in triplet from the `triplets\\` directory into a project local location. Then, use overlay triplets (such as [`$VCPKG_OVERLAY_TRIPLETS`](config-environment.md#vcpkg_overlay_triplets), [CMake Manifest Mode](manifests.md#vcpkg_overlay_triplets), or [MSBuild Manifest Mode](manifests.md#vcpkgadditionalinstalloptions-additional-options)) to add that directory to vcpkg. See our [overlay triplets example](../examples/overlay-triplets-linux-dynamic.md) for a more detailed walkthrough.\n\nTo change the triplet used by your project away from the default, see our [Integration Document](integration.md#triplet-selection).\n\n## Community triplets\n\nTriplets contained in the `triplets\\community` folder are not tested by continuous integration, but are commonly requested by the community.\n\nBecause we do not have continuous coverage, port updates may break compatibility with community triplets. Because of this, community involvement is paramount!\n\nWe will gladly accept and review contributions that aim to solve issues with these triplets.\n\n### Usage\n\nCommunity Triplets are enabled by default, when using a community triplet a message like the following one will be printed during a package install:\n\n```no-highlight\n-- Using community triplet x86-uwp. This triplet configuration is not guaranteed to succeed.\n-- [COMMUNITY] Loading triplet configuration from: D:\\src\\viromer\\vcpkg\\triplets\\community\\x86-uwp.cmake\n```\n\n## Variables\n### VCPKG_TARGET_ARCHITECTURE\nSpecifies the target machine architecture.\n\nValid options are `x86`, `x64`, `arm`, `arm64` and `wasm32`.\n\n### VCPKG_CRT_LINKAGE\nSpecifies the desired CRT linkage (for MSVC).\n\nValid options are `dynamic` and `static`.\n\n### VCPKG_LIBRARY_LINKAGE\nSpecifies the preferred library linkage.\n\nValid options are `dynamic` and `static`. Note that libraries can ignore this setting if they do not support the preferred linkage type.\n\n### VCPKG_CMAKE_SYSTEM_NAME\nSpecifies the target platform.\n\nValid options include any CMake system name, such as:\n- Empty (Windows Desktop for legacy reasons)\n- `WindowsStore` (Universal Windows Platform)\n- `MinGW` (Minimalist GNU for Windows)\n- `Darwin` (Mac OSX)\n- `iOS` (iOS)\n- `Linux` (Linux)\n- `Emscripten` (WebAssembly)\n\n### VCPKG_CMAKE_SYSTEM_VERSION\nSpecifies the target platform system version.\n\nThis field is optional and, if present, will be passed into the build as `CMAKE_SYSTEM_VERSION`.\n\nSee also the CMake documentation for `CMAKE_SYSTEM_VERSION`: https://cmake.org/cmake/help/latest/variable/CMAKE_SYSTEM_VERSION.html.\n\n### VCPKG_CHAINLOAD_TOOLCHAIN_FILE\nSpecifies an alternate CMake Toolchain file to use.\n\nThis (if set) will override all other compiler detection logic. By default, a toolchain file is selected from `scripts/toolchains/` appropriate to the platform.\n\nSee also the CMake documentation for toolchain files: https://cmake.org/cmake/help/v3.11/manual/cmake-toolchains.7.html.\n\n### VCPKG_CXX_FLAGS\nSets additional compiler flags to be used when not using `VCPKG_CHAINLOAD_TOOLCHAIN_FILE`.\n\nThis option also has forms for configuration-specific and C flags:\n- `VCPKG_CXX_FLAGS`\n- `VCPKG_CXX_FLAGS_DEBUG`\n- `VCPKG_CXX_FLAGS_RELEASE`\n- `VCPKG_C_FLAGS`\n- `VCPKG_C_FLAGS_DEBUG`\n- `VCPKG_C_FLAGS_RELEASE`\n\n### VCPKG_LINKER_FLAGS\nSets additional linker flags to be used while building dynamic libraries and\nexecutables in the absence of `VCPKG_CHAINLOAD_TOOLCHAIN_FILE`.\n\nThis option also has forms for configuration-specific flags:\n- `VCPKG_LINKER_FLAGS`\n- `VCPKG_LINKER_FLAGS_DEBUG`\n- `VCPKG_LINKER_FLAGS_RELEASE`\n\n### VCPKG_CMAKE_CONFIGURE_OPTIONS\nSet additional CMake configure options that are appended to the configure command (in [`vcpkg_cmake_configure`](../maintainers/ports/vcpkg-cmake/vcpkg_cmake_configure.md)).\n\nThis field is optional.\n\nAlso available as build-type specific `VCPKG_CMAKE_CONFIGURE_OPTIONS_DEBUG` and `VCPKG_CMAKE_CONFIGURE_OPTIONS_RELEASE` variables.\n\n### VCPKG_MAKE_CONFIGURE_OPTIONS\nSet additional automake / autoconf configure options that are appended to the configure command (in [`vcpkg_configure_make`](../maintainers/vcpkg_configure_make.md)).\n\nThis field is optional.\n\nFor example, to skip certain libtool checks that may errantly fail:\n```cmake\nset(VCPKG_MAKE_CONFIGURE_OPTIONS \"lt_cv_deplibs_check_method=pass_all\")\n```\n\nAlso available as build-type specific `VCPKG_MAKE_CONFIGURE_OPTIONS_DEBUG` and `VCPKG_MAKE_CONFIGURE_OPTIONS_RELEASE` variables.\n\n<a name=\"VCPKG_DEP_INFO_OVERRIDE_VARS\"></a>\n### VCPKG_DEP_INFO_OVERRIDE_VARS\nReplaces the default computed list of triplet \"Supports\" terms.\n\nThis option (if set) will override the default set of terms used for qualified dependency resolution and \"Supports\" field evaluation.\n\nSee the [`\"supports\"`](../maintainers/manifest-files.md#supports) manifest file field documentation for more details.\n\n> Implementers' Note: this list is extracted via the `vcpkg_get_dep_info` mechanism.\n\n## Windows Variables\n\n### VCPKG_ENV_PASSTHROUGH\nInstructs vcpkg to allow additional environment variables into the build process.\n\nOn Windows, vcpkg builds packages in a special clean environment that is isolated from the current command prompt to\nensure build reliability and consistency. This triplet option can be set to a list of additional environment variables\nthat will be added to the clean environment. The values of these environment variables will be hashed into the package\nabi -- to pass through environment variables without abi tracking, see `VCPKG_ENV_PASSTHROUGH_UNTRACKED`.\n\nSee also the `vcpkg env` command for how you can inspect the precise environment that will be used.\n\n> Implementers' Note: this list is extracted via the `vcpkg_get_tags` mechanism.\n\n### VCPKG_ENV_PASSTHROUGH_UNTRACKED\nInstructs vcpkg to allow additional environment variables into the build process without abi tracking.\n\nSee `VCPKG_ENV_PASSTHROUGH`.\n\n<a name=\"VCPKG_VISUAL_STUDIO_PATH\"></a>\n### VCPKG_VISUAL_STUDIO_PATH\nSpecifies the Visual Studio installation to use.\n\nTo select the precise combination of Visual Studio instance and toolset version, we walk through the following algorithm:\n1. Determine the setting for `VCPKG_VISUAL_STUDIO_PATH` from the triplet, or the environment variable `VCPKG_VISUAL_STUDIO_PATH`, or consider it unset\n2. Determine the setting for `VCPKG_PLATFORM_TOOLSET` from the triplet or consider it unset\n3. Gather a list of all pairs of Visual Studio Instances with all toolsets available in those instances\n    1. This is ordered first by instance type (Stable, Prerelease, Legacy) and then by toolset version (v142, v141, v140)\n4. Filter the list based on the settings for `VCPKG_VISUAL_STUDIO_PATH` and `VCPKG_PLATFORM_TOOLSET`.\n5. Select the best remaining option\n\nThe path should be absolute, formatted with backslashes, and have no trailing slash:\n```cmake\nset(VCPKG_VISUAL_STUDIO_PATH \"C:\\\\Program Files (x86)\\\\Microsoft Visual Studio\\\\Preview\\\\Community\")\n```\n\n### VCPKG_PLATFORM_TOOLSET\nSpecifies the VS-based C/C++ compiler toolchain to use.\n\nSee [`VCPKG_VISUAL_STUDIO_PATH`](#VCPKG_VISUAL_STUDIO_PATH) for the full selection algorithm.\n\nValid settings:\n* The Visual Studio 2019 platform toolset is `v142`.\n* The Visual Studio 2017 platform toolset is `v141`.\n* The Visual Studio 2015 platform toolset is `v140`.\n\n### VCPKG_LOAD_VCVARS_ENV\nIf `VCPKG_CHAINLOAD_TOOLCHAIN_FILE` is used, VCPKG will not setup the Visual Studio environment.\nSetting `VCPKG_LOAD_VCVARS_ENV` to (true|1|on) changes this behavior so that the Visual Studio environment is setup following the same rules as if `VCPKG_CHAINLOAD_TOOLCHAIN_FILE` was not set.\n\n## MacOS Variables\n\n### VCPKG_INSTALL_NAME_DIR\nSets the install name used when building macOS dynamic libraries. Default value is `@rpath`. See the CMake documentation for [CMAKE_INSTALL_NAME_DIR](https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_NAME_DIR.html) for more information.\n\n### VCPKG_OSX_DEPLOYMENT_TARGET\nSets the minimum macOS version for compiled binaries. This also changes what versions of the macOS platform SDK that CMake will search for. See the CMake documentation for [CMAKE_OSX_DEPLOYMENT_TARGET](https://cmake.org/cmake/help/latest/variable/CMAKE_OSX_DEPLOYMENT_TARGET.html) for more information.\n\n### VCPKG_OSX_SYSROOT\nSet the name or path of the macOS platform SDK that will be used by CMake. See the CMake documentation for [CMAKE_OSX_SYSROOT](https://cmake.org/cmake/help/latest/variable/CMAKE_OSX_SYSROOT.html) for more information.\n\n\n### VCPKG_OSX_ARCHITECTURES\nSet the macOS / iOS target architecture which will be used by CMake. See the CMake documentation for [CMAKE_OSX_ARCHITECTURES](https://cmake.org/cmake/help/latest/variable/CMAKE_OSX_ARCHITECTURES.html) for more information.\n\n## Per-port customization\nThe CMake Macro `PORT` will be set when interpreting the triplet file and can be used to change settings (such as `VCPKG_LIBRARY_LINKAGE`) on a per-port basis.\n\nExample:\n```cmake\nset(VCPKG_LIBRARY_LINKAGE static)\nif(PORT MATCHES \"qt5-\")\n    set(VCPKG_LIBRARY_LINKAGE dynamic)\nendif()\n```\nThis will build all the `qt5-*` libraries as DLLs, but every other library as a static library.\n\nFor an example in a real project, see https://github.com/Intelight/vcpkg/blob/master/triplets/x86-windows-mixed.cmake.\n\n## Additional Remarks\nThe default triplet when running any vcpkg command is `%VCPKG_DEFAULT_TRIPLET%` or a platform-specific choice if that environment variable is undefined.\n\n- Windows: `x86-windows`\n- Linux: `x64-linux`\n- OSX: `x64-osx`\n\nWe recommend using a systematic naming scheme when creating new triplets. The Android toolchain naming scheme is a good source of inspiration: https://developer.android.com/ndk/guides/standalone_toolchain.html.\n\n## Android triplets\nSee [android.md](android.md)\n\n## Mingw-w64 triplets\nSee [mingw.md](mingw.md)\n","Nav":"#"},{"Path":"/en/docs/users/versioning.implementation-details.html","Name":"Versioning.implementation-details","Source":"# Versioning: Implementation details\r\n\r\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/users/versioning.implementation-details.md).**\r\n\r\n## Contents\r\n\r\n* [Minimum versioning](#minimum-versioning)\r\n* [Constraint resolution](#constraint-resolution)\r\n* [Acquiring port versions](#acquiring-port-versions)\r\n\r\n\r\n### Minimum versioning\r\nVcpkg uses a minimal selection approach to versioning, inspired by the one [used by Go](https://research.swtch.com/vgo-mvs). But modified in some ways:\r\n\r\n* Always starts from a fresh install, eliminates the need for upgrade/downgrade operations.\r\n* Allow unconstrained dependencies by introducing baselines.\r\n\r\nThe minimal selection principle, however, stays the same. Given a set of constraints, vcpkg will use the \"oldest\" possible versions of packages that can satisfy all the constraints.\r\n \r\nUsing a minimum version approach has the following advantages:\r\n* Is predictable and easy to understand.\r\n* User controls when upgrades happen, as in, no upgrades are performed automatically when a new version is released.\r\n* Avoids using a SAT solver.\r\n\r\nTo give an example, consider the following package graph:\r\n```\r\n    (A 1.0) -> (B 1.0)\r\n    \r\n    (A 1.1) -> (B 1.0) \r\n            -> (C 3.0) \r\n    \r\n    (A 1.2) -> (B 2.0)\r\n            -> (C 3.0)\r\n\r\n    (C 2.0)\r\n```\r\n\r\nAnd the following manifest:\r\n```\r\n{\r\n    \"name\": \"example\",\r\n    \"version\": \"1.0.0\",\r\n    \"dependencies\": [ \r\n        { \"name\": \"A\", \"version>=\": \"1.1\" },\r\n        { \"name\": \"C\", \"version>=\": \"2.0\" }\r\n    ], \r\n    \"builtin-baseline\": \"<some git commit with A's baseline at 1.0>\"\r\n}\r\n```\r\n\r\nAfter accounting for transitive dependencies we have the following set of constraints:\r\n* A >= 1.1\r\n    * B >= 1.0\r\n    * C >= 3.0\r\n* C >= 2.0\r\n\r\nSince vcpkg has to satisfy all the constraints, the set of installed packages becomes:\r\n\r\n* `A 1.1`, even when `A 1.2` exists, there are no constraints higher than `1.1` so vcpkg selects the minimum version possible.\r\n* `B 1.0`, transitively required by `A 1.1`.\r\n* `C 3.0`, upgraded by the transitive constraint added by `B 1.0` in order to satisfy version constraints.\r\n\r\n## Constraint resolution\r\nGiven a manifest with a set of versioned dependencies, vcpkg will attempt to calculate a package installation plan that satisfies all the constraints. \r\n\r\nVersion constraints come in the following flavors:\r\n* **Declared constraints**: Constraints declared explicitly in the top-level manifest using `version>=`.\r\n* **Baseline constraints**: Constraints added implicitly by the `builtin-baseline`.\r\n* **Transitive constraints**: Constraints added indirectly by dependencies of your dependencies.\r\n* **Overridden constraints**: Constraints overridden in the top-level manifest using `overrides` declarations.\r\n\r\nTo compute an installation plan, vcpkg follows roughly these steps:\r\n\r\n* Add all top-level constraints to the plan.\r\n* Recursively add transitive constraints to the plan.\r\n    * Each time a new package is added to the plan, also add its baseline constraint to the plan.\r\n    * Each time a constraint is added:\r\n    * If an override exists for the package\r\n        * Select the version in the override.\r\n    * Otherwise:\r\n        * If there is no previous version selected. \r\n            * Select the minimal version that satisfies the constraint.\r\n        * If there is a previous version selected:\r\n            * If the versioning scheme of the new constraint does not match that of the previously selected version:\r\n                * Add a version conflict.\r\n            * If the constraint's version is not comparable to the previously selected version. For example, comparing \"version-string: apple\" to \"version-string: orange\":\r\n                * Add a version conflict.\r\n            * If the constraints version is higher than the previously selected version:\r\n                * Select the highest version.\r\n            * Otherwise: \r\n                * Keep the previous selection.\r\n* Review the plan:\r\n  * If there are no conflicts\r\n    * Install the selected packages\r\n  * Otherwise:\r\n    * Report the conflicts to the user\r\n\r\n## Acquiring port versions\r\nAlthough the concept of package versions has always been present in vcpkg, the concept of version constraints has been not.\r\n\r\nWith the introduction of versioning constraints, it is now possible that a package depends on a port version that does not match the one available locally. This raises a problem as vcpkg needs to know how to acquire the port files for the requested version.\r\n\r\nTo solve this problem, a new set of metadata files was introduced. These files are located in the `versions/` directory at the root level of the vcpkg repository.\r\n\r\nThe `versions/` directory, will contain JSON files for each one of the ports available in the registry. Each file will list all the versions available for a package and contain a Git tree-ish object that vcpkg can check out to obtain that version's portfiles.\r\n\r\nExample: `zlib.json`\r\n\r\n```\r\n{\r\n  \"versions\": [\r\n    {\r\n      \"git-tree\": \"2dfc991c739ab9f2605c2ad91a58a7982eb15687\",\r\n      \"version-string\": \"1.2.11\",\r\n      \"port-version\": 9\r\n    },\r\n    ...\r\n    {\r\n      \"git-tree\": \"a516e5ee220c8250f21821077d0e3dd517f02631\",\r\n      \"version-string\": \"1.2.10\",\r\n      \"port-version\": 0\r\n    },\r\n    {\r\n      \"git-tree\": \"3309ec82cd96d752ff890c441cb20ef49b52bf94\",\r\n      \"version-string\": \"1.2.8\",\r\n      \"port-version\": 0\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\nFor each port, its corresponding versions file should be located in `versions/{first letter of port name}-/{port name}.json`. For example, zlib's version file will be located in `versions/z-/zlib.json`. Aside from port version files, the current baseline file is located in `versions/baseline.json`.\r\n\r\n\r\n","Nav":"#"},{"Path":"/en/docs/users/versioning.html","Name":"Versioning","Source":"# Versioning\r\n\r\n**The latest version of this documentation is available on [GitHub](https://github.com/Microsoft/vcpkg/tree/master/docs/users/versioning.md).**\r\n\r\nVersioning allows you to deterministically control the precise revisions of dependencies used by\r\nyour project from within your manifest file.\r\n\r\nSee our guide to [getting started with versioning](../examples/versioning.getting-started.md).\r\n\r\n## Contents\r\n\r\n* [Version schemes](#version-schemes)\r\n  * [`version`](#version)\r\n  * [`version-semver`](#version-semver)\r\n  * [`version-date`](#version-date)\r\n  * [`version-string`](#version-string)\r\n* [Version constraints](#version-constraints)\r\n* [Version files](#version-files)\r\n\r\n## Version schemes\r\nPorts in vcpkg should attempt to follow the versioning conventions used by the package's authors. For that reason, when declaring a package's version the appropriate scheme should be used.\r\n\r\nEach versioning scheme defines its own rules on what is a valid version string and more importantly the rules for how to sort versions using the same scheme.\r\n\r\nThe versioning schemes understood by vcpkg are:\r\n\r\nManifest property | Versioning scheme\r\n------------------|------------------------------------\r\n`version`         | For dot-separated numeric versions\r\n`version-semver`  | For SemVer compliant versions\r\n`version-date`    | For dates in the format YYYY-MM-DD\r\n`version-string`  | For arbitrary strings\r\n\r\nA manifest must contain only one version declaration. \r\n\r\n_NOTE: By design, vcpkg does not compare versions that use different schemes. For example, a package\r\nthat has a `version-string: 7.1.3` cannot be compared with the same package using `version: 7.1.4`, even if the\r\nconversion seems obvious._\r\n\r\n#### `version`\r\nAccepts version strings that follow a relaxed, dot-separated-, semver-like scheme.\r\n\r\nThe version is logically composed of dot-separated (`.`) numeric sections. Each section must contain an integer positive number with no leading zeroes.\r\n\r\nThe regex pattern for this versioning scheme is: `(0|[1-9]\\d*)(\\.(0|[1-9]\\d*))*`\r\n\r\n_Sorting behavior_: When comparing two versions, each section is compared from left to right by their numeric value, until the first difference is found. A version with the smallest set of sections takes precedence over another with a larger set of sections, given that all their preceding sections compare equally.\r\n\r\nExample:\r\n`0` < `0.1` < `0.1.0` < `1` < `1.0.0` < `1.0.1` < `1.1`< `2.0.0`\r\n\r\n#### `version-semver`\r\nAccepts version strings that follow semantic versioning conventions as described in the [semantic versioning specification](https://semver.org/#semantic-versioning-specification-semver).\r\n\r\n_Sorting behavior_: Strings are sorted following the rules described in the semantic versioning specification.\r\n\r\nExample:\r\n`1.0.0-1` < `1.0.0-alpha` < `1.0.0-beta` < `1.0.0` < `1.0.1` < `1.1.0`\r\n\r\n#### `version-date`\r\n\r\nAccepts version strings that can be parsed to a date following the ISO-8601 format `YYYY-MM-DD`. Disambiguation identifiers are allowed in the form of dot-separated-, positive-, integer-numbers with no leading zeroes.\r\n\r\nThis is the recommended versioning scheme for \"Live at HEAD\" libraries that don't have established release versions.\r\n\r\nThe regex pattern for this versioning scheme is: `\\d{4}-\\d{2}-\\d{2}(\\.(0|[1-9]\\d*))*`\r\n\r\n_Sorting behavior_: Strings are sorted first by their date part, then by numeric comparison of their disambiguation identifiers. Disambiguation identifiers follow the rules of the relaxed (`version`) scheme.\r\n\r\nExamples:\r\n`2021-01-01` < `2021-01-01.1` < `2021-02-01.1.2` < `2021-02-01.1.3` < `2021-02-01`\r\n\r\n#### `version-string`\r\nFor packages using version strings that do not fit any of the other schemes, it accepts most arbitrary strings.  The `#` which is used to denote port versions is disallowed.\r\n\r\n_Sorting behavior_: No sorting is attempted on the version string itself. However, if the strings match exactly, their port versions can be compared and sorted.\r\n\r\nExamples:\r\n* `apple` <> `orange` <> `orange.2` <> `orange2`\r\n* `watermelon#0`< `watermelon#1`\r\n\r\n#### `port-version`\r\nA positive integer value that increases each time a vcpkg-specific change is made to the port.\r\n\r\nThe rules for port versions are:\r\n* Start at 0 for the original version of the port,\r\n* increase by 1 each time a vcpkg-specific change is made to the port that does not increase the version of the package,\r\n* and reset to 0 each time the version of the package is updated.\r\n\r\n_NOTE: Whenever vcpkg output a version it follows the format `<version>#<port version>`. For example `1.2.0#2` means version `1.2.0` port version `2`. When the port version is `0` the `#0` suffix is omitted (`1.2.0` implies version `1.2.0` port version `0`)._\r\n\r\n_Sorting behavior_: If two versions compare equally, their port versions are compared by their numeric value, lower port versions take precedence.\r\n\r\nExamples:\r\n* `1.2.0` < `1.2.0#1` < `1.2.0#2` < `1.2.0#10`\r\n* `2021-01-01#20` < `2021-01-01.1`\r\n* `windows#7` < `windows#8`\r\n\r\n## Version constraints\r\n\r\n### `builtin-baseline`\r\nAccepts a Git commit ID. Vcpkg will try to find a baseline file in the given commit ID and use that to set the baseline versions (lower bounds) of all dependencies.\r\n\r\nBaselines provide stability and ease of development for top-level manifest files. They are not considered from ports consumed as a dependency. If a minimum version constraint is required during transitive version resolution, the port should use `version>=`.\r\n\r\nExample:\r\n```json\r\n{\r\n  \"name\": \"project\",\r\n  \"version\": \"1.0.0\",\r\n  \"dependencies\": [\"zlib\", \"fmt\"],\r\n  \"builtin-baseline\":\"9fd3bd594f41afb8747e20f6ac9619f26f333cbe\"\r\n}\r\n```\r\n\r\nYou can get the current commit of your vcpkg instance either by adding an empty `\"builtin-baseline\"` field, installing, and examining the error message or by running `git rev-parse HEAD` in the root of the vcpkg instance.\r\n\r\nWhen resolving version constraints for a package, vcpkg will look for a baseline version by looking\r\nat the baseline file in the given commit ID.\r\nIf the given commit ID doesn't have a `versions/baseline.json` file or if the baseline file exists\r\nbut it does not declare a baseline version for the package the invocation will fail.\r\n### `version>=`\r\nExpresses a minimum version requirement, `version>=` declarations put a lower boundary on the versions that can be used to satisfy a dependency.\r\n\r\n**Note: Vcpkg selects the lowest version that matches all constraints, so a less-than constraint is not required.**\r\n\r\nExample:\r\n```json\r\n{\r\n  \"name\": \"project\",\r\n  \"version-semver\": \"1.0.0\",\r\n  \"dependencies\": [\r\n    { \"name\": \"zlib\", \"version>=\": \"1.2.11#9\" },\r\n    { \"name\": \"fmt\", \"version>=\": \"7.1.3#1\" }\r\n  ],\r\n  \"builtin-baseline\":\"3426db05b996481ca31e95fff3734cf23e0f51bc\"\r\n}\r\n```\r\n\r\nAs part of a version constraint declaration, a port version can be specified by adding the suffix `#<port-version>`, in the previous example `1.2.11#9` refers to version `1.2.11` port version `9`.\r\n\r\n### `overrides`\r\nDeclaring an override forces vcpkg to ignore all other version constraints and use the version specified in the override. This is useful for pinning exact versions and for resolving version conflicts.\r\n\r\nOverrides are declared as an array of package version declarations.\r\n\r\nFor an override to take effect, the overridden package must form part of the dependency graph. That means that a dependency must be declared either by the top-level manifest or be part of a transitive dependency.\r\n\r\n```json\r\n{\r\n  \"name\": \"project\",\r\n  \"version-semver\": \"1.0.0\",\r\n  \"dependencies\": [\r\n    { \"name\": \"zlib\", \"version>=\": \"1.2.11#9\" },\r\n    \"fmt\"\r\n  ],\r\n  \"builtin-baseline\":\"3426db05b996481ca31e95fff3734cf23e0f51bc\",\r\n  \"overrides\": [\r\n    { \"name\": \"fmt\", \"version\": \"6.0.0\" }\r\n  ]\r\n}\r\n```\r\n\r\n## Version files\r\nVcpkg uses a set of metadata files to power its versioning feature.\r\n\r\nThese files are located in the following locations:\r\n* `${VCPKG_ROOT}/versions/baseline.json`, (this file is common to all ports) and\r\n* `${VCPKG_ROOT}/versions/${first-letter-of-portname}-/${portname}.json` (one per port).\r\n\r\nFor example, for `zlib` the relevant files are:\r\n* `${VCPKG_ROOT}/versions/baseline.json`\r\n* `${VCPKG_ROOT}/versions/z-/zlib.json`\r\n\r\nThe vcpkg public CI checks validate that each time a port is added or updated its respective version files are also updated.\r\n\r\n### Baseline file\r\nThe baseline file located in `${VCPKG_ROOT}/versions/baseline.json` is used to declared the current baseline versions of all packages.\r\n\r\nFor example:\r\n```json\r\n{\r\n  \"default\": {\r\n    \"3fd\": { \"baseline\": \"2.6.3\", \"port-version\": 0 },\r\n    \"7zip\": { \"baseline\": \"19.00\", \"port-version\": 2 },\r\n    \"abseil\": { \"baseline\": \"2020-09-23\", \"port-version\": 1 }\r\n  }\r\n}\r\n```\r\n\r\nProvided that there are no local modifications to the ports, the versions of all packages in the baseline file should map to the version of their corresponding portfiles in the `ports/` directory.\r\n\r\n### Versions file\r\nEach port in vcpkg has a corresponding versions file, the location of a port's versions file follows the pattern:\r\n\r\n```sh\r\n${VCPKG_ROOT}/versions/${first-letter-of-portname}-/${portname}.json\r\n```\r\n\r\nFor example, for `zlib` the corresponding versions file is:\r\n\r\n```sh\r\n${VCPKG_ROOT}/versions/z-/zlib.json\r\n```\r\n\r\nThese files contain an array of all the versions available for a given port.\r\nFor example, the contents of `versions/z-/zlib.json` declare the following versions:\r\n```json\r\n{\r\n  \"versions\": [\r\n    {\r\n      \"git-tree\": \"827111046e37c98153d9d82bb6fa4183b6d728e4\",\r\n      \"version-string\": \"1.2.11\",\r\n      \"port-version\": 9\r\n    },\r\n    {\r\n      \"git-tree\": \"068430e3e24fa228c302c808ba99f8a48d126557\",\r\n      \"version-string\": \"1.2.11\",\r\n      \"port-version\": 8\r\n    },\r\n    ...\r\n  ]\r\n}\r\n```\r\nEach version declared in this file uses the same syntax used in manifest files, but adds an extra `git-tree` property. The value of `git-tree` is the SHA hash, as calculated by Git, of the directory containing the portfiles for the declared version. You can ask Git for the object SHA via the syntax:\r\n```\r\ngit rev-parse <commit>:<path>\r\n```\r\nFor example,\r\n```\r\ngit rev-parse HEAD:ports/zlib\r\n```\r\n\r\n### Updating the version files\r\nThe recommended method to update these files is to run the `x-add-version` command.\r\n\r\nFor example, if you have made changes to `zlib`:\r\n\r\n```\r\nvcpkg x-add-version zlib\r\n```\r\n\r\nIf you're updating multiple ports at the same time, instead you can run:\r\n\r\n```\r\nvcpkg x-add-version --all\r\n```\r\n\r\nTo update the files for all modified ports at once.\r\n\r\n_NOTE: These commands require you to have committed your changes to the ports before running them. The reason is that the Git SHA of the port directory is required in these version files. But don't worry, the `x-add-version` command will warn you if you have local changes that haven't been committed._\r\n\r\n## See Also\r\n\r\n* The [implementation details](versioning.implementation-details.md)\r\n* The [original specification](../specifications/versioning.md)\r\n\r\n","Nav":"#"}]